<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>深度解析 LayoutNode 的测量、布局原理 - wikiHow</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="wikiHow"><meta name="msapplication-TileImage" content="/img/wiki.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="wikiHow"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="深入源码，层层解析，带你完全吃透 LayoutNode 的测量、摆放流程，在此基础上更加深度解析 Modifier.layout()、NodeCoordinator 的原理！"><meta property="og:type" content="blog"><meta property="og:title" content="深度解析 LayoutNode 的测量、布局原理"><meta property="og:url" content="http://example.com/2025/08/10/compose/Compose%20--%20Modifier%20--%2003.%20%E8%A7%A3%E6%9E%90%20Modifier.layout()/"><meta property="og:site_name" content="wikiHow"><meta property="og:description" content="深入源码，层层解析，带你完全吃透 LayoutNode 的测量、摆放流程，在此基础上更加深度解析 Modifier.layout()、NodeCoordinator 的原理！"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/gallery/covers/compose/cover_modifier_3.png"><meta property="article:published_time" content="2025-08-09T16:00:00.000Z"><meta property="article:modified_time" content="2025-08-19T09:10:03.943Z"><meta property="article:author" content="Marco"><meta property="article:tag" content="Compose"><meta property="article:tag" content="Modifier"><meta property="article:tag" content="LayoutModifier"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/gallery/covers/compose/cover_modifier_3.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2025/08/10/compose/Compose%20--%20Modifier%20--%2003.%20%E8%A7%A3%E6%9E%90%20Modifier.layout()/"},"headline":"深度解析 LayoutNode 的测量、布局原理","image":["http://example.com/gallery/covers/compose/cover_modifier_3.png"],"datePublished":"2025-08-09T16:00:00.000Z","dateModified":"2025-08-19T09:10:03.943Z","author":{"@type":"Person","name":"Marco"},"publisher":{"@type":"Organization","name":"wikiHow","logo":{"@type":"ImageObject","url":"http://example.com/img/wikihow.svg"}},"description":"深入源码，层层解析，带你完全吃透 LayoutNode 的测量、摆放流程，在此基础上更加深度解析 Modifier.layout()、NodeCoordinator 的原理！"}</script><link rel="canonical" href="http://example.com/2025/08/10/compose/Compose%20--%20Modifier%20--%2003.%20%E8%A7%A3%E6%9E%90%20Modifier.layout()/"><link rel="icon" href="/img/wiki.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/wikihow.svg" alt="wikiHow" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/pepsimaxin"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/gallery/covers/compose/cover_modifier_3.png" alt="深度解析 LayoutNode 的测量、布局原理"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-08-09T16:00:00.000Z" title="2025/8/10 00:00:00">2025-08-10</time>发表</span><span class="level-item"><time dateTime="2025-08-19T09:10:03.943Z" title="2025/8/19 17:10:03">2025-08-19</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Compose/">Compose</a><span> / </span><a class="link-muted" href="/categories/Compose/Modifier/">Modifier</a></span></div></div><h1 class="title is-3 is-size-4-mobile">深度解析 LayoutNode 的测量、布局原理</h1><div class="content"><hr>
<div class="notification is-danger">
<p>其实原理性分析的文章，真的很难讲的通俗易懂，讲的简单浅显没必要写，讲的繁琐难懂往往大家也不乐意看，所以怎么找个好的角度慢慢钻进去尤为重要，比如：Begin simple code！</p>
</div>

<article class="message is-info"><div class="message-body">
<p>基于 androidx.compose.runtime:runtime:1.7.1 版本</p>
</div></article>

<h1 id="Simple-Code"><a href="#Simple-Code" class="headerlink" title="Simple Code"></a>Simple Code</h1><hr>
<h2 id="一个-Text"><a href="#一个-Text" class="headerlink" title="一个 Text()"></a>一个 Text()</h2><p>先来看一段最简单的代码示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">ComponentActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContent &#123;</span><br><span class="line">            ComposeBlogTheme &#123;</span><br><span class="line">                Box(Modifier.background(Color.Green)) &#123;</span><br><span class="line">                    Text(<span class="string">&quot;Hi Compose&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码很简单，效果图如下：</p>
<img src="https://v1.ax1x.com/2025/08/18/EPWp1s.png" alt="" border="0" width="500"/>

<br>

<br>

<p>接下来基于这个 Demo，我们会慢慢引入本篇文章的主角。</p>
<hr>
<h2 id="Modifier-layout"><a href="#Modifier-layout" class="headerlink" title="Modifier.layout()"></a>Modifier.layout()</h2><p>在 Compose 中 <span style="color: #FF5A00;">Modifier.layout() 是一种「布局修饰符」</span>：<br>⤵︎<br>它会包裹一个布局节点：LayoutNode（什么是 LayoutNode，下面会讲），<br>⤵︎<br><span style="color: #085DFF;">通常用作对目标组件「进行测量」和「位置摆放」的</span>。</p>
<br>

<p><strong>讲的更直白一点就是：</strong><br>⤵︎<br>你可以用 <span style="color: #FF5A00;">Modifier.layout()</span> 来<span style="color: #085DFF;">「自定义目标组件的测量过程」</span>以及<span style="color: #085DFF;">「决定目标组件怎么摆放」</span>。</p>
<br>

<p>我们先来看看在代码中怎么使用，通常会像下面这样写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">ComponentActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContent &#123;</span><br><span class="line">            ComposeBlogTheme &#123;</span><br><span class="line">                Box(Modifier.background(Color.Green)) &#123;</span><br><span class="line">                    Text(<span class="string">&quot;Hi Compose&quot;</span>,</span><br><span class="line">                        Modifier.layout &#123; measurable, constraints -&gt;  &#125;</span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就这么简单，<code>Text</code> 就是目标组件，我们给它加了一个 Modifier.layout()，没有添加任何其他代码逻辑，</p>
<p><code>&#123; measurable, constraints -&gt;  &#125;</code> 是自动生成的，</p>
<p>此时你会发现在 Android Studio IDLE 中，这样写是会标红的：</p>
<img src="https://v1.ax1x.com/2025/08/18/EPWL6a.png" alt="" border="0" width="700"/>

<br>

<br>

<p>正常来说，我这里什么也不填不就相当于对 Text() 不做任何修饰吗？但很明显这样是不行的，代码已经报错了！</p>
<p><strong>接下来我们一起尝试解决这个报错！</strong></p>
<p>首先我们发现当使用 Modifier.layout{} 修饰符时，传入的回调 lambda 包含了两个参数：</p>
<div class="buttons">
  <button class="button is-info">measurable</button> ：用于子元素的测量和位置放置；
</div>

<div class="buttons">
  <button class="button is-warning">constraints</button> ：用于约束子元素 width 和 height 的最大值和最小值。
</div>

<p>我们定位到 Modifier.layout() 的源码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">📄 androidx.compose.ui.layout --&gt; LayoutModifier.kt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Modifier.<span class="title">layout</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    measure: <span class="type">MeasureScope</span>.(<span class="type">Measurable</span>, <span class="type">Constraints</span>) -&gt; <span class="type">MeasureResult</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> = <span class="keyword">this</span> then LayoutElement(measure)</span><br></pre></td></tr></table></figure>

<p>发现没？measurable 对应的是 Measurable：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">📄 androidx.compose.ui.layout --&gt; Measurable.kt</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Measurable</span> : <span class="type">IntrinsicMeasurable</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Measures the layout with [constraints], returning a [Placeable] layout that has its new</span></span><br><span class="line"><span class="comment">     * size. A [Measurable] can only be measured once inside a layout pass.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 返回一个 Placeable，它里面包含目标组件的宽、高等信息</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">measure</span><span class="params">(constraints: <span class="type">Constraints</span>)</span></span>: Placeable</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Measurable 是一个接口，内部仅有一个 <span style="color: #FF0000; font-weight: bold;">measure()</span> 方法。</p>
<p>所以现在可以开始修改刚才的报错了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">ComponentActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContent &#123;</span><br><span class="line">            ComposeBlogTheme &#123;</span><br><span class="line">                Box(Modifier.background(Color.Green)) &#123;</span><br><span class="line">                    Text(<span class="string">&quot;Hi Compose&quot;</span>,</span><br><span class="line">                        Modifier.layout &#123; measurable, constraints -&gt;</span><br><span class="line">                            <span class="comment">// 用一个变量保存返回的 Placeable 对象</span></span><br><span class="line">                            <span class="keyword">val</span> placeable = measurable.measure(constraints)</span><br><span class="line">                        &#125;</span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在代码仍然是标红报错的，原因在于：我们只处理了 measurable，它返回的是 Placeable，而 Modifier.layout() 需要返回的类型是 <span style="color: #085DFF; font-weight: bold;">MeasureResult</span>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Modifier.<span class="title">layout</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    measure: <span class="type">MeasureScope</span>.(<span class="type">Measurable</span>, <span class="type">Constraints</span>) -&gt; <span class="type">MeasureResult</span>  <span class="comment">// 需要返回 MeasureResult</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> = <span class="keyword">this</span> then LayoutModifierElement(measure)</span><br></pre></td></tr></table></figure>

<p>所以 MeasureResult 又是什么？</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">📄 androidx.compose.ui.layout --&gt; MeasureResult.kt</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MeasureResult</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> width: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">val</span> height: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">val</span> alignmentLines: Map&lt;AlignmentLine, <span class="built_in">Int</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">placeChildren</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MeasureResult 也是一个接口，它里面也有 <u><strong>width</strong></u> 和 <u><strong>height</strong></u>，继续修复刚才的报错：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">ComponentActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContent &#123;</span><br><span class="line">            ComposeBlogTheme &#123;</span><br><span class="line">                Text(<span class="string">&quot;ComposeTest&quot;</span>,</span><br><span class="line">                    Modifier.layout &#123; measurable, constraints -&gt;</span><br><span class="line">                        <span class="keyword">val</span> placeable = measurable.measure(constraints)</span><br><span class="line">                        <span class="keyword">object</span> : MeasureResult &#123;</span><br><span class="line">                            <span class="keyword">override</span> <span class="keyword">val</span> alignmentLines: Map&lt;AlignmentLine, <span class="built_in">Int</span>&gt;</span><br><span class="line">                                <span class="keyword">get</span>() = TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">                            <span class="keyword">override</span> <span class="keyword">val</span> height: <span class="built_in">Int</span></span><br><span class="line">                                <span class="keyword">get</span>() = TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">                            <span class="keyword">override</span> <span class="keyword">val</span> width: <span class="built_in">Int</span></span><br><span class="line">                                <span class="keyword">get</span>() = TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">placeChildren</span><span class="params">()</span></span> &#123;</span><br><span class="line">                                TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然 Modifier.layout()  需要一个 MeasureResult 返回对象，那我们就在内部给它创建一个 MeasureResult 对象，此时 IDLE 就不会再报错了。</p>
<p>当然我们还需要做一个工作，那就是把 placeable 的宽高传进 MeasureResult 内部，所以最终的代码修改如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">ComponentActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContent &#123;</span><br><span class="line">            ComposeBlogTheme &#123;</span><br><span class="line">                Box(Modifier.background(Color.Green)) &#123;</span><br><span class="line">                    Text(<span class="string">&quot;Hi Compose&quot;</span>,</span><br><span class="line">                        Modifier.layout &#123; measurable, constraints -&gt;</span><br><span class="line">                            <span class="keyword">val</span> placeable = measurable.measure(constraints)</span><br><span class="line">                            <span class="keyword">object</span> : MeasureResult &#123;</span><br><span class="line">                                <span class="comment">// 测量基准线，暂时不用关心</span></span><br><span class="line">                                <span class="keyword">override</span> <span class="keyword">val</span> alignmentLines: Map&lt;AlignmentLine, <span class="built_in">Int</span>&gt;</span><br><span class="line">                                    <span class="keyword">get</span>() = TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">                                <span class="comment">// 高：placeable.height</span></span><br><span class="line">                                <span class="keyword">override</span> <span class="keyword">val</span> height: <span class="built_in">Int</span></span><br><span class="line">                                    <span class="keyword">get</span>() = placeable.height</span><br><span class="line">                                <span class="comment">// 宽：placeable.width</span></span><br><span class="line">                                <span class="keyword">override</span> <span class="keyword">val</span> width: <span class="built_in">Int</span></span><br><span class="line">                                    <span class="keyword">get</span>() = placeable.width</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 摆放内部组件，暂时不用关心</span></span><br><span class="line">                                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">placeChildren</span><span class="params">()</span></span> &#123;</span><br><span class="line">                                    TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此报错就修复了，上面的代码演示了对 Text() 添加 Modifier.layout() 进行修饰（当然上面的做法等同于啥也没做）。</p>
<p>但这段代码有个缺陷：如果每次通过 Modifier.layout() 对组件修饰，都得像上面这样写一堆代码，那还不得疯？</p>
<hr>
<h2 id="layout-函数"><a href="#layout-函数" class="headerlink" title="layout() 函数"></a>layout() 函数</h2><p>其实在实际开发中我们并不会这么写，而是使用 Compose 提供给我们的 <font color="#085DFF"><strong>layout() 函数</strong></font>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">ComponentActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContent &#123;</span><br><span class="line">            ComposeBlogTheme &#123;</span><br><span class="line">                Box(Modifier.background(Color.Green)) &#123;</span><br><span class="line">                    Text(<span class="string">&quot;Hi Compose&quot;</span>,</span><br><span class="line">                        Modifier.layout &#123; measurable, constraints -&gt;</span><br><span class="line">                            <span class="keyword">val</span> placeable = measurable.measure(constraints)</span><br><span class="line">                            <span class="comment">/*object : MeasureResult &#123;</span></span><br><span class="line"><span class="comment">                                override val alignmentLines: Map&lt;AlignmentLine, Int&gt;</span></span><br><span class="line"><span class="comment">                                    get() = TODO(&quot;Not yet implemented&quot;)</span></span><br><span class="line"><span class="comment">                                override val height: Int</span></span><br><span class="line"><span class="comment">                                    get() = TODO(&quot;Not yet implemented&quot;)</span></span><br><span class="line"><span class="comment">                                override val width: Int</span></span><br><span class="line"><span class="comment">                                    get() = TODO(&quot;Not yet implemented&quot;)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                                override fun placeChildren() &#123;</span></span><br><span class="line"><span class="comment">                                    TODO(&quot;Not yet implemented&quot;)</span></span><br><span class="line"><span class="comment">                                &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                            &#125;*/</span></span><br><span class="line">                            layout() &#123;</span><br><span class="line">                                </span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看下 layout() 源码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">📄 androidx.compose.ui.layout --&gt; MeasureScope.kt</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MeasureScope</span> : <span class="type">IntrinsicMeasureScope</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">layout</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        width: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        height: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        alignmentLines: <span class="type">Map</span>&lt;<span class="type">AlignmentLine</span>, <span class="built_in">Int</span>&gt; = emptyMap()</span></span>,</span><br><span class="line">        placementBlock: Placeable.PlacementScope.() -&gt; <span class="built_in">Unit</span></span><br><span class="line">    ) = layout(width, height, alignmentLines, <span class="literal">null</span>, placementBlock)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">layout</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        width: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        height: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        alignmentLines: <span class="type">Map</span>&lt;<span class="type">AlignmentLine</span>, <span class="built_in">Int</span>&gt; = emptyMap()</span></span>,</span><br><span class="line">        rulers: (RulerScope.() -&gt; <span class="built_in">Unit</span>)? = <span class="literal">null</span>,</span><br><span class="line">        placementBlock: Placeable.PlacementScope.() -&gt; <span class="built_in">Unit</span></span><br><span class="line">    ): MeasureResult &#123;</span><br><span class="line">        checkMeasuredSize(width, height)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">object</span> : MeasureResult &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="keyword">val</span> width = width</span><br><span class="line">            <span class="keyword">override</span> <span class="keyword">val</span> height = height</span><br><span class="line">            <span class="keyword">override</span> <span class="keyword">val</span> alignmentLines = alignmentLines</span><br><span class="line">            <span class="keyword">override</span> <span class="keyword">val</span> rulers = rulers</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">placeChildren</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="comment">// This isn&#x27;t called from anywhere inside the compose framework. This might</span></span><br><span class="line">                <span class="comment">// be called by tests or external frameworks.</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span><span class="symbol">@MeasureScope</span> <span class="keyword">is</span> LookaheadCapablePlaceable) &#123;</span><br><span class="line">                    placementScope.placementBlock()</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    SimplePlacementScope(</span><br><span class="line">                        width,</span><br><span class="line">                        layoutDirection</span><br><span class="line">                    ).placementBlock()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显 layout() 函数帮我们创建好了 MeasureResult 对象，同时它还帮我们干了另外两件没做的事：</p>
<ol>
<li>给 alignmentLines 设定了默认值；</li>
<li>实现了 placeChildren()。</li>
</ol>
<p>所以，我们现在只需要补全 layout() 函数剩余的两个参数：<u><strong>width</strong></u> 和 <u><strong>height</strong></u>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">ComponentActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContent &#123;</span><br><span class="line">            ComposeBlogTheme &#123;</span><br><span class="line">                Box(Modifier.background(Color.Green)) &#123;</span><br><span class="line">                    Text(<span class="string">&quot;Hi Compose&quot;</span>,</span><br><span class="line">                        Modifier.layout &#123; measurable, constraints -&gt;</span><br><span class="line">                            <span class="keyword">val</span> placeable = measurable.measure(constraints)</span><br><span class="line">                            layout(placeable.width, placeable.height) &#123;</span><br><span class="line"></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样写代码是不是瞬间感觉清爽了很多？但工作到这边还没有结束，layout() 函数还有第四个参数，是一个 Lambda 表达式，<font color="#085DFF"><strong>主要工作是处理被修饰组件的摆放规则</strong></font>，比如偏移量。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">layout</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    width: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    height: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    alignmentLines: <span class="type">Map</span>&lt;<span class="type">AlignmentLine</span>, <span class="built_in">Int</span>&gt; = emptyMap()</span></span>,</span><br><span class="line">    placementBlock: Placeable.PlacementScope.() -&gt; <span class="built_in">Unit</span>    <span class="comment">// Lambda 表达式</span></span><br><span class="line">) = <span class="keyword">object</span> : MeasureResult &#123;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们继续完善：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">ComponentActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContent &#123;</span><br><span class="line">            ComposeBlogTheme &#123;</span><br><span class="line">                Box(Modifier.background(Color.Green)) &#123;</span><br><span class="line">                    Text(<span class="string">&quot;Hi Compose&quot;</span>,</span><br><span class="line">                        Modifier.layout &#123; measurable, constraints -&gt;</span><br><span class="line">                            <span class="keyword">val</span> placeable = measurable.measure(constraints)</span><br><span class="line">                            layout(placeable.width, placeable.height) &#123;</span><br><span class="line">                                <span class="comment">// 不做任何偏移</span></span><br><span class="line">                                placeable.placeRelative(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在所有工作（测量 + 摆放）都已完成，运行看下效果：</p>
<img src="https://v1.ax1x.com/2025/08/18/EPW3N7.png" alt="" border="0" width="500"/>

<br>

<br>

<p>可以看出来，没有任何变化，因为我们虽然用 Modifier.layout() 对 Text 做修饰，但并没有对它做任何尺寸修改和位置偏移。</p>
<p>那如果我现在想修改 Text() 的尺寸，该怎么做？</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">ComponentActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContent &#123;</span><br><span class="line">            ComposeBlogTheme &#123;</span><br><span class="line">                Box(Modifier.background(Color.Green)) &#123;</span><br><span class="line">                    Text(<span class="string">&quot;Hi Compose&quot;</span>,</span><br><span class="line">                        Modifier.layout &#123; measurable, constraints -&gt;</span><br><span class="line">                            <span class="keyword">val</span> placeable = measurable.measure(constraints)</span><br><span class="line">                            <span class="keyword">val</span> size = min(placeable.width, placeable.height)</span><br><span class="line">                            layout(size, size) &#123;</span><br><span class="line">                                placeable.placeRelative(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义了一个 size 变量，通过 min() 函数获取宽高最小值，然后重新传入 layout() 里面，这样就会获得一个正方形的效果。</p>
<img src="https://v1.ax1x.com/2025/08/18/EPWlvI.png" alt="" border="0" width="500"/>

<br>

<br>

<p>尺寸修改确实生效了，接下来再增加一个偏移：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">ComponentActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContent &#123;</span><br><span class="line">            ComposeBlogTheme &#123;</span><br><span class="line">                Box(Modifier.background(Color.Green)) &#123;</span><br><span class="line">                    Text(<span class="string">&quot;Hi Compose&quot;</span>,</span><br><span class="line">                        Modifier.layout &#123; measurable, constraints -&gt;</span><br><span class="line">                            <span class="keyword">val</span> placeable = measurable.measure(constraints)</span><br><span class="line">                            <span class="keyword">val</span> size = min(placeable.width, placeable.height)</span><br><span class="line">                            layout(size, size) &#123;</span><br><span class="line">                                placeable.placeRelative(<span class="number">30</span>, <span class="number">0</span>)</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下效果：</p>
<img src="https://v1.ax1x.com/2025/08/18/EPWQ0L.png" alt="" border="0" width="500"/>

<br>

<br>

<p>另外有个细节需要说明下，除了使用 <strong>placeRelative</strong> 对组件偏移外，也可以使用 <strong>place</strong> 进行偏移操作，两者的区别就是 <strong>placeRelative</strong> 会自适应 RTL 布局。</p>
<hr>
<p>讲到这里，Modifier.layout() 修饰符和 layout() 函数的用法你应该都清楚了，但还没结束，前面我们一直忽略了一个参数：<font color="#FF0000"><strong>constraints</strong></font>，它是什么？</p>
<div class="buttons">
  <button class="button is-info">measurable</button> ：用于子元素的测量和位置放置；
</div>

<div class="buttons">
  <button class="button is-warning">constraints</button> ：用于约束子元素 width 和 height 的最大值和最小值。
</div>

<p>前面的例子并没有对 constraints 做任何修改，在实际开发过程中，我们往往需要通过 constraints 对组件进行限制。</p>
<p>比如我想对 Text() 组件进行一个限制，类似 padding 的效果，给它加一个 10dp 的最大宽高的限制（最大宽高缩减 10dp）。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">ComponentActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContent &#123;</span><br><span class="line">            ComposeBlogTheme &#123;</span><br><span class="line">                Box(Modifier.background(Color.Green)) &#123;</span><br><span class="line">                    Text(<span class="string">&quot;Hi Compose&quot;</span>,</span><br><span class="line">                        Modifier.layout &#123; measurable, constraints -&gt;</span><br><span class="line">                            <span class="keyword">val</span> paddingPx = <span class="number">10.</span>dp.roundToPx()</span><br><span class="line">                            <span class="keyword">val</span> placeable = measurable.measure(constraints.copy(</span><br><span class="line">                                maxWidth = constraints.maxWidth - paddingPx * <span class="number">2</span>,</span><br><span class="line">                                maxHeight = constraints.maxHeight - paddingPx * <span class="number">2</span></span><br><span class="line">                            ))</span><br><span class="line">                            layout(placeable.width + paddingPx * <span class="number">2</span>, placeable.height + paddingPx * <span class="number">2</span>) &#123;</span><br><span class="line">                                placeable.placeRelative(paddingPx, paddingPx)</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下效果：</p>
<img src="https://v1.ax1x.com/2025/08/18/EPWNxJ.png" alt="" border="0" width="500"/>

<br>

<br>

<p>很明显，我们实现的效果跟 Modifier.padding(10.dp) 的效果是一样的，如果你去看看 Modifier.padding 的源码，就会发现它的内部原理跟我们例子是一样的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Stable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Modifier.<span class="title">padding</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    horizontal: <span class="type">Dp</span> = <span class="number">0.</span>dp,</span></span></span><br><span class="line"><span class="params"><span class="function">    vertical: <span class="type">Dp</span> = <span class="number">0.</span>dp</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> = <span class="keyword">this</span> then PaddingElement(</span><br><span class="line">    ... ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">PaddingElement</span>(</span><br><span class="line">    <span class="keyword">var</span> start: Dp = <span class="number">0.</span>dp,</span><br><span class="line">    <span class="keyword">var</span> top: Dp = <span class="number">0.</span>dp,</span><br><span class="line">    <span class="keyword">var</span> end: Dp = <span class="number">0.</span>dp,</span><br><span class="line">    <span class="keyword">var</span> bottom: Dp = <span class="number">0.</span>dp,</span><br><span class="line">    <span class="keyword">var</span> rtlAware: <span class="built_in">Boolean</span>,</span><br><span class="line">    <span class="keyword">val</span> inspectorInfo: InspectorInfo.() -&gt; <span class="built_in">Unit</span></span><br><span class="line">) : ModifierNodeElement&lt;PaddingNode&gt;() &#123;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">PaddingNode</span>(</span><br><span class="line">    <span class="keyword">var</span> start: Dp = <span class="number">0.</span>dp,</span><br><span class="line">    <span class="keyword">var</span> top: Dp = <span class="number">0.</span>dp,</span><br><span class="line">    <span class="keyword">var</span> end: Dp = <span class="number">0.</span>dp,</span><br><span class="line">    <span class="keyword">var</span> bottom: Dp = <span class="number">0.</span>dp,</span><br><span class="line">    <span class="keyword">var</span> rtlAware: <span class="built_in">Boolean</span></span><br><span class="line">) : LayoutModifierNode, Modifier.Node() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> MeasureScope.<span class="title">measure</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        measurable: <span class="type">Measurable</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        constraints: <span class="type">Constraints</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: MeasureResult &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> horizontal = start.roundToPx() + end.roundToPx()</span><br><span class="line">        <span class="keyword">val</span> vertical = top.roundToPx() + bottom.roundToPx()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> placeable = measurable.measure(constraints.offset(-horizontal, -vertical))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> width = constraints.constrainWidth(placeable.width + horizontal)</span><br><span class="line">        <span class="keyword">val</span> height = constraints.constrainHeight(placeable.height + vertical)</span><br><span class="line">        <span class="keyword">return</span> layout(width, height) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rtlAware) &#123;</span><br><span class="line">                placeable.placeRelative(start.roundToPx(), top.roundToPx())</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                placeable.place(start.roundToPx(), top.roundToPx())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><progress class="progress is-success" value="100" max="100"></progress></p>
<h1 id="LayoutNode-浅析"><a href="#LayoutNode-浅析" class="headerlink" title="LayoutNode 浅析"></a>LayoutNode 浅析</h1><br>

<p>通过前面的例子，我们可以看出：</p>
<p><font color="#085DFF">不论是使用 Modifier.layout() 修饰符还是使用 Compose 提供给我们的现成的修饰符，比如：Modifier.padding() &#x2F; Modifier.size()，它们都会对被修饰组件产生精细影响（组件大小、位置偏移）。</font></p>
<p>但到目前为止，我们仅仅是从 UI 效果上看到 Modifier.layout() 会影响被修饰组件，但源码底层是如何产生影响的呢？</p>
<p>这才是我们这篇文章的核心价值！</p>
<div class="buttons">
  <button class="button is-danger">所以，最硬核的原理部分来了！</button>
</div>

<p>我们就拿常用的 Modifier.padding() 分析，来看下它的源码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">📄 androidx.compose.foundation.layout --&gt; Padding.kt</span><br><span class="line"></span><br><span class="line"><span class="meta">@Stable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Modifier.<span class="title">padding</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    start: <span class="type">Dp</span> = <span class="number">0.</span>dp,</span></span></span><br><span class="line"><span class="params"><span class="function">    top: <span class="type">Dp</span> = <span class="number">0.</span>dp,</span></span></span><br><span class="line"><span class="params"><span class="function">    end: <span class="type">Dp</span> = <span class="number">0.</span>dp,</span></span></span><br><span class="line"><span class="params"><span class="function">    bottom: <span class="type">Dp</span> = <span class="number">0.</span>dp</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> = <span class="keyword">this</span> then PaddingElement(</span><br><span class="line">    start = start,</span><br><span class="line">    top = top,</span><br><span class="line">    end = end,</span><br><span class="line">    bottom = bottom,</span><br><span class="line">    rtlAware = <span class="literal">true</span>,</span><br><span class="line">    inspectorInfo = &#123;</span><br><span class="line">        name = <span class="string">&quot;padding&quot;</span></span><br><span class="line">        properties[<span class="string">&quot;start&quot;</span>] = start</span><br><span class="line">        properties[<span class="string">&quot;top&quot;</span>] = top</span><br><span class="line">        properties[<span class="string">&quot;end&quot;</span>] = end</span><br><span class="line">        properties[<span class="string">&quot;bottom&quot;</span>] = bottom</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">PaddingElement</span>(</span><br><span class="line">    <span class="keyword">var</span> start: Dp = <span class="number">0.</span>dp,</span><br><span class="line">    <span class="keyword">var</span> top: Dp = <span class="number">0.</span>dp,</span><br><span class="line">    <span class="keyword">var</span> end: Dp = <span class="number">0.</span>dp,</span><br><span class="line">    <span class="keyword">var</span> bottom: Dp = <span class="number">0.</span>dp,</span><br><span class="line">    <span class="keyword">var</span> rtlAware: <span class="built_in">Boolean</span>,</span><br><span class="line">    <span class="keyword">val</span> inspectorInfo: InspectorInfo.() -&gt; <span class="built_in">Unit</span></span><br><span class="line">) : ModifierNodeElement&lt;PaddingNode&gt;() &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ModifierNodeElement</span>&lt;<span class="type">N : Modifier.Node</span>&gt; : <span class="type">Modifier.Element</span>, <span class="type">InspectableValue</span> &#123;</span><br></pre></td></tr></table></figure>

<p><strong>层级关系非常清晰：</strong></p>
<ol>
<li>Modifier.padding() 调用一个 PaddingElement()；<br>⤵︎</li>
<li>而 PaddingElement 实现了 ModifierNodeElement 类（这是个范型类，其中创建了 PaddingNode）；<br>⤵︎</li>
<li>这个 PaddingNode，会被 Compose 用于修改测量和布局过程，从而最终影响到界面元素的位置和尺寸。</li>
</ol>
<p>所以我们的重点就是要研究 <span style="color: #085DFF; font-weight: bold;">PaddingNode 是如何影响组件的！</span></p>
<br>

<p><span style="color: #FF0000; font-weight: bold;">但是！在研究 PaddingNode 原理之前，有一个核心知识点是必须要提前了解的。</span></p>
<p>来看下面这段非常熟悉的代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">ComponentActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContent &#123;</span><br><span class="line">            ComposeBlogTheme &#123;</span><br><span class="line">                Box(Modifier.background(Color.Green)) &#123;</span><br><span class="line">                    Text(<span class="string">&quot;Hi Compose&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Box 、Text 这些函数在实际运行的时候，其实并不是这些函数直接存在于内存里面，而是 Compose 利用这些函数创造出的一些对象存在于内存里面，这个对象就是：<span style="color: #008B45; font-weight: bold;">LayoutNode</span>。<br>⤵︎<br>它才是最底层的那个节点，进行实际的<span style="color: #085DFF; font-weight: bold;">「 测量、布局、绘制、触摸反馈 」</span>等工作。</p>
<div class="notification is-warning">
<p>我们既然想知道 PaddingNode 是如何精细影响 Text() 组件，那就得先研究明白 Text() 自己的测量、布局、绘制的原理，因为 PaddingNode 是包着这个 Text() 的。</p>
</div>

<p>在 LayoutNode 中（Text 实际底层节点），测量和布局是由 <span style="color: #FF0000; font-weight: bold;">remeasure()</span> 函数和 <span style="color: #FF0000; font-weight: bold;">replace()</span> 两个函数处理。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">📄 androidx.compose.ui.node --&gt; LayoutNode.kt</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">LayoutNode</span>(..) &#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">replace</span><span class="params">()</span></span>      <span class="comment">// 布局</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">remeasure</span><span class="params">()</span></span>    <span class="comment">// 测量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="remeasure"><a href="#remeasure" class="headerlink" title="remeasure()"></a>remeasure()</h2><p>我们先来分析 remeasure() 函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">📄 androidx.compose.ui.node --&gt; LayoutNode.kt</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">LayoutNode</span>(..) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">remeasure</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        constraints: <span class="type">Constraints</span>? = layoutDelegate.lastConstraints</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (constraints != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intrinsicsUsageByParent == UsageByParent.NotUsed) &#123;</span><br><span class="line">                <span class="comment">// 之前这个节点可能向子节点询问过 intrinsics（固有尺寸）</span></span><br><span class="line">                <span class="comment">// 若父节点这次不需要 intrinsics，就把整棵子树里记录的 intrinsics 使用标记清掉</span></span><br><span class="line">                clearSubtreeIntrinsicsUsage()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 核心：真正执行测量</span></span><br><span class="line"><span class="comment">             *      测量工作交给 LayoutNodeLayoutDelegate 的内部类 MeasurePassDelegate 处理</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            measurePassDelegate.remeasure(constraints)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LayoutNode 内部要处理的事情非常多，它把测量的工作交给了 MeasurePassDelegate 来处理。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">📄  androidx.compose.ui.node --&gt; LayoutNodeLayoutDelegate.kt</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">LayoutNodeLayoutDelegate</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> layoutNode: LayoutNode</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">MeasurePassDelegate</span> : <span class="type">Measurable</span>, <span class="type">Placeable</span>(), AlignmentLinesOwner,</span><br><span class="line">        MotionReferencePlacementDelegate &#123;</span><br><span class="line">	</span><br><span class="line">	    <span class="function"><span class="keyword">fun</span> <span class="title">remeasure</span><span class="params">(constraints: <span class="type">Constraints</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">	        ...</span><br><span class="line">	        <span class="keyword">if</span> (layoutNode.measurePending || measurementConstraints != constraints) &#123;</span><br><span class="line">	            ...</span><br><span class="line">	            performMeasure(constraints)    <span class="comment">// 关键代码</span></span><br><span class="line">	            ...</span><br><span class="line">	        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">	        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码很长，但我们只需要关注一行关键代码：<font color="#CD950C">performMeasure(constraints)</font>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">📄  androidx.compose.ui.node --&gt; LayoutNodeLayoutDelegate.kt</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">LayoutNodeLayoutDelegate</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> layoutNode: LayoutNode</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> performMeasureConstraints = Constraints()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> performMeasureBlock: () -&gt; <span class="built_in">Unit</span> = &#123;</span><br><span class="line">        outerCoordinator.measure(performMeasureConstraints)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">performMeasure</span><span class="params">(constraints: <span class="type">Constraints</span>)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        layoutNode.requireOwner().snapshotObserver.observeMeasureSnapshotReads(</span><br><span class="line">            layoutNode,</span><br><span class="line">            affectsLookahead = <span class="literal">false</span>,</span><br><span class="line">            performMeasureBlock   <span class="comment">// 关键代码</span></span><br><span class="line">        )</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们仍然只需要关注：<font color="#CD950C">outerCoordinator.measure(performMeasureConstraints)</font>，它是做实际测量工作的。</p>
<p>继续跟踪：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">📄  androidx.compose.ui.layout --&gt; Measurable.kt</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Measurable</span> : <span class="type">IntrinsicMeasurable</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Measures the layout with [constraints], returning a [Placeable] layout that has its new</span></span><br><span class="line"><span class="comment">     * size. A [Measurable] can only be measured once inside a layout pass.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">measure</span><span class="params">(constraints: <span class="type">Constraints</span>)</span></span>: Placeable</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><font color="#FF0000">What ？？？怎么是个接口啊，没有任何处理逻辑啊！！！</font></strong></p>
<p>转念一想，既然是个接口，那肯定有其他地方实现了这个方法，我们可以搜一下哪些地方实现了。</p>
<img src="https://v1.ax1x.com/2025/08/18/EPWgNP.png" alt="" border="0" />

<br>

<br>

<p>有 9 个地方实现了，但哪一个才是我们需要的呢？别慌，我带你找一下。</p>
<p>我们往回退，找找刚才哪里调用 measure() 方法的？</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">📄  androidx.compose.ui.node --&gt; LayoutNodeLayoutDelegate.kt</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">LayoutNodeLayoutDelegate</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> layoutNode: LayoutNode</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2. outerCoordinator 由传进来的 layoutNode 参数决定，那么我们得找找 layoutNode 是哪里传进来的</span></span><br><span class="line"><span class="comment">     *    这里记住：</span></span><br><span class="line"><span class="comment">     *    a. 接下来我们先找到哪里传入了 layoutNode</span></span><br><span class="line"><span class="comment">     *    b. 找到后我们再看 layoutNode.nodes.outerCoordinator 是什么？</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> outerCoordinator: NodeCoordinator</span><br><span class="line">        <span class="keyword">get</span>() = layoutNode.nodes.outerCoordinator</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> performMeasureBlock: () -&gt; <span class="built_in">Unit</span> = &#123;</span><br><span class="line">        <span class="comment">// 1. 这里调用了 measure()，那么 outerCoordinator 是什么？</span></span><br><span class="line">        outerCoordinator.measure(performMeasureConstraints)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续回退到上一层：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">📄  androidx.compose.ui.node --&gt; LayoutNodeLayoutDelegate.kt</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">LayoutNodeLayoutDelegate</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> layoutNode: LayoutNode</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">MeasurePassDelegate</span> : <span class="type">Measurable</span>, <span class="type">Placeable</span>(), AlignmentLinesOwner &#123;</span><br><span class="line">	</span><br><span class="line">	    <span class="comment">// 2. 我们继续回退</span></span><br><span class="line">	    <span class="function"><span class="keyword">fun</span> <span class="title">remeasure</span><span class="params">(constraints: <span class="type">Constraints</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">	        ...</span><br><span class="line">	        <span class="keyword">if</span> (layoutNode.measurePending || measurementConstraints != constraints) &#123;</span><br><span class="line">	            ...</span><br><span class="line">	            <span class="comment">// 1. 没有地方传入 layoutNode 啊</span></span><br><span class="line">	            performMeasure(constraints)</span><br><span class="line">	            ...</span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续回退到上一层：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">📄 androidx.compose.ui.node --&gt; LayoutNode.kt</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">LayoutNode</span>(..) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 通过 layoutDelegate 获取 measurePassDelegate，那 layoutDelegate 是什么？</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> measurePassDelegate</span><br><span class="line">        <span class="keyword">get</span>() = layoutDelegate.measurePassDelegate</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 来来来，nodes 在这里，NodeChain 又是什么？</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> nodes = NodeChain(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3. LayoutNodeLayoutDelegate(this) 看到这行代码你有没有想起来什么？</span></span><br><span class="line"><span class="comment">     *    这个 this 不就是我们要找的那个 layoutNode 参数嘛！</span></span><br><span class="line"><span class="comment">     *    现在我们再看下刚刚用到这个参数的地方：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *        val outerCoordinator: NodeCoordinator</span></span><br><span class="line"><span class="comment">     *            get() = layoutNode.nodes.outerCoordinator</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     *    还记得吧？现在 layoutNode 找到了，接下来看看 nodes 是什么？</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> layoutDelegate = LayoutNodeLayoutDelegate(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">remeasure</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        constraints: <span class="type">Constraints</span>? = layoutDelegate.lastConstraints</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (constraints != <span class="literal">null</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 1. 还是没有地方传入 layoutNode 啊，别急，我们看看 measurePassDelegate 是什么？</span></span><br><span class="line">            measurePassDelegate.remeasure(constraints)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NodeChain"><a href="#NodeChain" class="headerlink" title="NodeChain"></a>NodeChain</h2><p>我们再来看看 NodeChain 是什么？</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">📄 androidx.compose.ui.node --&gt; NodeChain.kt</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">NodeChain</span>(<span class="keyword">val</span> layoutNode: LayoutNode) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2. 再看这里，而 innerCoordinator 又是 InnerNodeCoordinator！</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> innerCoordinator = InnerNodeCoordinator(layoutNode)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *   不忘初心，再次搬出代码：</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     *        val outerCoordinator: NodeCoordinator</span></span><br><span class="line"><span class="comment">     *            get() = layoutNode.nodes.outerCoordinator</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 1. 哦，原来如此：</span></span><br><span class="line"><span class="comment">     *    layoutNode.nodes.outerCoordinator 是 innerCoordinator</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> outerCoordinator: NodeCoordinator = innerCoordinator</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码跟踪到这里就真相显现了，到底是哪个实现类处理了 measure() 方法，你现在清楚了吧？再来看下刚刚的截图：</p>
<img src="https://v1.ax1x.com/2025/08/18/EPWhaw.png" alt="" border="0" />

<br>

<br>

<p>所以接下来我们就看看 InnerNodeCoordinator 是如何负责具体测量的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">📄  androidx.compose.ui.node --&gt; InnerNodeCoordinator.kt</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">InnerNodeCoordinator</span>(</span><br><span class="line">    layoutNode: LayoutNode</span><br><span class="line">) : NodeCoordinator(layoutNode) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">measure</span><span class="params">(constraints: <span class="type">Constraints</span>)</span></span>: Placeable &#123;</span><br><span class="line">        <span class="meta">@Suppress(<span class="string">&quot;NAME_SHADOWING&quot;</span>)</span> <span class="keyword">val</span> constraints =</span><br><span class="line">            <span class="keyword">if</span> (forceMeasureWithLookaheadConstraints) &#123;</span><br><span class="line">                lookaheadDelegate!!.constraints</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                constraints</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> performingMeasure(constraints) &#123;</span><br><span class="line">            <span class="comment">// before rerunning the user&#x27;s measure block reset previous measuredByParent for children</span></span><br><span class="line">            layoutNode.forEachChild &#123;</span><br><span class="line">                it.measurePassDelegate.measuredByParent = LayoutNode.UsageByParent.NotUsed</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 返回一个 MeasureResult 对象给 replace() 去布局</span></span><br><span class="line">            measureResult = with(layoutNode.measurePolicy) &#123;</span><br><span class="line">                <span class="comment">// 1. 最核心处：这边就是最底层开始测量的工作了</span></span><br><span class="line">                measure(layoutNode.childMeasurables, constraints)</span><br><span class="line">            &#125;</span><br><span class="line">            onMeasured()</span><br><span class="line">            <span class="keyword">this</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析到这里，关于组件自身的测量和布局流程就跑通了：</strong> </p>
<div class="notification is-danger">
<p>我们在代码中所写的 Box、Text 等组件内部会有自己设定的测量数据，他们在代码实际运行过程中会被 Comopse 转换成 LayoutNode 节点（包含所有组件自身的测量数据），然后一层层往下传，最终传到 InnerNodeCoordinator，由它进行最底层的测量工作，测量完成后会返回一个 MeasureResult 对象再交给 replace() 函数完成布局工作。</p>
</div>

<p><strong>总结一句话：</strong></p>
<div class="notification is-info">
<p>InnerNodeCoordinator 就是 LayoutNode 的“原始皮肤”，把 LayoutNode 的原生测量 &amp; 绘制逻辑适配进整条 Coordinator 链。</p>
</div>

<p>所以，Do you understand?</p>
<img src="https://v1.ax1x.com/2025/08/18/EPW8I6.png" alt="" border="0" />

<br>

<br>

<p><progress class="progress is-success" value="100" max="100"></progress></p>
<h1 id="LayoutModifierNode-的工作原理"><a href="#LayoutModifierNode-的工作原理" class="headerlink" title="LayoutModifierNode 的工作原理"></a>LayoutModifierNode 的工作原理</h1><br>

<p>前面我们已经了解了<font color="#085DFF"><strong>组件自身的测量和布局原理</strong></font>，现在就可以开始分析 LayoutModifierNode 是如何影响组件的测量和布局了。</p>
<p>就像我们前面说的那样，所有组件最终都会被转换为一个 LayoutNode，这个 LayoutNode 包含了所有的测量数据，那同样它也会包含你对组件设定的 Modifier，所以最终经过一些列转换，也会传到 LayoutNode 里面，而 LayoutNode 里面也有一个 modifier 变量，存储的就是修饰 Composable 函数的 Modifier。</p>
<img src="https://v1.ax1x.com/2025/08/18/EPWx0O.png" alt="" border="0" />

<br>

<h2 id="LayoutNode-Modifer"><a href="#LayoutNode-Modifer" class="headerlink" title="LayoutNode.Modifer"></a>LayoutNode.Modifer</h2><p>现在我们来看看具体的代码逻辑：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 📄 androidx.compose.ui.node --&gt; LayoutNode.kt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">LayoutNode</span>(..) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> modifier: Modifier</span><br><span class="line">        <span class="keyword">get</span>() = _modifier</span><br><span class="line">        <span class="comment">// 如果有新值变化</span></span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isAttached) &#123;</span><br><span class="line">                applyModifier(value)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pendingModifier = value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">applyModifier</span><span class="params">(modifier: <span class="type">Modifier</span>)</span></span> &#123;</span><br><span class="line">        _modifier = modifier</span><br><span class="line">        nodes.updateFrom(modifier)    <span class="comment">// 关键代码</span></span><br><span class="line">        layoutDelegate.updateParentData()</span><br><span class="line">        <span class="keyword">if</span> (lookaheadRoot == <span class="literal">null</span> &amp;&amp; nodes.has(Nodes.ApproachMeasure)) &#123;</span><br><span class="line">            lookaheadRoot = <span class="keyword">this</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 nodes 应该不陌生了吧？前一节我们已经知道了它是 <strong>NodeChain</strong> 对象。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">val</span> nodes = NodeChain(<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure>

<p>但是 NodeChain 是什么？</p>
<div class="buttons">
  <button class="button is-danger">其实它就是一个链表，而且是个「双向链表」</button>
</div>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">📄 androidx.compose.ui.node --&gt; NodeChain.kt</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">NodeChain</span>(<span class="keyword">val</span> layoutNode: LayoutNode) &#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> innerCoordinator = InnerNodeCoordinator(layoutNode)</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> outerCoordinator: NodeCoordinator = innerCoordinator</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> tail: Modifier.Node = innerCoordinator.tail</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> head: Modifier.Node = tail</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="#085FFF">1. 头、尾节点都是 Modifier.Node 类型！</font></p>
<p><font color="#085FFF">2. 其中的 NodeCoordinator 是用来辅助 Node 节点处理测量和布局的，其中包含 measure 和 placeAt 的函数逻辑。</font></p>
<p><font color="#085FFF">3. NodeChain 链表上的每一个 Node 都会对应的绑定一个 NodeCoordinator 对象来辅助处理。（不理解没关系，接着往下看！）</font></p>
<hr>
<h2 id="updateFrom"><a href="#updateFrom" class="headerlink" title="updateFrom()"></a>updateFrom()</h2><p>接下来看看 updateFrom 的具体工作，它主要负责 NodeChain 链表的「更新」，每当有 Modifier 对象被设置到 LayoutNode 上面，都会调用 updateFrom 函数进行更新对应的 NodeChain。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">📄 androidx.compose.ui.node --&gt; NodeChain.kt</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">NodeChain</span>(<span class="keyword">val</span> layoutNode: LayoutNode) &#123;</span><br><span class="line">    <span class="comment">// 负责最内层测量的 NodeCoordinator</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> innerCoordinator = InnerNodeCoordinator(layoutNode)</span><br><span class="line">    <span class="comment">// 负责外层测量的 NodeCoordinator，初始值是 InnerNodeCoordinator</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> outerCoordinator: NodeCoordinator = innerCoordinator</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line">    <span class="comment">// 双向链表的尾节点</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> tail: Modifier.Node = innerCoordinator.tail</span><br><span class="line">    <span class="comment">// 双向链表的头节点</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> head: Modifier.Node = tail</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateFrom</span><span class="params">(m: <span class="type">Modifier</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> coordinatorSyncNeeded = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">val</span> paddedHead = padChain()</span><br><span class="line">        <span class="keyword">var</span> before = current</span><br><span class="line">        <span class="keyword">val</span> beforeSize = before?.size ?: <span class="number">0</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 📝 核心代码 1: </span></span><br><span class="line"><span class="comment">         *    fillVector 会将 Modifier 展开铺平到一个数组，</span></span><br><span class="line"><span class="comment">         *    后面的代码就可以用这个数组遍历</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">val</span> after = m.fillVector(buffer ?: mutableVectorOf())</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="comment">// 检查更新差异</span></span><br><span class="line">        <span class="keyword">if</span> (after.size == beforeSize) &#123;</span><br><span class="line">            ...    <span class="comment">// 这段代码不用看，只要加了 Modifier.xx 默认不会走到这边</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (layoutNode.applyingModifierOnAttach &amp;&amp; beforeSize == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 第一次组装 Modifier.Node 双向链表</span></span><br><span class="line">            coordinatorSyncNeeded = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">var</span> node = paddedHead</span><br><span class="line">            <span class="keyword">while</span> (i &lt; after.size) &#123;</span><br><span class="line">                <span class="keyword">val</span> next = after[i]</span><br><span class="line">                <span class="keyword">val</span> parent = node</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 📝 核心代码 2: 组装双向链表的具体逻辑</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                node = createAndInsertNodeAsChild(next, parent)</span><br><span class="line">                logger?.nodeInserted(<span class="number">0</span>, i, next, parent, node)</span><br><span class="line">                i++</span><br><span class="line">            &#125;</span><br><span class="line">            syncAggregateChildKindSet()</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (after.size == <span class="number">0</span>) &#123;  <span class="comment">// 删除所有 modifier</span></span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        current = after</span><br><span class="line">        buffer = before?.also &#123; it.clear() &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 📝 核心代码 3: 更新头节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        head = trimChain(paddedHead)</span><br><span class="line">        <span class="keyword">if</span> (coordinatorSyncNeeded) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 📝 核心代码 4: 关联 Modifier.Node 和 NodeCoordinator</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            syncCoordinators()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="buttons">
  <button class="button is-warning">接下来跟着我深入分析每一行核心代码！希望你能沉下心看下去，包教包会！</button>
</div>

<h3 id="📝-分解-Modifier"><a href="#📝-分解-Modifier" class="headerlink" title="📝 分解 Modifier"></a>📝 分解 Modifier</h3><p>先来看第一个核心代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> after = m.fillVector(buffer ?: mutableVectorOf())</span><br></pre></td></tr></table></figure>

<p>m 就是你的 Modifier 链，这里的 buffer 默认为 null，mutableVectorOf() 其实跟 buffer 一样都是一个可变列表，只是容量不同而已，你只要知道它就是一个列表，用来装分解后的单个 Modifier 用的就行了。</p>
<p>接着我们开始分析 fillVector 函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">📄 androidx.compose.ui.node --&gt; NodeChain.kt</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> Modifier.<span class="title">fillVector</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    result: <span class="type">MutableVector</span>&lt;<span class="type">Modifier</span>.<span class="type">Element</span>&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: MutableVector&lt;Modifier.Element&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> capacity = result.size.coerceAtLeast(<span class="number">16</span>)</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. 创建一个元素为 Modifier 的可变列表，并在初始化后添加传进来的 Modifier，</span></span><br><span class="line"><span class="comment">     *    从 stack 名字就可以看出来，这里相当于创建了一个栈，并且容量为 16</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> stack = MutableVector&lt;Modifier&gt;(capacity).also &#123; it.add(<span class="keyword">this</span>) &#125;</span><br><span class="line">    <span class="keyword">var</span> predicate: ((Modifier.Element) -&gt; <span class="built_in">Boolean</span>)? = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 2. 只要栈不为空，一直循环</span></span><br><span class="line">    <span class="keyword">while</span> (stack.isNotEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 3. 从栈中移除并获取最后一个元素，存到 next 变量中</span></span><br><span class="line">        <span class="keyword">when</span> (<span class="keyword">val</span> next = stack.removeAt(stack.size - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">// 4. 如果 next 是 CombinedModifier 类型</span></span><br><span class="line">            <span class="keyword">is</span> CombinedModifier -&gt; &#123;</span><br><span class="line">                stack.add(next.<span class="keyword">inner</span>)  <span class="comment">// 把 inner 部分加入到 stack 中</span></span><br><span class="line">                stack.add(next.outer)  <span class="comment">// 把 outer 部分加入到 stack 中</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 5. 如果 next 是 Modifier.Element 类型，则直接加到 result 中</span></span><br><span class="line">            <span class="keyword">is</span> Modifier.Element -&gt; result.add(next)</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 6. 如果 next 是 Modifier 的其他实现，可能我们不知道具体实现细节，</span></span><br><span class="line"><span class="comment">             *    把 it（可能是 Modifier.Element 的实例）加入到 result 中</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">else</span> -&gt; next.all(predicate ?: &#123; element: Modifier.Element -&gt;</span><br><span class="line">                result.add(element)</span><br><span class="line">                <span class="literal">true</span></span><br><span class="line">            &#125;.also &#123; predicate = it &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 7. 在处理完所有的元素之后，返回 result，它包含了所有的 Modifier.Element</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数其实就是创建了一个 Modifier 调用栈，以便可以迭代地处理一个可能嵌套的 Modifier 结构。栈的使用是为了在不使用递归的情况下扁平化修饰符的结构。</p>
<blockquote>
<p><font color="#085DFF">注意！从 1.3.0-beta01 版本开始，Compose 中不再使用 foldIn&#x2F;foldOut 函数对 Modifier 进行遍历了，在 1.3.0-beta01 之前的版本 LayoutNode 源码中是通过 foldOut 遍历 + 头插法处理，而现在是通过 fillVector 函数处理达到类似的效果。（提高性能！）</font></p>
</blockquote>
<p>看的懂吗？是不是很懵？我们来个实际例子吧，比如传入的 Modifier 链如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是你写的代码</span></span><br><span class="line">Box(Modifier.padding(<span class="number">10.</span>dp).size(<span class="number">20.</span>dp))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时 Modifier 链为:</span></span><br><span class="line">modifierChain = Modifier.padding(<span class="number">10.</span>dp).size(<span class="number">20.</span>dp)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际的结构：</span></span><br><span class="line">CombinedModifier(</span><br><span class="line">   PaddingElement  <span class="comment">// outer</span></span><br><span class="line">   SizeElement     <span class="comment">// inner</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><span style="color: #085DFF; font-weight: bold;">我们来看看 fillVector 是怎么处理它的：</span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;➡️ 1. 当调用 fillVector 函数时，初始状态是 modifierChain 放入了一个空的 <span style="color: #085DFF;">stack</span> 中。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;➡️ 2. 此时 <span style="color: #085DFF;">stack</span> 不为空，开始循环：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;🔸 removeAt 从 stack 的末尾（最后加入的元素）移除 <span style="color: #FF0000;">CombinedModifier</span>（因为它是链中最后一个元素），并将其赋值给 next。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;🔸 next 是一个 <span style="color: #FF0000;">CombinedModifier</span> 实例，此时就把 inner 和 outer 分别加进 stack 中，这个时候 stack 里面就有了两个元素：<span style="color: #085DFF;">[SizeElement, PaddingElement]</span>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;🔸 再次循环，这个时候再次开始 removeAt 从末尾取，先取到 <span style="color: #085DFF;">PaddingElement</span>，条件判断发现它是一个 <span style="color: #2E8B57;">Modifier.Element</span>，那就把它加进 <u><strong>result</strong></u> 里面（result 也是一个可变列表）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;🔸 继续循环，又取到了 <span style="color: #085DFF;">SizeElement</span>，发现它也是一个 <span style="color: #2E8B57;">Modifier.Element</span>，那就直接加进 <u><strong>result</strong></u> 里面。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;➡️ 3. 继续循环，啪～ stack 没东西了，循环结束，直接返回 <u><strong>result</strong></u> 结果：<span style="color: #085DFF;">[PaddingElement, SizeElement]</span>。</p>
<br>

<p><font color="#085DFF"><strong>这段流程我给你画了张图：</strong></font></p>
<img src="https://v1.ax1x.com/2025/08/18/EPWA4f.png" alt="" border="0" />

<br>

<br>

<h3 id="📝-构建双向链表"><a href="#📝-构建双向链表" class="headerlink" title="📝 构建双向链表"></a>📝 构建双向链表</h3><p>现在我们来分析第二段核心代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NodeChain.kt</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (layoutNode.applyingModifierOnAttach &amp;&amp; beforeSize == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 第一次组装 Modifier.Node 双向链表</span></span><br><span class="line">    coordinatorSyncNeeded = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> node = paddedHead     🟡 <span class="number">1.</span> node 初始值是什么？</span><br><span class="line">    <span class="keyword">while</span> (i &lt; after.size) &#123;  🟡 <span class="number">2.</span> after 是什么？</span><br><span class="line">        <span class="keyword">val</span> next = after[i]</span><br><span class="line">        <span class="keyword">val</span> parent = node</span><br><span class="line">        <span class="comment">// 📝 核心代码 2: 组装双向链表的具体逻辑</span></span><br><span class="line">        node = createAndInsertNodeAsChild(next, parent)</span><br><span class="line">        logger?.nodeInserted(<span class="number">0</span>, i, next, parent, node)</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    syncAggregateChildKindSet()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>我们先来看 node，它是 paddedHead：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> paddedHead = padChain()</span><br></pre></td></tr></table></figure>

<p>来看下 padChain() 做了什么：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NodeChain.kt</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">val</span> tail: Modifier.Node = innerCoordinator.tail</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">var</span> head: Modifier.Node = tail</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">padChain</span><span class="params">()</span></span>: Modifier.Node &#123;</span><br><span class="line">    checkPrecondition(head !== SentinelHead) &#123; <span class="string">&quot;padChain called on already padded chain&quot;</span> &#125;</span><br><span class="line">    <span class="keyword">val</span> currentHead = head</span><br><span class="line">    currentHead.parent = SentinelHead</span><br><span class="line">    SentinelHead.child = currentHead</span><br><span class="line">    <span class="keyword">return</span> SentinelHead</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候 <span style="color: #FF0000;">head</span> 默认是 <span style="color: #085DFF;">tail</span>，其实就是组件本身：<span style="color: #085DFF;">Box</span>。</p>
<p><span style="color: #FF5A00;">SentinelHead</span> 是什么？它最主要的作用就是作为一个<u><strong>哨兵节点</strong></u>，简化链表操作用的，我们就可以把它理解为在 Box 这个 Modifier.Node 节点前面插入一个哨兵节点，它们彼此构成一个双向链表。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[SentinelHead] &lt;-&gt; [currentHead] = [tail] = [TailModifierNode]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>现在再来看 <span style="color: #FF0000;">after</span>，它就是先前 <u><strong>result</strong></u> 返回的结果，即：<span style="color: #085DFF;">[PaddingElement, SizeElement]</span>，所以 next 会轮流取到这两个 Modifier 进行进一步的操作。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NodeChain.kt</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (layoutNode.applyingModifierOnAttach &amp;&amp; beforeSize == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 第一次组装 Modifier.Node 双向链表</span></span><br><span class="line">    coordinatorSyncNeeded = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> node = paddedHead     🟡 <span class="number">1.</span> node 此时是双向链表的头部，指向 <span class="string">&quot;哨兵节点&quot;</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; after.size) &#123;  🟡 <span class="number">2.</span> after 是 [PaddingElement, SizeElement]</span><br><span class="line">        <span class="keyword">val</span> next = after[i]   🟡 <span class="number">3.</span> 取出第一个是：PaddingElement</span><br><span class="line">        <span class="keyword">val</span> parent = node     🟡 <span class="number">4.</span> parent 指向 <span class="string">&quot;哨兵节点&quot;</span></span><br><span class="line">        <span class="comment">// 📝 核心代码 2: 组装双向链表的具体逻辑</span></span><br><span class="line">        node = createAndInsertNodeAsChild(next, parent)</span><br><span class="line">        logger?.nodeInserted(<span class="number">0</span>, i, next, parent, node)</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    syncAggregateChildKindSet()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们来分析 createAndInsertNodeAsParent 函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NodeChain.kt</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createAndInsertNodeAsChild</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    element: <span class="type">Modifier</span>.<span class="type">Element</span>,    🟡 element：PaddingElement</span></span></span><br><span class="line"><span class="params"><span class="function">    parent: <span class="type">Modifier</span>.<span class="type">Node</span>,        🟡 parent ：哨兵节点</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Modifier.Node &#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个新的节点</span></span><br><span class="line">    <span class="keyword">val</span> node = <span class="keyword">when</span> (element) &#123;</span><br><span class="line">        <span class="comment">// 2. 如果 element 是 ModifierNodeElement 的实例，它会调用 element 上的 create 方法，</span></span><br><span class="line">        <span class="comment">// 这个方法会返回一个新的 Modifier.Node</span></span><br><span class="line">        <span class="keyword">is</span> ModifierNodeElement&lt;*&gt; -&gt; element.create().also &#123;</span><br><span class="line">            it.kindSet = calculateNodeKindSetFromIncludingDelegates(it)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; BackwardsCompatNode(element)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 3. 插入到树中</span></span><br><span class="line">    <span class="comment">//    node  : PaddingNode</span></span><br><span class="line">    <span class="comment">//    parent: 哨兵节点</span></span><br><span class="line">    <span class="keyword">return</span> insertChild(node, parent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们重点来看一下 when() 内部的操作：</p>
<ol>
<li><p>首先取到的是 <span style="color: #085DFF;">PaddingElement</span>，它是 <span style="color: #FF0000;">ModifierNodeElement</span> 的实现类，所以满足条件，接着调用 create() 方法，会把 PaddingElement 包装成一个 <span style="color: #FF5A00;">Modifier.Node</span>。</p>
</li>
<li><p>现在已经得到了一个 Modifier.Node，接着把它插入树中，我们来看下操作：</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NodeChain.kt</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">insertChild</span><span class="params">(node: <span class="type">Modifier</span>.<span class="type">Node</span>, parent: <span class="type">Modifier</span>.<span class="type">Node</span>)</span></span>: Modifier.Node &#123;</span><br><span class="line">    <span class="comment">// 1. parent 就是哨子节点，所以 theChild 就是 Box 对应的 Modifier.Node</span></span><br><span class="line">    <span class="keyword">val</span> theChild = parent.child</span><br><span class="line">    <span class="keyword">if</span> (theChild != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 2. node 是传进来的 PaddingNode，将两个 Modifier.Node 建立双向链表关系</span></span><br><span class="line">        theChild.parent = node</span><br><span class="line">        node.child = theChild</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 再把哨子节点跟传进来的 PaddingNode 构建双向链表关系</span></span><br><span class="line">    parent.child = node</span><br><span class="line">    node.parent = parent</span><br><span class="line">    <span class="comment">// 4. 返回 node，也就是一个双向链表，不过指向 PaddingNode 节点</span></span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[SentinelHead] &lt;-&gt; [PaddingNode] &lt;-&gt; [TailModifierNode]</span><br></pre></td></tr></table></figure>

<hr>
<p>能理解吗？我也给你画了张图：</p>
<img src="https://v1.ax1x.com/2025/08/18/EPWWkc.png" alt="" border="0" />

<hr>
<p>现在已经处理完了 PaddingElement，循环取值，拿出第二个 SizeElement：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NodeChain.kt</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (layoutNode.applyingModifierOnAttach &amp;&amp; beforeSize == <span class="number">0</span>) &#123;</span><br><span class="line">    coordinatorSyncNeeded = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> node = paddedHead</span><br><span class="line">    <span class="keyword">while</span> (i &lt; after.size) &#123;</span><br><span class="line">        <span class="keyword">val</span> next = after[i]   🟡 <span class="number">1.</span> 取出第 <span class="number">2</span> 个是：SizeElement</span><br><span class="line">        <span class="keyword">val</span> parent = node     🟡 <span class="number">2.</span> parent 指向 PaddingNode</span><br><span class="line">        node = createAndInsertNodeAsChild(next, parent)</span><br><span class="line">        logger?.nodeInserted(<span class="number">0</span>, i, next, parent, node)</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    syncAggregateChildKindSet()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看 createAndInsertNodeAsChild() 函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NodeChain.kt</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createAndInsertNodeAsChild</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    element: <span class="type">Modifier</span>.<span class="type">Element</span>,    🟡 element：SizeElement</span></span></span><br><span class="line"><span class="params"><span class="function">    parent: <span class="type">Modifier</span>.<span class="type">Node</span>,        🟡 parent ：PaddingNode</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Modifier.Node &#123;</span><br><span class="line">    <span class="comment">// 1. 为 SizeElement 创建一个新的节点</span></span><br><span class="line">    <span class="keyword">val</span> node = <span class="keyword">when</span> (element) &#123;</span><br><span class="line">        <span class="comment">// 2. 创建 SizeNode</span></span><br><span class="line">        <span class="keyword">is</span> ModifierNodeElement&lt;*&gt; -&gt; element.create().also &#123;</span><br><span class="line">            it.kindSet = calculateNodeKindSetFromIncludingDelegates(it)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; BackwardsCompatNode(element)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 3. 插入到树中</span></span><br><span class="line">    <span class="comment">//    node  : SizeNode</span></span><br><span class="line">    <span class="comment">//    parent: PaddingNode</span></span><br><span class="line">    <span class="keyword">return</span> insertChild(node, parent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续，看下怎么插入树中的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NodeChain.kt</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">insertChild</span><span class="params">(node: <span class="type">Modifier</span>.<span class="type">Node</span>, parent: <span class="type">Modifier</span>.<span class="type">Node</span>)</span></span>: Modifier.Node &#123;</span><br><span class="line">    <span class="comment">// 1. parent 就是 PaddingNode，所以 theChild 就是 Box 对应的 Modifier.Node</span></span><br><span class="line">    <span class="keyword">val</span> theChild = parent.child</span><br><span class="line">    <span class="keyword">if</span> (theChild != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 2. node 是传进来的 SizeNode，将两个 Modifier.Node 建立双向链表关系</span></span><br><span class="line">        theChild.parent = node</span><br><span class="line">        node.child = theChild</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 再把 PaddingNode 节点跟传进来的 SizeNode 构建双向链表关系</span></span><br><span class="line">    parent.child = node</span><br><span class="line">    node.parent = parent</span><br><span class="line">    <span class="comment">// 4. 返回最新的双向链接</span></span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[SentinelHead] &lt;-&gt; [PaddingNode] &lt;-&gt; [SizeNode] &lt;-&gt; [TailModifierNode]</span><br></pre></td></tr></table></figure>

<p>能理解吗？我也给你画了张图：</p>
<img src="https://v1.ax1x.com/2025/08/18/EPWcb3.png" alt="" border="0" />

<hr>
<p>至此，第二部构建双向链表的工作就结束了，你发现没有，虽然先处理了 PaddingElement，后处理了 SizeElement，但实际上是把 SizeElement 插入到了 PaddingElement 内部，这其实就跟老版本的 foldIn 从尾部便利然后头插的方式一样，实现了同样的功能。</p>
<h3 id="📝-更新头节点"><a href="#📝-更新头节点" class="headerlink" title="📝 更新头节点"></a>📝 更新头节点</h3><p>第二段核心代码已经构建好了双向链表，但如果你看过老版本的代码会发现，以前是没有 SentineHead 这个哨子节点的，目前的双向链表的头节点是 SentineHead，它并没有实际的功能上的用处，所以这就是第三步核心代码要做的事，我们来看看：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NodeChain.kt</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">trimChain</span><span class="params">(paddedHead: <span class="type">Modifier</span>.<span class="type">Node</span>)</span></span>: Modifier.Node &#123;</span><br><span class="line">    checkPrecondition(paddedHead === SentinelHead) &#123;</span><br><span class="line">        <span class="string">&quot;trimChain called on already trimmed chain&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1. 取 SentineHead 的子节点，有吗？有 -- 就是 PaddingNode</span></span><br><span class="line">    <span class="keyword">val</span> result = SentinelHead.child ?: tail</span><br><span class="line">    <span class="comment">// 2. 断开 SentineHead 与 PaddingNode 之间的链</span></span><br><span class="line">    result.parent = <span class="literal">null</span></span><br><span class="line">    SentinelHead.child = <span class="literal">null</span></span><br><span class="line">    SentinelHead.aggregateChildKindSet = <span class="number">0.</span>inv()</span><br><span class="line">    SentinelHead.updateCoordinator(<span class="literal">null</span>)</span><br><span class="line">    checkPrecondition(result !== SentinelHead) &#123; <span class="string">&quot;trimChain did not update the head&quot;</span> &#125;</span><br><span class="line">    <span class="comment">// 3. 返回链，此时链就完全是一个由组件自身的 Node 和 Modifier 的 Node 组成的双向链表了</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很简单，就是把 SentineHead 从双向链表中断开去除，这样就是一个新的以 PaddingModifier 为表头的双向链表了。</p>
<h3 id="📝-同步协调器"><a href="#📝-同步协调器" class="headerlink" title="📝 同步协调器"></a>📝 同步协调器</h3><p>我们前面提到过：<font color="#085DFF">NodeCoordinator 是用来辅助 Node 节点处理测量和布局的，其中包含 measure 和 placeAt 的函数逻辑。NodeChain 链表上的每一个 Node 都会对应的绑定一个 NodeCoordinator 对象来辅助处理。</font></p>
<p>现在 NodeChain 链表已经全部搞定了，那么接下来就要开始对链表上每一个 Modifier.Node 绑定一个 NodeCoordinator，现在我们来看看 syncCoordinator 函数是怎么做的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NodeChain.kt</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">syncCoordinators</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> coordinator: NodeCoordinator = innerCoordinator</span><br><span class="line">    <span class="comment">// tail 就是链表的尾部节点，也就是组件自身的 Modifier.Node</span></span><br><span class="line">    <span class="comment">// 开始遍历，获取它的父节点，也就是 tail -&gt; SizeNode -&gt; PaddingNode</span></span><br><span class="line">    <span class="keyword">var</span> node: Modifier.Node? = tail.parent</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断 Modifier.Node 是不是 LayoutModifierNode</span></span><br><span class="line">        <span class="keyword">val</span> layoutmod = node.asLayoutModifierNode()</span><br><span class="line">    	<span class="comment">// 如果是 LayoutModifierNode</span></span><br><span class="line">        <span class="keyword">if</span> (layoutmod != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果节点已有关联的 coordinator，则使用现有的协调器，同时判断此协调器所关联的节点是否变化了，</span></span><br><span class="line">            <span class="comment">// 如果有变化，则调用 onLayoutModifierNodeChanged() 方法</span></span><br><span class="line">            <span class="keyword">val</span> next = <span class="keyword">if</span> (node.coordinator != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> c = node.coordinator <span class="keyword">as</span> LayoutModifierNodeCoordinator</span><br><span class="line">                <span class="keyword">val</span> prevNode = c.layoutModifierNode</span><br><span class="line">                c.layoutModifierNode = layoutmod</span><br><span class="line">                <span class="keyword">if</span> (prevNode !== node) c.onLayoutModifierNodeChanged()</span><br><span class="line">                c</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果节点没有关联的 coordinator，则创建一个 LayoutModifierNodeCoordinator，</span></span><br><span class="line">                <span class="comment">// 并通过 updateCoordinator 方法将这个新协调器和节点相关联</span></span><br><span class="line">                <span class="keyword">val</span> c = LayoutModifierNodeCoordinator(layoutNode, node)</span><br><span class="line">                node.updateCoordinator(c)</span><br><span class="line">                c</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不论是使用旧的还是新建的 coordinator，通过设置 wrappedBy 和 wrapped 属性，</span></span><br><span class="line">            <span class="comment">// 建立当前 coordinator 与下一个 coordinator 的包装关系，</span></span><br><span class="line">            <span class="comment">// 然后将 coordinator 变量更新为下一个 coordinator</span></span><br><span class="line">            <span class="comment">// 例如我们这边的例子：tail -&gt; SizeNode</span></span><br><span class="line">            coordinator.wrappedBy = next    <span class="comment">// InnerCoordinator 被谁包裹？-- LayoutModifierNodeCoordinator</span></span><br><span class="line">            next.wrapped = coordinator      <span class="comment">// LayoutModifierNodeCoordinator 包裹了谁？-- InnerCoordinator</span></span><br><span class="line">            coordinator = next  <span class="comment">// 更新 coordinator，比如后面再跟 PaddingNode 建立包裹关系</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 node 不是布局修饰符节点，直接调用 updateCoordinator 方法来更新协调器，</span></span><br><span class="line">            <span class="comment">// 将 node 和 NodeCoordinator 挂接关联</span></span><br><span class="line">            <span class="comment">// 比如：</span></span><br><span class="line">            <span class="comment">//     Modifier.background().size()</span></span><br><span class="line">            <span class="comment">//     这里 Modifier.background() 转换后的 Node 对应的 NodeCoordinator</span></span><br><span class="line">            <span class="comment">//     为 SizeNode 对应的 NodeCoordinator</span></span><br><span class="line">            node.updateCoordinator(coordinator)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在每次迭代结束时，将 node 变量更新为当前节点的父节点 node.parent，为下一次循环准备</span></span><br><span class="line">        <span class="comment">// 也就是获取 SizeNode 的父节点 -- PaddingNode，继续处理</span></span><br><span class="line">        node = node.parent</span><br><span class="line">    &#125;</span><br><span class="line">    coordinator.wrappedBy = layoutNode.parent?.innerCoordinator</span><br><span class="line">    outerCoordinator = coordinator    <span class="comment">// 调整外层 NodeCoordinator</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看懂了吗？我又画了一张图：</p>
<img src="https://v1.ax1x.com/2025/08/18/EPWvPj.png" alt="" border="0" />

<br>

<br>

<p><strong>现在让我们简单总结下 updateFrom() 的处理步骤：</strong></p>
<ol>
<li>在 Composable 编写的 Modifier 是层层嵌套的，首先需要将 Modifier 集合铺平到一个数组中；</li>
<li>如果 NodeChain 还没有组装过双向链表，遍历步骤一铺平的 Modifier 数组组装成双向链表，否则就对双向链表增量更新；</li>
<li>更新双向链表头节点；</li>
<li>将 Modifier 和所属的 NodeCoordinator 挂接关联。</li>
</ol>
<hr>
<p>现在去除代码分析部分，再来看一个整体思维模型图：</p>
<img src="https://v1.ax1x.com/2025/08/18/EPWaF5.png" alt="" border="0" />

<hr>
<p>看到这里，所有的 Modifier 处理完了，接下来就可以开始测量了，你还记得第二节我们讲的组件自身测量的代码逻辑吗？我估计你看到这，应该已经全忘了，所以再看一下流程图吧：</p>
<img src="https://v1.ax1x.com/2025/08/18/EPW8I6.png" alt="" border="0" />

<br>

<br>

<p>看到没？是谁测量的？– <span style="color: #085DFF;">outerCoordinator！</font></p>
<p>outerCoordinator 对象就是做实际测量工作的，所以开始测量的时候，从哪开始测？不用我说了吧？</p>
<img src="https://v1.ax1x.com/2025/08/18/EPWOqm.png" alt="" border="0" />

<br>

<p><progress class="progress is-success" value="100" max="100"></progress></p>
<h1 id="LayoutModifierNode-的测量"><a href="#LayoutModifierNode-的测量" class="headerlink" title="LayoutModifierNode 的测量"></a>LayoutModifierNode 的测量</h1><p>我们看下 LayoutModifierNodeCoordinator 是怎么做测量的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LayoutModifierNodeCoordinator.kt</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">LayoutModifierNodeCoordinator</span>(</span><br><span class="line">    layoutNode: LayoutNode,</span><br><span class="line">    measureNode: LayoutModifierNode,</span><br><span class="line">) : NodeCoordinator(layoutNode) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">measure</span><span class="params">(constraints: <span class="type">Constraints</span>)</span></span>: Placeable &#123;</span><br><span class="line">        <span class="meta">@Suppress(<span class="string">&quot;NAME_SHADOWING&quot;</span>)</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        performingMeasure(constraints) &#123;</span><br><span class="line">            <span class="comment">// 过度型 Modifier，暂时不在我们本篇文章的考虑范围，忽略</span></span><br><span class="line">            measureResult = approachMeasureScope?.let &#123; scope -&gt;</span><br><span class="line">                ... ...</span><br><span class="line">            &#125; ?: with(layoutModifierNode) &#123;    <span class="comment">// 普通 LayoutModifierNode 测量</span></span><br><span class="line">                <span class="comment">// 1. 核心代码，with 包含了 LayoutModifierNode，提供了一个 LayoutModifierNode 的上下文</span></span><br><span class="line">                <span class="comment">// 2. 这里的 wrappedNonNull 是什么？我们后面马上就说到</span></span><br><span class="line">                measure(wrappedNonNull, constraints)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span><span class="symbol">@LayoutModifierNodeCoordinator</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新本 Coordinator 的内部状态</span></span><br><span class="line">        onMeasured()</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>measure() 的工作会跳转到哪里，是由 with() 决定的，它提供了 LayoutModifierNode 上下文，所以 measure() 跳转到了 LayoutModifierNode 里面。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LayoutModifierNode.kt</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">LayoutModifierNode</span> : <span class="type">Remeasurement</span>, <span class="type">DelegatableNode</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> MeasureScope.<span class="title">measure</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        measurable: <span class="type">Measurable</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        constraints: <span class="type">Constraints</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: MeasureResult</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LayoutModifierNode 只是一个接口，所以具体的测量实现在哪？</p>
<hr>
<p><strong>这里我们要分两种场景来看：</strong></p>
<p><font color="#085DFF">1. 我们首先来看最简单的一种情况：Modifier.layout()</font></p>
<p>比如我们文章前面写过的一个例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">ComponentActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContent &#123;</span><br><span class="line">            ComposeBlogTheme &#123;</span><br><span class="line">                Box(Modifier.background(Color.Green)) &#123;</span><br><span class="line">                    Text(<span class="string">&quot;Hi Compose&quot;</span>,</span><br><span class="line">                        <span class="comment">// here，熟悉吗？</span></span><br><span class="line">                        Modifier.layout &#123; measurable, constraints -&gt;</span><br><span class="line">                            <span class="keyword">val</span> paddingPx = <span class="number">10.</span>dp.roundToPx()</span><br><span class="line">                            <span class="keyword">val</span> placeable = measurable.measure(constraints.copy(</span><br><span class="line">                                maxWidth = constraints.maxWidth - paddingPx * <span class="number">2</span>,</span><br><span class="line">                                maxHeight = constraints.maxHeight - paddingPx * <span class="number">2</span></span><br><span class="line">                            ))</span><br><span class="line">                            layout(placeable.width + paddingPx * <span class="number">2</span>, placeable.height + paddingPx * <span class="number">2</span>) &#123;</span><br><span class="line">                                placeable.placeRelative(paddingPx, paddingPx)</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点进 <code>Modifier.layout &#123;&#125;</code> 看源码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LayoutModifier.kt</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Modifier.<span class="title">layout</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    measure: <span class="type">MeasureScope</span>.(<span class="type">Measurable</span>, <span class="type">Constraints</span>) -&gt; <span class="type">MeasureResult</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> = <span class="keyword">this</span> then LayoutElement(measure)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">LayoutElement</span>(</span><br><span class="line">    <span class="keyword">val</span> measure: MeasureScope.(Measurable, Constraints) -&gt; MeasureResult</span><br><span class="line">) : ModifierNodeElement&lt;LayoutModifierImpl&gt;() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span></span> = LayoutModifierImpl(measure)</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再点击 LayoutModifierImpl 进去看看：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">LayoutModifierImpl</span>(</span><br><span class="line">    <span class="keyword">var</span> measureBlock: MeasureScope.(Measurable, Constraints) -&gt; MeasureResult</span><br><span class="line">) : LayoutModifierNode, Modifier.Node() &#123;</span><br><span class="line">    <span class="comment">// 看！！！是不是重写了 MeasureScope.measure 方法 ? 所以具体测量工作就在这里了。</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> MeasureScope.<span class="title">measure</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        measurable: <span class="type">Measurable</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        constraints: <span class="type">Constraints</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> = measureBlock(measurable, constraints)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;LayoutModifierImpl(measureBlock=<span class="variable">$measureBlock</span>)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里 <code>measure</code> 直接调用了 <code>measureBlock()</code>，它是参数传进来的，往回退：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LayoutModifier.kt</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Modifier.<span class="title">layout</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    measure: <span class="type">MeasureScope</span>.(<span class="type">Measurable</span>, <span class="type">Constraints</span>) -&gt; <span class="type">MeasureResult</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> = <span class="keyword">this</span> then LayoutElement(measure)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">LayoutElement</span>(</span><br><span class="line">    <span class="keyword">val</span> measure: MeasureScope.(Measurable, Constraints) -&gt; MeasureResult</span><br><span class="line">) : ModifierNodeElement&lt;LayoutModifierImpl&gt;() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span></span> = LayoutModifierImpl(measure)</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>measureBlock</code> 又是 <code>measure</code>，而 <code>measure</code> 是啥？就是你主代码里面写在 <code>Modifier.layout &#123;&#125;</code> 里面的测量和布局逻辑，这就相当于实现了将内部的测量结果暴露给上层，让我们能修饰做二次测量处理。</p>
<p><font color="#085DFF">2. 现在我们再来看第二种场景：Modifier.padding(10.dp).size(20.dp)</font></p>
<p>这个例子不用多说了吧，之前分析源码就是基于它，这个场景就要关联到我们刚刚提到的 wrappedNonNull 了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LayoutModifierNodeCoordinator.kt</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">LayoutModifierNodeCoordinator</span>(</span><br><span class="line">    layoutNode: LayoutNode,</span><br><span class="line">    measureNode: LayoutModifierNode,</span><br><span class="line">) : NodeCoordinator(layoutNode) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. wrapped 是 LayoutModifierNodeCoordinator 的内部 NodeCoordinator</span></span><br><span class="line">    <span class="keyword">val</span> wrappedNonNull: NodeCoordinator <span class="keyword">get</span>() = wrapped!!</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">measure</span><span class="params">(constraints: <span class="type">Constraints</span>)</span></span>: Placeable &#123;</span><br><span class="line">        ...</span><br><span class="line">        performingMeasure(constraints) &#123;</span><br><span class="line">            measureResult = approachMeasureScope?.let &#123; scope -&gt;</span><br><span class="line">                ... ...</span><br><span class="line">            &#125; ?: with(layoutModifierNode) &#123;</span><br><span class="line">                <span class="comment">// 1. 这里的 wrappedNonNull 是什么？</span></span><br><span class="line">                measure(wrappedNonNull, constraints)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span><span class="symbol">@LayoutModifierNodeCoordinator</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新本 Coordinator 的内部状态</span></span><br><span class="line">        onMeasured()</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释写的很清楚：wrapped 是最外层 LayoutModifierNodeCoordinator 的内部 NodeCoordinator，是谁？</p>
<img src="https://v1.ax1x.com/2025/08/18/EPWSa4.png" alt="" border="0" />

<p>所以你能看出什么门道吗？流程很清晰：测量过程中会从外往里执行每一个 NodeCoordinator 的 measure 方法，直到触底遇到组件自身的 InnerNodeCoordinator，它负责自身的测量。</p>
<p>我们看下源码更清晰，比如先 Padding()：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">PaddingNode</span>(</span><br><span class="line">    <span class="keyword">var</span> start: Dp = <span class="number">0.</span>dp,</span><br><span class="line">    <span class="keyword">var</span> top: Dp = <span class="number">0.</span>dp,</span><br><span class="line">    <span class="keyword">var</span> end: Dp = <span class="number">0.</span>dp,</span><br><span class="line">    <span class="keyword">var</span> bottom: Dp = <span class="number">0.</span>dp,</span><br><span class="line">    <span class="keyword">var</span> rtlAware: <span class="built_in">Boolean</span></span><br><span class="line">) : LayoutModifierNode, Modifier.Node() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 看这里的 measurable 是什么？</span></span><br><span class="line"><span class="comment">     * ==&gt; 就是它内部的 SizeNode 的 NodeCoordinator</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> MeasureScope.<span class="title">measure</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        measurable: <span class="type">Measurable</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        constraints: <span class="type">Constraints</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: MeasureResult &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> horizontal = start.roundToPx() + end.roundToPx()</span><br><span class="line">        <span class="keyword">val</span> vertical = top.roundToPx() + bottom.roundToPx()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 往内部传，让 SizeNode 去测</span></span><br><span class="line">        <span class="keyword">val</span> placeable = measurable.measure(constraints.offset(-horizontal, -vertical))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拿到里层结果后 TODO</span></span><br><span class="line">        <span class="keyword">val</span> width = constraints.constrainWidth(placeable.width + horizontal)</span><br><span class="line">        <span class="keyword">val</span> height = constraints.constrainHeight(placeable.height + vertical)</span><br><span class="line">        <span class="keyword">return</span> layout(width, height) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rtlAware) &#123;</span><br><span class="line">                placeable.placeRelative(start.roundToPx(), top.roundToPx())</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                placeable.place(start.roundToPx(), top.roundToPx())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来看 Size()：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">SizeNode</span>(</span><br><span class="line">    <span class="keyword">var</span> minWidth: Dp = Dp.Unspecified,</span><br><span class="line">    <span class="keyword">var</span> minHeight: Dp = Dp.Unspecified,</span><br><span class="line">    <span class="keyword">var</span> maxWidth: Dp = Dp.Unspecified,</span><br><span class="line">    <span class="keyword">var</span> maxHeight: Dp = Dp.Unspecified,</span><br><span class="line">    <span class="keyword">var</span> enforceIncoming: <span class="built_in">Boolean</span></span><br><span class="line">) : LayoutModifierNode, Modifier.Node() &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 看这里的 measurable 是什么？</span></span><br><span class="line"><span class="comment">     * ==&gt; 就是它内部的 Box 的 NodeCoordinator，也就是 InnerNodeCoordinator</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> MeasureScope.<span class="title">measure</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        measurable: <span class="type">Measurable</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        constraints: <span class="type">Constraints</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: MeasureResult &#123;</span><br><span class="line">        <span class="keyword">val</span> wrappedConstraints = targetConstraints.let &#123; targetConstraints -&gt;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再往内部传，让 Box 去测自己</span></span><br><span class="line">        <span class="keyword">val</span> placeable = measurable.measure(wrappedConstraints)</span><br><span class="line">        <span class="keyword">return</span> layout(placeable.width, placeable.height) &#123;</span><br><span class="line">            placeable.placeRelative(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把这个结果回传给上层（padding）” → 返回的 MeasureResult</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> placeable = measurable.measure(wrappedConstraints)</span><br><span class="line">        <span class="keyword">return</span> layout(placeable.width, placeable.height) &#123;</span><br><span class="line">            placeable.placeRelative(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>再来看 </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">InnerNodeCoordinator</span>(</span><br><span class="line">    layoutNode: LayoutNode</span><br><span class="line">) : NodeCoordinator(layoutNode) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">measure</span><span class="params">(constraints: <span class="type">Constraints</span>)</span></span>: Placeable &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> performingMeasure(constraints) &#123;</span><br><span class="line">            <span class="comment">// before rerunning the user&#x27;s measure block reset previous measuredByParent for children</span></span><br><span class="line">            layoutNode.forEachChild &#123;</span><br><span class="line">                it.measurePassDelegate.measuredByParent = LayoutNode.UsageByParent.NotUsed</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 返回一个 MeasureResult 对象给 replace() 去布局</span></span><br><span class="line">            measureResult = with(layoutNode.measurePolicy) &#123;</span><br><span class="line">                <span class="comment">// 1. 最核心处：这边就是最底层开始测量的工作了</span></span><br><span class="line">                measure(layoutNode.childMeasurables, constraints)</span><br><span class="line">            &#125;</span><br><span class="line">            onMeasured()</span><br><span class="line">            <span class="keyword">this</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>流程如下：</strong></p>
<ol>
<li>我们要给 Box 增加 10dp 的 padding，但此时还不知道组件本身大小，所以就需要先测量内部，会先去找 10dp 套着的内部；</li>
<li>现在内部要设定 20dp 的 size，但仍然不知道组件本身大小，需要先测量内部，继续往下找它的内部；</li>
<li>找到了具体组件 Box，它是 InnerNodeCoordinator，InnerNodeCoordinator 已经没有内部了，所以 Box 按照自己的测量方式去测量拿到测量结果；</li>
<li>InnerNodeCoordinator 测量出结果后，往上传给要设定 size 的 LayoutModifierNode，在测量结果上设定 20dp 的 size 后返回测量结果；</li>
<li>拿到设定 20dp size 的测量结果后，再往上传给要加 padding 的 LayoutModifierNode，在测量结果上再添加 10dp 的 padding，LayoutNode 拿到最终的测量结果。</li>
</ol>
</div><div class="article-licensing box"><div class="licensing-title"><p>深度解析 LayoutNode 的测量、布局原理</p><p><a href="http://example.com/2025/08/10/compose/Compose -- Modifier -- 03. 解析 Modifier.layout()/">http://example.com/2025/08/10/compose/Compose -- Modifier -- 03. 解析 Modifier.layout()/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Marco</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2025-08-10</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2025-08-19</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Compose/">Compose</a><a class="link-muted mr-2" rel="tag" href="/tags/Modifier/">Modifier</a><a class="link-muted mr-2" rel="tag" href="/tags/LayoutModifier/">LayoutModifier</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2025/08/16/compose/Compose%20--%20Modifier%20--%2004.%20%E8%A7%A3%E6%9E%90%20DrawModifier/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">解析 DrawModifier</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2025/08/03/compose/Compose%20--%20Modifier%20--%2002.%20%E8%A7%A3%E6%9E%90%20ComposedModifier/"><span class="level-item">解析 ComposedModifier</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/2025/08/16/compose/Compose%20--%20Modifier%20--%2004.%20%E8%A7%A3%E6%9E%90%20DrawModifier/"><img src="/gallery/covers/compose/cover_modifier_4.png" alt="解析 DrawModifier"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-08-15T16:00:00.000Z">2025-08-16</time></p><p class="title"><a href="/2025/08/16/compose/Compose%20--%20Modifier%20--%2004.%20%E8%A7%A3%E6%9E%90%20DrawModifier/">解析 DrawModifier</a></p><p class="categories"><a href="/categories/Compose/">Compose</a> / <a href="/categories/Compose/Modifier/">Modifier</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2025/08/10/compose/Compose%20--%20Modifier%20--%2003.%20%E8%A7%A3%E6%9E%90%20Modifier.layout()/"><img src="/gallery/covers/compose/cover_modifier_3.png" alt="深度解析 LayoutNode 的测量、布局原理"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-08-09T16:00:00.000Z">2025-08-10</time></p><p class="title"><a href="/2025/08/10/compose/Compose%20--%20Modifier%20--%2003.%20%E8%A7%A3%E6%9E%90%20Modifier.layout()/">深度解析 LayoutNode 的测量、布局原理</a></p><p class="categories"><a href="/categories/Compose/">Compose</a> / <a href="/categories/Compose/Modifier/">Modifier</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2025/08/03/compose/Compose%20--%20Modifier%20--%2002.%20%E8%A7%A3%E6%9E%90%20ComposedModifier/"><img src="/gallery/covers/compose/cover_modifier_2.png" alt="解析 ComposedModifier"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-08-02T16:00:00.000Z">2025-08-03</time></p><p class="title"><a href="/2025/08/03/compose/Compose%20--%20Modifier%20--%2002.%20%E8%A7%A3%E6%9E%90%20ComposedModifier/">解析 ComposedModifier</a></p><p class="categories"><a href="/categories/Compose/">Compose</a> / <a href="/categories/Compose/Modifier/">Modifier</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2025/08/01/compose/Compose%20--%20Modifier%20--%2001.%20%E8%A7%A3%E6%9E%90%20Modifier%20&amp;%20CombinedModifier/"><img src="/gallery/covers/compose/cover_modifier_1.png" alt="解析 Modifier &amp; CombinedModifier"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-07-31T16:00:00.000Z">2025-08-01</time></p><p class="title"><a href="/2025/08/01/compose/Compose%20--%20Modifier%20--%2001.%20%E8%A7%A3%E6%9E%90%20Modifier%20&amp;%20CombinedModifier/">解析 Modifier &amp; CombinedModifier</a></p><p class="categories"><a href="/categories/Compose/">Compose</a> / <a href="/categories/Compose/Modifier/">Modifier</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2025/06/22/compose/Compose%20--%20%E7%8A%B6%E6%80%81%E8%AE%A2%E9%98%85%20&amp;%20%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%20--%2005.%20%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E9%87%8D%E7%BB%84%E5%90%97%EF%BC%9F/"><img src="/gallery/covers/compose/cover_state_3.png" alt="你真的了解 Compose 的重组吗？"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-06-21T16:00:00.000Z">2025-06-22</time></p><p class="title"><a href="/2025/06/22/compose/Compose%20--%20%E7%8A%B6%E6%80%81%E8%AE%A2%E9%98%85%20&amp;%20%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%20--%2005.%20%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E9%87%8D%E7%BB%84%E5%90%97%EF%BC%9F/">你真的了解 Compose 的重组吗？</a></p><p class="categories"><a href="/categories/Compose/">Compose</a> / <a href="/categories/Compose/%E7%8A%B6%E6%80%81%E8%AE%A2%E9%98%85-%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0/">状态订阅 &amp; 自动更新</a></p></div></article></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Simple-Code"><span class="level-left"><span class="level-item">1</span><span class="level-item">Simple Code</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#一个-Text"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">一个 Text()</span></span></a></li><li><a class="level is-mobile" href="#Modifier-layout"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">Modifier.layout()</span></span></a></li><li><a class="level is-mobile" href="#layout-函数"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">layout() 函数</span></span></a></li></ul></li><li><a class="level is-mobile" href="#LayoutNode-浅析"><span class="level-left"><span class="level-item">2</span><span class="level-item">LayoutNode 浅析</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#remeasure"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">remeasure()</span></span></a></li><li><a class="level is-mobile" href="#NodeChain"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">NodeChain</span></span></a></li></ul></li><li><a class="level is-mobile" href="#LayoutModifierNode-的工作原理"><span class="level-left"><span class="level-item">3</span><span class="level-item">LayoutModifierNode 的工作原理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#LayoutNode-Modifer"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">LayoutNode.Modifer</span></span></a></li><li><a class="level is-mobile" href="#updateFrom"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">updateFrom()</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#📝-分解-Modifier"><span class="level-left"><span class="level-item">3.2.1</span><span class="level-item">📝 分解 Modifier</span></span></a></li><li><a class="level is-mobile" href="#📝-构建双向链表"><span class="level-left"><span class="level-item">3.2.2</span><span class="level-item">📝 构建双向链表</span></span></a></li><li><a class="level is-mobile" href="#📝-更新头节点"><span class="level-left"><span class="level-item">3.2.3</span><span class="level-item">📝 更新头节点</span></span></a></li><li><a class="level is-mobile" href="#📝-同步协调器"><span class="level-left"><span class="level-item">3.2.4</span><span class="level-item">📝 同步协调器</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#LayoutModifierNode-的测量"><span class="level-left"><span class="level-item">4</span><span class="level-item">LayoutModifierNode 的测量</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/wikihow.svg" alt="wikiHow" height="28"></a><p class="is-size-7"><span>&copy; 2025 Marco</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© Honey Badger Team</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/pepsimaxin"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>