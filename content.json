{"posts":[{"title":"聊聊 mutableStateListOf","text":"Source Code based on: androidx.compose.**:**:1.5.0 讲任何一个新的主题或者知识点，习惯性的从 Demo 开始，比如： 1234567891011class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var name by mutableStateOf(&quot;Hi, Compose&quot;) setContent { Text(name) } }} 这段代码已经熟的不能再熟了吧？如果我们用 by mutableStateOf 初始化一个变量，那 name 就会变成一个被 Compose「自动订阅」的变量。 我们之前文章的例子，都是用 by mutableStateOf 包了一个 String，如果换成别的类型，行不行？ 1234fun &lt;T&gt; mutableStateOf( value: T, // 泛型参数 policy: SnapshotMutationPolicy&lt;T&gt; = structuralEqualityPolicy()): MutableState&lt;T&gt; = createSnapshotMutableState(value, policy) 例如：Int 类型 12345678910111213141516class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var num by mutableStateOf(1) setContent { Text( text = &quot;当前数值：$num&quot;, Modifier.clickable { num++ } ) } }} 代码不做解释了，直接看效果： 例如：List 类型 123// num 类型：MutableList&lt;Int&gt;// mutableStateOf 类型：MutableState&lt;MutableList&lt;Int&gt;&gt;var nums by mutableStateOf(mutableListOf(1, 2, 3)) 我们在代码里面用起来： 123456789101112131415class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var nums by mutableStateOf(mutableListOf(1, 2, 3)) setContent { Column { for (num in nums) { Text(&quot;第 $num 块文字&quot;) } } } }} 运行： 现在我们稍微改下代码： 1234567891011121314151617181920class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var nums by mutableStateOf(mutableListOf(1, 2, 3)) setContent { Column { Button(onClick = { nums.add(nums.last() + 1) }) { Text(&quot;List 加 1&quot;) } for (num in nums) { Text(&quot;第 $num 块文字&quot;) } } } }} 代码很简单：我们添加了一个 Button，每次点击后，nums 会添加一个值，比最有一个值大 1。 运行： Button 疯狂点击，但是没生效！为什么？ 我们先来思考一个问题，mutableStateOf 原理是什么？我们回忆一下： mutableStateOf 之所以可以对变量进行订阅和刷新，主要是因为内部的 get() 和 set() 方法加了钩子，或者说它的 set() 方法是赋值！是改变了变量的指向，它是直接把对象给替换了，但在我们这个代码里面 nums 仅仅是改变了它内部的状态！ 所以，它不会出发 setValue() 的调用，从而不会触发自动刷新的操作。 为了验证是不是因为没有重组，我们可以改下代码： 12345678910111213141516171819202122class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var nums by mutableStateOf(mutableListOf(1, 2, 3)) var refresh by mutableStateOf(&quot;强制刷新&quot;) setContent { Column { Text(refresh, Modifier.clickable { refresh = &quot;刷新完成&quot;}) Button(onClick = { nums.add(nums.last() + 1) }) { Text(&quot;List 加 1&quot;) } for (num in nums) { Text(&quot;第 $num 块文字&quot;) } } } }} 我们添加了一个 Text() 组件，改变 refresh 的值，那么理论上它就会带着「整个重组作用域内」的组件全部「刷新」，包括 List。 运行： 成功刷新了 List ！ 现在我们就很清楚了，mutableStateOf 没法对 List 类型的对象实现类似 String、Int 的自动订阅及刷新，那有没有解决办法？ 上面我们说过了，问题的根本原因是 List 只是内部的变化，而不是它自己本身对象的变化，那我们在内部操作完后直接把 List 重新给换了不就行了？试试： 1234567891011121314151617181920212223class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var nums by mutableStateOf(mutableListOf(1, 2, 3)) setContent { Column { Button(onClick = { // nums 重新赋值 nums = nums.toMutableList().apply { add(nums.last() + 1) } }) { Text(&quot;List 加 1&quot;) } for (num in nums) { Text(&quot;第 $num 块文字&quot;) } } } }} 运行： 成功刷新了 List ！ 但这样写就会显得很奇怪：既然对于 String、Int 这些类型，Compose 提供了 mutableStateOf，难道对于 List 这种这么常用的类型，就没有一个 mutable*** 的函数给我们用？ 那必须有！它就是 mutableStateListOf！它可以观测到内部 List 的数据变化！ 我们可以像下面这样申明： 12345678910var nums by mutableStateListOf(mutableListOf(1, 2, 3)) // 有红线标注，写法错误// mutableStateListOf 是内部元素被观测，而不是它本身被观测，所以我们要把 `by` 换成 `=`var nums = mutableStateListOf(mutableListOf(1, 2, 3))// `var` 也可以换成 `val`val nums = mutableStateListOf(mutableListOf(1, 2, 3))// mutableStateListOf 本身就代表一个可观测的 List，所以 mutableListOf 也可以去除val nums = mutableStateListOf(1, 2, 3) // 这就是最终的写法 这个时候我们就可以优化下代码了： 1234567891011121314151617181920class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val nums = mutableStateListOf(1, 2, 3) setContent { Column { Button(onClick = { nums.add(nums.last() + 1) }) { Text(&quot;List 加 1&quot;) } for (num in nums) { Text(&quot;第 $num 块文字&quot;) } } } }} 运行： 提到 List，我们就会想到 Map，同样 Map 也提供了一个 mutableStateMapOf！它也可以观测到内部 Map 的数据变化！ 12345678910111213141516171819class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val maps = mutableStateMapOf(1 to &quot;One&quot;, 2 to &quot;Two&quot;) setContent { Column { Button(onClick = { maps[3] = &quot;Three&quot; }) { Text(&quot;Maps 加 1&quot;) } for ((key, value) in maps) { Text(&quot;$key 对应 value: $value&quot;) } } } }} 运行：","link":"/2025/07/18/compose/Compose%20--%20%E7%8A%B6%E6%80%81%E8%AE%A2%E9%98%85%20&%20%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%20--%2004.%20mutableStateListOf/"},{"title":"深度解析 mutableStateOf 源码","text":"其实原理性分析的文章，真的很难讲的通俗易懂，讲的简单浅显没必要写，讲的繁琐难懂往往大家也不乐意看，所以怎么找个好的角度慢慢钻进去尤为重要，比如：Begin simple code！ Simple Code 正如我上面说的，直接讲原理太枯燥（你也会很懵），我喜欢从简单代码入手，带你一点点进入，现在开始。 先看一个最简单的代码示例： 1234567891011121314class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // 这种定义变量的方式随处可见了 val name = mutableStateOf(&quot;Compose&quot;) setContent { ComposeBlogTheme { Text(name.value) } } }} 我先来简单解读一下这段代码背后的原理： 当我们定义一个变量 name，用 「mutableStateOf」 包起来后：⤵︎它就变成了一个 MutableState 类型的对象（后面会分析源码）。 同时，我们取值的话必须要写 「name.value」，这样能才能取到变量值：”Compose”。⤵︎因为 name 不再是一个 String，而是 MutableState 对象，我们也可以把它叫做「State: 状态」。 此时，name 是一个「被订阅的状态」，「name.value」就是一个被订阅的值：⤵︎如果它发生变化，Text() 函数就会重新执行一遍，更新到最新的值。 现在我们修改下代码，3s 后改变 name.value 的值： 123456789101112131415161718class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val name = mutableStateOf(&quot;Compose&quot;) setContent { ComposeBlogTheme { Text(name.value) } LaunchedEffect(true) { delay(3000) // 3s 延迟 name.value = &quot;Kotlin&quot; // 修改 name.value } } }} 运行，效果如下： 现在关于 mutableStateOf 的用法你已经掌握了，但你会不会产生一个疑问？ name 被「自动订阅」了，它的值改变了就会让界面「重新刷新」，这背后的「状态订阅 &amp; 刷新机制」的原理是什么？ 如果你想深入了解，那么接着往下看。 状态订阅 &amp; 自动刷新 基于 androidx.compose.runtime:runtime:1.7.1 版本 硬核部分走起，查看 mutableStateOf() 源码： 1234fun &lt;T&gt; mutableStateOf( value: T, policy: SnapshotMutationPolicy&lt;T&gt; = structuralEqualityPolicy()): MutableState&lt;T&gt; = createSnapshotMutableState(value, policy) mutableStateOf() 返回的是一个 MutableState 对象，这个我们前面说过。 mutableStateOf() 又调用了另一个函数：createSnapshotMutableState()。 进入 createSnapshotMutableState() ： 1234internal actual fun &lt;T&gt; createSnapshotMutableState( value: T, policy: SnapshotMutationPolicy&lt;T&gt;): SnapshotMutableState&lt;T&gt; = ParcelableSnapshotMutableState(value, policy) 又调用了 ParcelableSnapshotMutableState() 函数： 1234567internal class ParcelableSnapshotMutableState&lt;T&gt;( value: T, policy: SnapshotMutationPolicy&lt;T&gt;) : SnapshotMutableStateImpl&lt;T&gt;(value, policy), Parcelable { // 这里内部的代码全部都是对 Parcelable 接口的实现，我们不用关心，不是核心内容 ... ...} 关键在 SnapshotMutableStateImpl，它里面才是最核心的逻辑： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788internal open class SnapshotMutableStateImpl&lt;T&gt;( value: T, override val policy: SnapshotMutationPolicy&lt;T&gt;) : StateObjectImpl, SnapshotMutableState&lt;T&gt; { @Suppress(&quot;UNCHECKED_CAST&quot;) override var value: T get() = next.readable(this).value set(value) = next.withCurrent { if (!policy.equivalent(it.value, value)) { next.overwritable(this, it) { this.value = value } } } private var next: StateStateRecord&lt;T&gt; = StateStateRecord(value).also { if (Snapshot.isInSnapshot) { it.next = StateStateRecord(value).also { next -&gt; next.snapshotId = Snapshot.PreexistingSnapshotId } } } override val firstStateRecord: StateRecord get() = next override fun prependStateRecord(value: StateRecord) { @Suppress(&quot;UNCHECKED_CAST&quot;) next = value as StateStateRecord&lt;T&gt; } @Suppress(&quot;UNCHECKED_CAST&quot;) override fun mergeRecords( previous: StateRecord, current: StateRecord, applied: StateRecord ): StateRecord? { val previousRecord = previous as StateStateRecord&lt;T&gt; val currentRecord = current as StateStateRecord&lt;T&gt; val appliedRecord = applied as StateStateRecord&lt;T&gt; return if (policy.equivalent(currentRecord.value, appliedRecord.value)) current else { val merged = policy.merge( previousRecord.value, currentRecord.value, appliedRecord.value ) if (merged != null) { appliedRecord.create().also { (it as StateStateRecord&lt;T&gt;).value = merged } } else { null } } } override fun toString(): String = next.withCurrent { &quot;MutableState(value=${it.value})@${hashCode()}&quot; } private class StateStateRecord&lt;T&gt;(myValue: T) : StateRecord() { override fun assign(value: StateRecord) { @Suppress(&quot;UNCHECKED_CAST&quot;) this.value = (value as StateStateRecord&lt;T&gt;).value } override fun create(): StateRecord = StateStateRecord(value) var value: T = myValue } /** * The componentN() operators allow state objects to be used with the property destructuring * syntax */ override operator fun component1(): T = value override operator fun component2(): (T) -&gt; Unit = { value = it } /** * A function used by the debugger to display the value of the current value of the mutable * state object without triggering read observers. */ @Suppress(&quot;unused&quot;) val debuggerDisplayValue: T @JvmName(&quot;getDebuggerDisplayValue&quot;) get() = next.withCurrent { it }.value} 好长啊～算了，不看了🙈… 如果你仍打算继续往下看，那接下来我会带你一步步探索其中的奥秘！ 先看开头部分： 12345678910111213141516171819202122232425internal open class SnapshotMutableStateImpl&lt;T&gt;( value: T, override val policy: SnapshotMutationPolicy&lt;T&gt;) : StateObjectImpl, SnapshotMutableState&lt;T&gt; { @Suppress(&quot;UNCHECKED_CAST&quot;) override var value: T get() = next.readable(this).value set(value) = next.withCurrent { if (!policy.equivalent(it.value, value)) { next.overwritable(this, it) { this.value = value } } } private var next: StateStateRecord&lt;T&gt; = StateStateRecord(value).also { if (Snapshot.isInSnapshot) { it.next = StateStateRecord(value).also { next -&gt; next.snapshotId = Snapshot.PreexistingSnapshotId } } } override val firstStateRecord: StateRecord get() = next ... ...} 一个 value 属性印入眼帘，这就是文章开头代码里面用到的 name.value。 value 有 get() 和 set() 函数，并且都有具体的实现。 📓 next 是个啥？ 无论是 get() 还是 set() 都有一个 next。 12get() = next.readable(this).valueset(value) = next.withCurrent {...} 它是个啥？我们得先搞明白这个！ 1234567private var next: StateStateRecord&lt;T&gt; = StateStateRecord(value).also { if (Snapshot.isInSnapshot) { it.next = StateStateRecord(value).also { next -&gt; next.snapshotId = Snapshot.PreexistingSnapshotId } }} 它的类型是 StateStateRecord，那 StateStateRecord 又是个啥？ 12345678910private class StateStateRecord&lt;T&gt;(myValue: T) : StateRecord() { override fun assign(value: StateRecord) { @Suppress(&quot;UNCHECKED_CAST&quot;) this.value = (value as StateStateRecord&lt;T&gt;).value } override fun create(): StateRecord = StateStateRecord(value) var value: T = myValue} StateStateRecord 又继承了 StateRecord，那 StateRecord 又是个啥呢？ 123456abstract class StateRecord { internal var snapshotId: Int = currentSnapshot().id // 记录快照 id internal var next: StateRecord? = null // 下一个状态记录的引用，状态记录存储在一个链表中 abstract fun assign(value: StateRecord) // 复制 StateRecord abstract fun create(): StateRecord // 创建一个新的记录相同的 StateRecord} 看不懂？没关系，到这里你只需要记住一点：StateRecord 是一个链表的数据结构即可，而 StateStateRecord 实现了它，并且将 value 进行了封装。 下面我们要讲别的了，先记住：StateRecord 是一个链表的数据结构！ 接着说，如果你仔细看代码的话，会发现 SnapshotMutableStateImpl 其实继承了两个接口： 123456internal open class SnapshotMutableStateImpl&lt;T&gt;( value: T, override val policy: SnapshotMutationPolicy&lt;T&gt;) : StateObjectImpl, SnapshotMutableState&lt;T&gt; { ... ...} 一个 StateObjectImpl、一个 SnapshotMutableState。 我们先来看下 SnapshotMutableState： 123456interface SnapshotMutableState&lt;T&gt; : MutableState&lt;T&gt; { /** * A policy to control how changes are handled in a mutable snapshot. */ val policy: SnapshotMutationPolicy&lt;T&gt;} SnapshotMutableState 继承了 MutableState，正好对应着我们文章开头说的，mutableStateOf() 返回的就是一个 MutableState，我们之前说是因为它实现了「订阅」从而可以「刷新」。 但！！！真正的原因并不是因为它！ 真正实现状态订阅机制的是另外一个接口：StateObjet 我们现在来看下 StateObjectImpl 干了什么事： 123internal abstract class StateObjectImpl internal constructor() : StateObject { ...} 实现了 StateObject 接口： 1234567891011121314interface StateObject { /** * The first state record in a linked list of state records. */ val firstStateRecord: StateRecord fun prependStateRecord(value: StateRecord) fun mergeRecords( previous: StateRecord, current: StateRecord, applied: StateRecord ): StateRecord? = null} 代码非常简单，但里面有一个 核心： 1val firstStateRecord: StateRecord 它是干嘛用的？我们去瞅瞅哪里用了它： 12345678910private var next: StateStateRecord&lt;T&gt; = StateStateRecord(value).also { if (Snapshot.isInSnapshot) { it.next = StateStateRecord(value).also { next -&gt; next.snapshotId = Snapshot.PreexistingSnapshotId } }} override val firstStateRecord: StateRecord get() = next 哦，原来 firstStateRecord 是用来记录 StateRecord 这个链表的 头节点 用的。 📓 get() 上面应该算是把 next 是什么讲清楚了吧？ 它就是 StateRecord，更准确的说就是 StateRecord 链表的头节点 下面我们开始扒扒 get() 的逻辑： 1get() = next.readable(this).value 进入 readable() ： 1234567891011fun &lt;T : StateRecord&gt; T.readable(state: StateObject): T { val snapshot = Snapshot.current // 第一件事 snapshot.readObserver?.invoke(state) // 第二件事 return readable(this, snapshot.id, snapshot.invalid) ?: sync { val syncSnapshot = Snapshot.current @Suppress(&quot;UNCHECKED_CAST&quot;) readable(state.firstStateRecord as T, syncSnapshot.id, syncSnapshot.invalid) ?: readError() }} 干了两件事，第一件事： 1snapshot.readObserver?.invoke(state) // 第一件事 readObserver 是一个读操作的观察者，这个操作是记录 StateObject 中的值被哪里调用了，比如开头的代码示例： 1234567891011121314151617181920class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val name = mutableStateOf(&quot;Compose&quot;) setContent { ComposeBlogTheme { // 这里调用了 name.value，就会执行到： // get() --&gt; readObserver() --&gt; 记录这里调用了 value 值 Text(name.value) } LaunchedEffect(true) { delay(3000) name.value = &quot;Kotlin&quot; } } }} 所以，我们可以把这个操作理解为它是一个订阅操作：订阅状态，记录 name.value 在哪里调用了。 第二件事： 12345return readable(this, snapshot.id, snapshot.invalid) ?: sync { val syncSnapshot = Snapshot.current @Suppress(&quot;UNCHECKED_CAST&quot;) readable(state.firstStateRecord as T, syncSnapshot.id, syncSnapshot.invalid) ?: readError()} 又调用了三参数的 readable()： 1234567891011121314151617private fun &lt;T : StateRecord&gt; readable(r: T, id: Int, invalid: SnapshotIdSet): T? { // The readable record is the valid record with the highest snapshotId var current: StateRecord? = r var candidate: StateRecord? = null while (current != null) { if (valid(current, id, invalid)) { candidate = if (candidate == null) current else if (candidate.snapshotId &lt; current.snapshotId) current else candidate } current = current.next } if (candidate != null) { @Suppress(&quot;UNCHECKED_CAST&quot;) return candidate as T } return null} 前边我们说过：StateRecord 是一个链表，而三参数里面的工作就是通过表头对象遍历列表来获取 最新的、有效的 StateRecord。 最终返回一个 最新的、有效的 StateRecord。（什么是最新的、有效的，这个可以不用关心，这跟要结合 Snapshot 快照系统说，你直接过滤即可，不影响我们原理的理解） 所以，整个 readable() 方法就干了两件事： 返回最新的、有效的 StateRecord 记录在哪里调用了 value 1get() = next.readable(this).value 最后还剩一个 value，这就很简单了，前面我们说过 StateStateRecord (StateRecord 的实现类) 会对 value 进行封装，而 StateRecord 只是一个链表，我们要想获取到值，就要再调用 value 获取内部被包着的值。 到这里 get() 就讲完了！ 📓 set() 现在来看 set() 的具体代码：（细节点注意：这边我把代码截图了，而不是纯代码段，你留意一下，下面会回归到这里） next 是啥不用说了吧，那 withCurrent 是什么？ 12inline fun &lt;T : StateRecord, R&gt; T.withCurrent(block: (r: T) -&gt; R): R = block(current(this)) 它只有一个参数 block，而 block 是一个函数类型的参数，它的工作很直接，直接调用这个函数类型的参数，也就是 withCurrent 后面跟着的 Lambda 表达式。 block 里面传入了一个 current 函数，它做了什么： 12345678internal fun &lt;T : StateRecord&gt; current(r: T) = Snapshot.current.let { snapshot -&gt; readable(r, snapshot.id, snapshot.invalid) ?: sync { Snapshot.current.let { syncSnapshot -&gt; readable(r, syncSnapshot.id, syncSnapshot.invalid) } } ?: readError() } 发现了什么？它调用了一个三参数的 readable()，你还记得三参数的 readable() 是做什么的吗？ ⇒ 获取 最新的、有效的 StateRecord。 这个时候你再看下我开头为啥对代码做了截图： 懂啥意思没？withCurrent 传入的 current 函数的返回值就对应着代码提示器提示的 it 对象（一个 StateStateRecord）。 接着看代码： 123456set(value) = next.withCurrent { // 判断新旧值 if (!policy.equivalent(it.value, value)) { next.overwritable(this, it) { this.value = value } }} if 判断里面会判断取到的 StateRecord 的值和新设置的值是否相同，没变直接结束，变了就进入下一步 overwritable()。 我们看看它做了什么： 123456789101112131415internal inline fun &lt;T : StateRecord, R&gt; T.overwritable( state: StateObject, candidate: T, block: T.() -&gt; R): R { var snapshot: Snapshot = snapshotInitializer return sync { // 第一件事 snapshot = Snapshot.current // 第二件事 this.overwritableRecord(state, snapshot, candidate).block() }.also { notifyWrite(snapshot, state) }} 也干了两件事： 获取快照；2. 调用了overwritableRecord() 函数； Snapshot 快照的知识我们可以先忽略，来看 overwritableRecord() 做了什么： 12345678910111213141516171819202122internal fun &lt;T : StateRecord&gt; T.overwritableRecord( state: StateObject, snapshot: Snapshot, candidate: T): T { if (snapshot.readOnly) { // If the snapshot is read-only, use the snapshot recordModified to report it. snapshot.recordModified(state) } val id = snapshot.id // 核心模块 1 if (candidate.snapshotId == id) return candidate // 核心模块 2 val newData = sync { newOverwritableRecordLocked(state) } newData.snapshotId = id if (candidate.snapshotId != Snapshot.PreexistingSnapshotId) snapshot.recordModified(state) return newData} 我们将代码分为两端来看： 核心代码块 1： 如果传进来的 StateRecord 的快照 id 正好对应当前 snapshot 的 id，那么直接返回。 核心代码块 2： 否则会创建一个新的或者返回一个弃用的 StateRecord，然后将快照 id 赋予新的 StateRecord。 说白了最终就是要取到一个对应当前 snapshot 的 StateRecord！ 1234567891011121314internal inline fun &lt;T : StateRecord, R&gt; T.overwritable( state: StateObject, candidate: T, block: T.() -&gt; R): R { var snapshot: Snapshot = snapshotInitializer return sync { snapshot = Snapshot.current // 取到一个对应当前 snapshot 的 StateRecord this.overwritableRecord(state, snapshot, candidate).block() }.also { notifyWrite(snapshot, state) }} 取到对应当前 snapshot 的 StateRecord 后，紧接着调用了 block()，它是传进来的参数，是外面传进来的，也就是 {this.value = value}。 123456set(value) = next.withCurrent { // 判断新旧值 if (!policy.equivalent(it.value, value)) { next.overwritable(this, it) { this.value = value } }} 又拐回来了，把传入的新值赋值给拿到的 StateRecord 内部的 value，这不就是写新值的操作么？ 到这里是不是 set() 流程是不是我们就讲完了？ No～，我们再看一下 overwritable() 方法内部： 1234567891011121314internal inline fun &lt;T : StateRecord, R&gt; T.overwritable( state: StateObject, candidate: T, block: T.() -&gt; R): R { var snapshot: Snapshot = snapshotInitializer return sync { snapshot = Snapshot.current // 这里讲完了 this.overwritableRecord(state, snapshot, candidate).block() }.also { notifyWrite(snapshot, state) // 但这里还有个 notifyWrite }} 还有一行我们遗漏了，notifyWrite() 又做了什么？ 1234internal fun notifyWrite(snapshot: Snapshot, state: StateObject) { snapshot.writeCount += 1 snapshot.writeObserver?.invoke(state)} 有种似曾相识的感觉，在前面分析 get() 函数的时候，我们看到过单参数的 readable() 里面有一行： 1snapshot.readObserver?.invoke(state) 那这里的作用呢？ ⇒ 寻找变量在哪里被读了，然后将这部分内容的组合标记为失效，等到下一帧的时候会重组刷新。 所以，整个 set() 方法就干了两件事： 将传入的值赋值给 StateRecord 内部的 value 写入通知刷新 到这里我们就基本上能够很清晰的明白了状态订阅&amp;自动刷新机制的原理了： 当 get() 被调用的时候，不仅返回值，还会记录读值的地方，也就是哪里调用了（相当于订阅）。 当 set() 被调用的时候，不仅修改值，还会查找读值的地方，然后进行刷新操作（相当于通知）。 代理/委托：by 在实际开发中，如果每次获取值都要加上 value 会显得很冗余，所以 Compose 给我们提供了一种更方便的写法：by。它是 Kotlin 的一个关键字，表示左边的变量用右边的对象作为代理（委托）。 12345678910111213class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val name by mutableStateOf(&quot;Compose&quot;) setContent { ComposeBlogTheme { Text(name) // 可以直接 name，而不需要 name.value } } }} 如果你这么写，IDLE 会提示报错，因为 name 委托给了 mutableStateOf，如果我们要获取 name 的值，那委托对象需要调用 getValue() 和 setValue() 两个函数，这两个函数需要自己实现。 但实际上并不需要我们实现，你通过提示也可以看出来，我们可以直接导入，因为 Compose 内部已经帮我们实现好了这个方法。 12import androidx.compose.runtime.getValueimport androidx.compose.runtime.setValue 自此，关于 Compose 的状态订阅&amp;自动刷新机制的原理算是讲明白了吧！","link":"/2025/07/01/compose/Compose%20--%20%E7%8A%B6%E6%80%81%E8%AE%A2%E9%98%85%20&%20%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%20--%2001.%20%E8%A7%A3%E6%9E%90%20mutableStateOf%20%E6%BA%90%E7%A0%81/"},{"title":"有状态、无状态、状态提升","text":"Source Code based on: androidx.compose.**:**:1.5.0 先来看两段 Compose 的官方描述： 利用 Compose，您可以构建不与特定 activity 或 fragment 相关联的小型「无状态」组件，这让您可以轻松重用和测试这些组件。 使用 remember 存储对象的可组合项包含「内部状态」，这会使该可组合项「有状态」。在调用方不需要控制状态，并且不必自行管理状态便可使用状态的情况下，「有状态」会非常有用。但是，具有「内部状态」的可组合项往往不易重复使用，也更难测试。 所以我们可以抛出三个问题： 什么是「无状态」？ 什么是「有状态」？ 什么是「内部状态」？ 带着这三个问题，我们开始探讨 Compose 中的状态。 无状态状态是什么？ 在传统 Android 中，比如 TextView，它的状态就是「内部的属性」，比如我们可以通过 getText() 获取 TextView 的文字，setText() 设置 TextView 的文字。 我们看下面的代码： 12345678910class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { val name = &quot;Hi, Compose&quot; Text(name) } }} 现在思考一个问题：Text() 组件在这里能像 TextView() 一样既能 getText()、也能 setText() 吗？ 很明显不能！Text(name) 只是用了 name，并没有保存，所以它是一个「无状态组件」。 有状态现在我们自定义一个 Compose 函数： 12345@Composablefun HiCompose() { val name = &quot;Hi, Compose&quot; Text(name)} 请问：Text() 有状态吗？- - 没有（我们刚刚才说过） 那么：HiCompose() 呢？- - 有！它的内部有一个属于它自己的变量：Hi, Compose，准确的来说，它是有「内部状态」的。 所以，Compose 组件是可以「有状态」，也可以「无状态」，而所谓的有没有状态 - - 其实都是指：「内部状态」！ 状态提升思考一个问题，既然 HiCompose() 函数是有「内部状态」的，那我如果想从「外部」获取它的「内部状态」，该如何做？ 比如下面的代码： 123456789101112131415class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { HiCompose().name ??? // 这里如何获取到 HiCompose 内部的 name? } }}@Composablefun HiCompose() { val name = &quot;Hi, Compose&quot; Text(name)} 这就相当于你要从外部获取一个函数内部的变量，是获取不到的，那如何做呢？ 123456789101112131415class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { val name = &quot;Hi, Compose&quot; HiCompose(name) } }}@Composablefun HiCompose(name: String) { Text(name)} 我们把 HiCompose() 「内部状态」给提到了「参数」里面，然后外部就可以传入「状态」，两者就联系起来了。 在 Compose 中这种做法就叫做：「状态提示」（State Hoisting） 那么，此时 HiCompose 还有状态吗？- - 现在它就是「无状态」的！因为它已经没有「内部状态」了，状态上提到外面去了。 输入框：TextFieldCompose 有一个典型的状态提升的组件示例：TextField，它是一个文本输入框，类似于 EditText。 123456789class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { TextField(value = , onValueChange = ) } }} 其中 value 就是从 TextField 内部提升上来的，我们来给它传个值： 12345678910class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { var name = &quot;&quot; TextField(name, onValueChange = ) } }} onValueChange 是一个函数类型的参数，可以写成 Lambda 表达式： 12345678910111213class MainActivity : ComponentActivity() { @OptIn(ExperimentalMaterial3Api::class) override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { var name = &quot;&quot; TextField(name, { }) } }} 此时什么也没填，运行看下效果： 键盘都敲冒烟了，但是输入框却没有任何内容，问题肯定出在 onValueChange，因为我们什么也没填，那填什么？ 12345678910111213class MainActivity : ComponentActivity() { @OptIn(ExperimentalMaterial3Api::class) override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { var name = &quot;&quot; TextField(name, { newValue -&gt; name = newValue }) } }} 这就这么简单，newValue 就是输入的内容，把 newValue 赋值给 name，name 才是输入框显示的内容实际值。 运行看下效果： 怎么还不行？如果你看了之前的文章，应该能找到问题点在哪！ 修改下代码： 12345678910111213class MainActivity : ComponentActivity() { @OptIn(ExperimentalMaterial3Api::class) override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { var name by remember { mutableStateOf(&quot;&quot;) } TextField(name, { newValue -&gt; name = newValue }) } }} 再次运行：","link":"/2025/07/13/compose/Compose%20--%20%E7%8A%B6%E6%80%81%E8%AE%A2%E9%98%85%20&%20%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%20--%2003.%20%E6%9C%89%E7%8A%B6%E6%80%81%E3%80%81%E6%97%A0%E7%8A%B6%E6%80%81%E3%80%81%E7%8A%B6%E6%80%81%E6%8F%90%E5%8D%87/"},{"title":"细说 remember 和重组作用域","text":"基于 androidx.compose.runtime:runtime:1.7.1 版本 阅读本篇文章之前，建议先看看【 解析 mutableStateOf 源码 】 一文，因为两篇文章是上下篇的关系，看完上篇，可以更好的串联知识点。 Simple Code 话不多说，还是老样子，从 Demo 一步步引出我们的核心知识点。 1234567891011121314151617class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var name by mutableStateOf(&quot;Compose&quot;) setContent { Text(name) // 延时更新 Text 内容 LaunchedEffect(true) { delay(3000) name = &quot;Kotlin&quot; } } }} 一段很简单的代码示例，3s 后文字从 Compose 变为 kotlin，执行看下效果： 现在我们改下代码： 1234567891011121314151617class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { // 从外面挪到里面来... var name by mutableStateOf(&quot;Compose&quot;) Text(name) // 延时更新 Text 内容 LaunchedEffect(true) { delay(3000) name = &quot;Kotlin&quot; } } }} 执行看下效果： 奇怪的事情发生了，3s 后文字没有刷新！ 重组作用域 问题出在哪？ 首先我们回顾下 Compose 是怎么「刷新界面」的？比如上面的例子，当 name 重新赋值后，读取它的地方会被标记为「失效」，然后「重组刷新」。 关键知识点 在 Compose 中「重组刷新」并不是单纯的刷新 Text(name) 这一行，而是会把包含 Text(name) 的代码块给包起来，刷新的是「整个代码块」，或者说重组「整个代码块」！ 就像下面这个样子： 这段蓝色背景的代码块会被重新执行一遍，这个蓝色区域就是所谓的：重组作用域（Recompose scope）！ 所以导致没有刷新的根本原因就是： 不仅仅 Text(name) 会被重新执行，var name by mutableStateOf(&quot;Compose&quot;) 也会执行！导致 name 又被重新初始化了。 remember那怎么解决？不知道你发现没有，其实开发工具已经提示我们了： mutableStateOf 是标红的，并且错误提示：Creating a state object during composition without using remember. 意思就是：你在组合过程里面创建了 StateObject 对象，但是没有用 remember。 那怎么使用？很简单，只需要套一层 remember，代码如下： 123456789101112131415class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { var name by remember { mutableStateOf(&quot;Compose&quot;) } Text(name) LaunchedEffect(true) { delay(3000) name = &quot;Kotlin&quot; } } }} 加了 remember 后，在第一次执行的时候，会执行 Lambda 表达式，也就是执行 mutableStateOf(&quot;Compose&quot;)，并且 remember 会保存结果（StateObject），再次调用的时候会直接返回保存的老对象（StateObject），而不是再次执行 Lambda 表达式里面的代码，相当于充当了「缓存」的功能。 我们执行下修改后的代码： 文字更新了！remember 起到了缓存的作用，就是为了防止多次初始化变量而导致程序不可控！ 所以有个原则 在 Compose 里面你只要用了 mutableStateOf，那么能加 remember 我们就加 remember。 另外我们需要注意 remember 是可以带参数的：可以「一个」或者「多个」参数。 1234567891011121314151617181920212223242526272829📄 androidx.compose.runtime -&gt; Composables.kt/** * Remember the value returned by [calculation] if [key1] is equal to the previous composition, * otherwise produce and remember a new value by calling [calculation]. */@Composableinline fun &lt;T&gt; remember( key1: Any?, calculation: @DisallowComposableCalls () -&gt; T): T { return currentComposer.cache(currentComposer.changed(key1), calculation)}/** * Remember the value returned by [calculation] if [key1] and [key2] are equal to the previous * composition, otherwise produce and remember a new value by calling [calculation]. */@Composableinline fun &lt;T&gt; remember( key1: Any?, key2: Any?, calculation: @DisallowComposableCalls () -&gt; T): T { return currentComposer.cache( currentComposer.changed(key1) or currentComposer.changed(key2), calculation )} 有什么用，举个例子说明，比如我们自定义了一个 Composable 函数： 12345@Composablefun showCharCount(value: String) { val length = value.length Text(&quot;字符串长度：$length&quot;)} 很简单，一个显示字符串长度的函数。 现在我们来假设一个场景： 传入进来的字符串特别长； 并且 showCharCount 反复被调用了很多次； 那么 value.length 每次都被调用，就显得有点笨重了，所以我们可以给它加上一个 remember： 1234567@Composablefun showCharCount(value: String) { val length = remember { value.length } Text(&quot;字符串长度：$length&quot;)} 但此时就会出现一个问题： 12345678910@Composablefun showCharCount(value: String) { // 第一次传进来：abcd // 第二次传进来：abcdefg // 第三次传进来：abcdefghijklmn val length = remember { value.length } Text(&quot;字符串长度：$length&quot;)} 字符串长度永远都是：4，因为 value.length 不会被执行，那怎么办： 12345678910@Composablefun showCharCount(value: String) { // 第一次传进来：abcd // 第二次传进来：abcdefg // 第三次传进来：abcdefghijklmn val length = remember(value) { value.length } Text(&quot;字符串长度：$length&quot;)} 我们给 remember 加了一个参数：value，只要这个 key 变化了，那么就会重新执行 Lambda 表达式，这就是带参数的 remember 的用法。","link":"/2025/07/07/compose/Compose%20--%20%E7%8A%B6%E6%80%81%E8%AE%A2%E9%98%85%20&%20%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%20--%2002.%20remember%20%E5%92%8C%E9%87%8D%E7%BB%84%E4%BD%9C%E7%94%A8%E5%9F%9F/"}],"tags":[{"name":"Compose","slug":"Compose","link":"/tags/Compose/"},{"name":"状态订阅 &amp; 自动更新","slug":"状态订阅-自动更新","link":"/tags/%E7%8A%B6%E6%80%81%E8%AE%A2%E9%98%85-%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0/"},{"name":"mutableStateListOf","slug":"mutableStateListOf","link":"/tags/mutableStateListOf/"},{"name":"Compose 状态","slug":"Compose-状态","link":"/tags/Compose-%E7%8A%B6%E6%80%81/"},{"name":"remember","slug":"remember","link":"/tags/remember/"},{"name":"重组作用域","slug":"重组作用域","link":"/tags/%E9%87%8D%E7%BB%84%E4%BD%9C%E7%94%A8%E5%9F%9F/"}],"categories":[{"name":"Compose","slug":"Compose","link":"/categories/Compose/"},{"name":"状态订阅 &amp; 自动更新","slug":"Compose/状态订阅-自动更新","link":"/categories/Compose/%E7%8A%B6%E6%80%81%E8%AE%A2%E9%98%85-%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0/"}],"pages":[]}