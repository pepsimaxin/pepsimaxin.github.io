{"posts":[{"title":"解析 mutableStateOf 源码","text":"其实原理性分析的文章，真的很难讲的通俗易懂，讲的简单浅显没必要写，讲的繁琐难懂往往大家也不乐意看，所以怎么找个好的角度慢慢钻进去尤为重要，比如：Begin simple code，如果确实能帮助到大家完全理解了文章所讲述到的源码理论，那就点个赞吧！ 引入话题 正如我上面说的，直接讲原理太枯燥（你也会很懵），我喜欢从简单代码入手，带你一点点进入，现在开始。先看一个最简单的代码示例： 1234567891011121314class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // 这种定义变量的方式随处可见了 val name = mutableStateOf(&quot;Compose&quot;) setContent { ComposeBlogTheme { Text(name.value) } } }} 我先来简单解读一下这段代码的原理： 当我们定义一个变量，用 mutableStateOf 包起来后，它就变成了一个 MutableState 类型的对象。 同时，我们取值的话就必须要写 name.value，这样能才能取到 “Compose”，因为name 不再是一个 String，而是 MutableState 对象，也可以叫“状态” 。 此时，name 是一个被订阅的状态，name.value 就是一个被订阅的值，如果它发生变化，Text() 函数就会重新执行一遍，更新到最新的值。 现在我们修改下代码，3s 后改变 name.value 的值： 123456789101112131415161718class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val name = mutableStateOf(&quot;Compose&quot;) setContent { ComposeBlogTheme { Text(name.value) } LaunchedEffect(true) { delay(3000) // 3s 延迟 name.value = &quot;Kotlin&quot; // 修改 name.value } } }} 运行下： ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/141782121dd4b200a5d4e86a30eb3edf.gif =400x) 现在关于 mutableStateOf 的用法你已经掌握了，但同时就会产生了一个疑问，name 被自动订阅了，它的值改变了就会让界面重新刷新，这背后的“状态订阅&amp;刷新机制”的原理是什么？ 如果你想深入了解，那么接着往下看。 状态订阅&amp;自动刷新 基于 androidx.compose.runtime:runtime:1.4.0 版本 硬核部分走起，查看 mutableStateOf() 源码： 1234fun &lt;T&gt; mutableStateOf( value: T, policy: SnapshotMutationPolicy&lt;T&gt; = structuralEqualityPolicy()): MutableState&lt;T&gt; = createSnapshotMutableState(value, policy) mutableStateOf() 返回的是一个 MutableState 对象，这个我们前面说过。 mutableStateOf() 又调用了另一个函数：**createSnapshotMutableState()**。 进入 **createSnapshotMutableState()**： 1234internal actual fun &lt;T&gt; createSnapshotMutableState( value: T, policy: SnapshotMutationPolicy&lt;T&gt;): SnapshotMutableState&lt;T&gt; = ParcelableSnapshotMutableState(value, policy) 又调用了 ParcelableSnapshotMutableState() 函数： 1234567internal class ParcelableSnapshotMutableState&lt;T&gt;( value: T, policy: SnapshotMutationPolicy&lt;T&gt;) : SnapshotMutableStateImpl&lt;T&gt;(value, policy), Parcelable { // 这里内部的代码全部都是对 Parcelable 接口的实现，我们不用关心，不是核心内容 ... ...} 关键在 SnapshotMutableStateImpl，它里面才是最核心的逻辑： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788internal open class SnapshotMutableStateImpl&lt;T&gt;( value: T, override val policy: SnapshotMutationPolicy&lt;T&gt;) : StateObject, SnapshotMutableState&lt;T&gt; { @Suppress(&quot;UNCHECKED_CAST&quot;) override var value: T get() = next.readable(this).value set(value) = next.withCurrent { if (!policy.equivalent(it.value, value)) { next.overwritable(this, it) { this.value = value } } } private var next: StateStateRecord&lt;T&gt; = StateStateRecord(value) override val firstStateRecord: StateRecord get() = next override fun prependStateRecord(value: StateRecord) { @Suppress(&quot;UNCHECKED_CAST&quot;) next = value as StateStateRecord&lt;T&gt; } @Suppress(&quot;UNCHECKED_CAST&quot;) override fun mergeRecords( previous: StateRecord, current: StateRecord, applied: StateRecord ): StateRecord? { val previousRecord = previous as StateStateRecord&lt;T&gt; val currentRecord = current as StateStateRecord&lt;T&gt; val appliedRecord = applied as StateStateRecord&lt;T&gt; return if (policy.equivalent(currentRecord.value, appliedRecord.value)) current else { val merged = policy.merge( previousRecord.value, currentRecord.value, appliedRecord.value ) if (merged != null) { appliedRecord.create().also { (it as StateStateRecord&lt;T&gt;).value = merged } } else { null } } } override fun toString(): String = next.withCurrent { &quot;MutableState(value=${it.value})@${hashCode()}&quot; } private class StateStateRecord&lt;T&gt;(myValue: T) : StateRecord() { override fun assign(value: StateRecord) { @Suppress(&quot;UNCHECKED_CAST&quot;) this.value = (value as StateStateRecord&lt;T&gt;).value } override fun create(): StateRecord = StateStateRecord(value) var value: T = myValue } /** * The componentN() operators allow state objects to be used with the property destructuring * syntax * * ``` * var (foo, setFoo) = remember { mutableStateOf(0) } * setFoo(123) // set * foo == 123 // get * ``` */ override operator fun component1(): T = value override operator fun component2(): (T) -&gt; Unit = { value = it } /** * A function used by the debugger to display the value of the current value of the mutable * state object without triggering read observers. */ @Suppress(&quot;unused&quot;) val debuggerDisplayValue: T @JvmName(&quot;getDebuggerDisplayValue&quot;) get() = next.withCurrent { it }.value} 好长啊～算了，不看了🙈… 接下来我带你一步步探索其中的奥秘！ 先看开头部分： 12345678910111213141516171819internal open class SnapshotMutableStateImpl&lt;T&gt;( value: T, override val policy: SnapshotMutationPolicy&lt;T&gt;) : StateObject, SnapshotMutableState&lt;T&gt; { @Suppress(&quot;UNCHECKED_CAST&quot;) override var value: T get() = next.readable(this).value set(value) = next.withCurrent { if (!policy.equivalent(it.value, value)) { next.overwritable(this, it) { this.value = value } } } private var next: StateStateRecord&lt;T&gt; = StateStateRecord(value) override val firstStateRecord: StateRecord get() = next ... ...} 一个 value 属性印入眼帘，这就是文章开头代码里面用到的 name.value。 value 有 get() 和 set() 函数，并且都有具体的实现。 📓 next 是个啥？ 无论是 get() 还是 set() 都有一个 next。 12get() = next.readable(this).valueset(value) = next.withCurrent {...} 它是个啥？我们得先搞明白这个。 1private var next: StateStateRecord&lt;T&gt; = StateStateRecord(value) 它的类型是 StateStateRecord，那 StateStateRecord 有是个啥？ 12345678910private class StateStateRecord&lt;T&gt;(myValue: T) : StateRecord() { override fun assign(value: StateRecord) { @Suppress(&quot;UNCHECKED_CAST&quot;) this.value = (value as StateStateRecord&lt;T&gt;).value } override fun create(): StateRecord = StateStateRecord(value) var value: T = myValue} StateStateRecord 继承了 StateRecord，那 StateRecord 又是个啥呢？ 123456abstract class StateRecord { internal var snapshotId: Int = currentSnapshot().id // 记录快照 id internal var next: StateRecord? = null // 下一个状态记录的引用，状态记录存储在一个链表中 abstract fun assign(value: StateRecord) // 复制 StateRecord abstract fun create(): StateRecord // 创建一个新的记录相同的 StateRecord} 你只要知道 StateRecord 是一个链表的数据结构即可，而 StateStateRecord 实现了它，并且将 value 进行了封装。 下面我们要讲别的了，先记住：StateRecord 是一个链表的数据结构！ 接着说，如果你仔细看代码的话，会发现 SnapshotMutableStateImpl 其实继承了两个接口： 123456internal open class SnapshotMutableStateImpl&lt;T&gt;( value: T, override val policy: SnapshotMutationPolicy&lt;T&gt;) : StateObject, SnapshotMutableState&lt;T&gt; { ... ...} 一个 StateObjet、一个 SnapshotMutableState。 我们先来看下 SnapshotMutableState： 123456interface SnapshotMutableState&lt;T&gt; : MutableState&lt;T&gt; { /** * A policy to control how changes are handled in a mutable snapshot. */ val policy: SnapshotMutationPolicy&lt;T&gt;} SnapshotMutableState 继承了 MutableState，正好对应着我们文章开头说的，mutableStateOf() 返回的就是一个 MutableState，我们说是因为它实现了订阅从而可以刷新，但！！！真正的原因并不是因为它！ 真正实现状态订阅机制的是另外一个接口：StateObjet！ 我们现在来看下 StateObject 这个大佬干了什么事： 1234567891011121314interface StateObject { /** * The first state record in a linked list of state records. */ val firstStateRecord: StateRecord fun prependStateRecord(value: StateRecord) fun mergeRecords( previous: StateRecord, current: StateRecord, applied: StateRecord ): StateRecord? = null} 代码非常简单，但里面有一个核心： 1val firstStateRecord: StateRecord 它是干嘛用的？我们去瞅瞅哪里用了它： 1234private var next: StateStateRecord&lt;T&gt; = StateStateRecord(value) override val firstStateRecord: StateRecord get() = next 哦，原来 firstStateRecord 是用来记录 StateRecord 这个链表的 头节点 用的。 📓 get() 上面应该算是把 next 是什么讲清楚了吧？– 它就是 StateRecord，更准确的说就是 StateRecord 链表的头节点。 下面我们开始扒扒 get() 具体的逻辑了。 1get() = next.readable(this).value 进入 readable() ： 1234567891011fun &lt;T : StateRecord&gt; T.readable(state: StateObject): T { val snapshot = Snapshot.current // 第一件事 snapshot.readObserver?.invoke(state) // 第二件事 return readable(this, snapshot.id, snapshot.invalid) ?: sync { val syncSnapshot = Snapshot.current @Suppress(&quot;UNCHECKED_CAST&quot;) readable(state.firstStateRecord as T, syncSnapshot.id, syncSnapshot.invalid) ?: readError() }} 干了两件事，第一件事： 1snapshot.readObserver?.invoke(state) // 第一件事 readObserver 是一个读操作的观察者，这个操作是记录 StateObject 中的值被哪里调用了，比如开头的代码示例： 1234567891011121314151617181920class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val name = mutableStateOf(&quot;Compose&quot;) setContent { ComposeBlogTheme { // 这里调用了 name.value，就会执行到： // get() --&gt; readServer() --&gt; 记录这里调用了 value 值 Text(name.value) } LaunchedEffect(true) { delay(3000) name.value = &quot;Kotlin&quot; } } }} 所以，我们可以把这个操作理解为它是一个订阅操作：订阅状态，记录 name.value 在哪里调用了。 第二件事： 12345return readable(this, snapshot.id, snapshot.invalid) ?: sync { val syncSnapshot = Snapshot.current @Suppress(&quot;UNCHECKED_CAST&quot;) readable(state.firstStateRecord as T, syncSnapshot.id, syncSnapshot.invalid) ?: readError()} 调用了三参数的 readable()： 1234567891011121314151617private fun &lt;T : StateRecord&gt; readable(r: T, id: Int, invalid: SnapshotIdSet): T? { // The readable record is the valid record with the highest snapshotId var current: StateRecord? = r var candidate: StateRecord? = null while (current != null) { if (valid(current, id, invalid)) { candidate = if (candidate == null) current else if (candidate.snapshotId &lt; current.snapshotId) current else candidate } current = current.next } if (candidate != null) { @Suppress(&quot;UNCHECKED_CAST&quot;) return candidate as T } return null} 前边我们说错：StateRecord 是一个链表，三参数里面的工作就是通过表头对象遍历列表来获取 最新的、有效的 StateRecord。 最终返回一个 最新的、有效的 StateRecord。（什么是最新的、有效的，这个可以不用关心，这跟要结合 Snapshot 快照系统说，你直接过滤即可，不影响我们原理的理解） 所以，整个 readable() 方法就干了两件事： 返回最新的、有效的 StateRecord 记录在哪里调用了 value 1get() = next.readable(this).value 最后还剩一个 value，这就很简单了，前面我们说过 StateStateRecord (StateRecord 的实现类) 会对 value 进行封装，而 StateRecord 它们只是一个链表，我们要获取到值，就要再调用 value 获取内部被包着的值。 到这里 get() 就讲完了！ 📓 set() 现在来看 set() 的具体代码：（细节点注意：这边我把代码截图了，而不是纯代码段，你留意一下，下面会回归到这里） ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/548aff88360d4dffda83386ed2ee80e3.png =500x) next 是啥不用说了吧，那 withCurrent 是什么？ 12inline fun &lt;T : StateRecord, R&gt; T.withCurrent(block: (r: T) -&gt; R): R = block(current(this, Snapshot.current)) 它只有一个参数 block，而 block 是一个函数类型的参数，它的工作很直接，直接调用这个函数类型的参数，也就是 withCurrent 后面跟着的 Lambda 表达式。 ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/63c3c244bd0959768487d28c00ed08ca.png =500x) block 里面传入了一个 current 函数，它做了什么： 12internal fun &lt;T : StateRecord&gt; current(r: T, snapshot: Snapshot) = readable(r, snapshot.id, snapshot.invalid) ?: readError() 发现了什么？它调用了一个三参数的 readable()，你还记得三参数的 readable() 是做什么的吗？ ⇒ 获取 最新的、有效的 StateRecord。 这个时候你在看下我开头为啥对代码做了截图： ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/df81d16a784a74cbb297037fdce6eda0.png =500x) 懂啥意思没？withCurrent 传入的 current 函数的返回值就对应着代码提示器提示的 it 对象（一个 StateStateRecord）。 接着看代码： 123456set(value) = next.withCurrent { // 判断新旧值 if (!policy.equivalent(it.value, value)) { next.overwritable(this, it) { this.value = value } }} if 判断里面会判断取到的 StateRecord 的值和新设置的值是否相同，没变直接结束，变了就进入下一步 overwritable()。 我们看看它做了什么： 123456789101112131415internal inline fun &lt;T : StateRecord, R&gt; T.overwritable( state: StateObject, candidate: T, block: T.() -&gt; R): R { var snapshot: Snapshot = snapshotInitializer return sync { // 第一件事 snapshot = Snapshot.current // 第二件事 this.overwritableRecord(state, snapshot, candidate).block() }.also { notifyWrite(snapshot, state) }} 也干了两件事： 获取快照；2. 调用了overwritableRecord() 函数； Snapshot 快照的知识我们可以先忽略，来看 overwritableRecord() 做了什么： 12345678910111213141516171819internal fun &lt;T : StateRecord&gt; T.overwritableRecord( state: StateObject, snapshot: Snapshot, candidate: T): T { if (snapshot.readOnly) { snapshot.recordModified(state) } val id = snapshot.id if (candidate.snapshotId == id) return candidate val newData = newOverwritableRecord(state) newData.snapshotId = id snapshot.recordModified(state) return newData} 这段代码又涉及到了另外一个知识点：Snapshot（快照）。 我们将代码分为两端来看： ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/9b9068d1ad9357f3b556a0a502884f0c.png =700x) 核心代码块 1：如果传进来的 StateRecord 的快照 id 正好对应当前 snapshot 的 id，那么直接返回。 核心代码块 2：否则会创建一个新的或者返回一个弃用的 StateRecord，然后将快照 id 赋予新的 StateRecord。 说白了最终就是要取到一个对应当前 snapshot 的 StateRecord！ 🤔 此时就存在一个很大的疑问了？什么是 Snapshot（快照）？Snapshot 怎么和 StateRecord 绑在一起了？ 关于 Compose 的 Snapshot 机制，可以看看这篇文章 揭秘 Jetpack Compose快照系统 ，讲的很好。 但由于 Snapshot 真的不是一两句就能说清楚的，但我仍然告诉你它不影响你对这篇文章原理的理解。 继续回到代码： 1234567891011121314internal inline fun &lt;T : StateRecord, R&gt; T.overwritable( state: StateObject, candidate: T, block: T.() -&gt; R): R { var snapshot: Snapshot = snapshotInitializer return sync { snapshot = Snapshot.current // 取到一个对应当前 snapshot 的 StateRecord this.overwritableRecord(state, snapshot, candidate).block() }.also { notifyWrite(snapshot, state) }} 取到对应当前 snapshot 的 StateRecord 后，紧接着调用了 block()，它是传进来的参数，是外面传进来的，也就是 {this.value = value}。 123456set(value) = next.withCurrent { // 判断新旧值 if (!policy.equivalent(it.value, value)) { next.overwritable(this, it) { this.value = value } }} 又拐回来了，把传入的新值赋值给拿到的 StateRecord 内部的 value，这不就是写新值的操作么？ 到这里是不是 set() 流程是不是我们就讲完了？ No～，我们再看一下 overwritable() 方法内部： 1234567891011121314internal inline fun &lt;T : StateRecord, R&gt; T.overwritable( state: StateObject, candidate: T, block: T.() -&gt; R): R { var snapshot: Snapshot = snapshotInitializer return sync { snapshot = Snapshot.current // 这里讲完了 this.overwritableRecord(state, snapshot, candidate).block() }.also { notifyWrite(snapshot, state) // 但这里还有个 notifyWrite }} 还有一行我们遗漏了，notifyWrite() 又做了什么？ 123internal fun notifyWrite(snapshot: Snapshot, state: StateObject) { snapshot.writeObserver?.invoke(state)} 有种似曾相识的感觉，在前面分析 get() 函数的时候，我们看到过单参数的 readable() 里面有一行： 1snapshot.readObserver?.invoke(state) 那这里的作用呢？ ⇒ 寻找变量在哪里被读了，然后将这部分内容的组合标记为失效，等到下一帧的时候会重组刷新。 所以，整个 set() 方法就干了两件事： 将传入的值赋值给 StateRecord 内部的 value 写入通知刷新 到这里我们就基本上能够很清晰的明白了状态订阅&amp;自动刷新机制的原理了： 当 get() 被调用的时候，不仅返回值，还会记录读值的地方，也就是哪里调用了（相当于订阅）。 当 set() 被调用的时候，不仅修改值，还会查找读值的地方，然后进行刷新操作（相当于通知）。 📓 by 在实际开发中，如果每次获取值都要加上 value 会显得很冗余，所以 Compose 给我们提供了一种更方便的写法：by。它是 Kotlin 的一个关键字，表示左边的变量用右边的对象作为代理（委托）。 12345678910111213class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val name by mutableStateOf(&quot;Compose&quot;) setContent { ComposeBlogTheme { Text(name) // 可以直接 name，而不需要 name.value } } }} 如果你这么写，IDLE 会提示报错，因为 name 委托给了 mutableStateOf，如果我们要获取 name 的值，那委托对象需要调用 getValue() 和 setValue() 两个函数，这两个函数需要自己实现。 但实际上并不需要我们实现，你通过提示也可以看出来，我们可以直接导入，因为 Compose 内部已经帮我们实现好了这个方法。 12import androidx.compose.runtime.getValueimport androidx.compose.runtime.setValue 自此，关于 Compose 的状态订阅&amp;自动刷新机制的原理算是讲明白了吧…","link":"/2024/07/05/compose/Compose%20--%20%E7%8A%B6%E6%80%81%E8%AE%A2%E9%98%85%20&%20%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%20--%2001.%20%E8%A7%A3%E6%9E%90%20mutableStateOf%20%E6%BA%90%E7%A0%81/"},{"title":"Jetpack「保姆教程」-- ROOM","text":"","link":"/2025/05/20/jetpack/Jetpack%20%E4%BF%9D%E5%A7%86%E6%95%99%E7%A8%8B%20--%20ROOM/"},{"title":"这是一篇通俗易懂的「协程」入门指南","text":"","link":"/2025/06/20/kotlin/Kotlin%20--%20%E5%8D%8F%E7%A8%8B%20--%2001.%20%E5%8D%8F%E7%A8%8B%E5%85%A5%E9%97%A8/"},{"title":"Settings「源码解析系列」-- 单&#x2F;双栏原理","text":"基于 Google Git: android-14.0.0_r75 版本 Source Codes: git clone https://android.googlesource.com/platform/packages/apps/Settings Android 12L 之后系统对大屏设备显示进行了优化，比如 Settings 从原来的 单列 变成 双列 显示，依靠的是「Activity 嵌入」原理。 在 Settings 中决定是否嵌入式显示在 SettingsHomepageActivity 的 onCreate 方法中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125public class SettingsHomepageActivity extends FragmentActivity implements CategoryMixin.CategoryHandler { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Ensure device is provisioned in order to access Settings home // TODO(b/331254029): This should later be replaced in favor of an allowlist // 用于确保设备已经完成首次启动初始化流程，后续可能会以 allowlist 白名单方式替代 // 检查系统数据库中的 DEVICE_PROVISIONED 字段是否为 0 // • 0 表示设备尚未初始化完成（首次启动流程未完成） // • 这通常用于防止用户绕过 SetupWizard 提前进入设置页 boolean unprovisioned = android.provider.Settings.Global.getInt(getContentResolver(), android.provider.Settings.Global.DEVICE_PROVISIONED, 0) == 0; if (unprovisioned) { Log.e(TAG, &quot;Device is not provisioned, exiting Settings&quot;); // 如果设备未初始化，打印日志并立即关闭当前 Activity，防止进入设置主界面 finish(); } // 判断是否启用双栏嵌套显示能力，背后逻辑是看系统是否支持 WindowEmbedding 组件 mIsEmbeddingActivityEnabled = ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this); // 如果支持嵌套布局，就进一步判断当前用户是否是：管理型配置文件（Managed Profile），即企业/公司 Profile if (mIsEmbeddingActivityEnabled) { final UserManager um = getSystemService(UserManager.class); final UserInfo userInfo = um.getUserInfo(getUserId()); // 如果是 ManagedProfile 用户 if (userInfo.isManagedProfile()) { final Intent intent = new Intent(getIntent()) .addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT) .putExtra(EXTRA_USER_HANDLE, getUser()) .putExtra(EXTRA_INITIAL_REFERRER, getCurrentReferrer()); if (TextUtils.equals(intent.getAction(), ACTION_SETTINGS_EMBED_DEEP_LINK_ACTIVITY) &amp;&amp; this instanceof DeepLinkHomepageActivity) { intent.setClass(this, DeepLinkHomepageActivityInternal.class); } intent.removeFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivityAsUser(intent, um.getProfileParent(userInfo.id).getUserHandle()); finish(); return; } } // 启用沉浸式状态栏/导航栏布局 setupEdgeToEdge(); // 设置 UI 布局，这是双栏主界面的根布局，其中包含左栏、右栏容器等 setContentView(R.layout.settings_homepage_container); // 判断当前是否已经处于嵌套（双栏）模式 mIsTwoPane = ActivityEmbeddingUtils.isAlreadyEmbedded(this); // 更新顶部 AppBar 的最小高度，保证沉浸模式下显示合理 updateAppBarMinHeight(); initHomepageContainer(); // 初始化页面容器 updateHomepageAppBar(); // 始化AppBar 样式 updateHomepageBackground(); // 始化背景色 mLoadedListeners = new ArraySet&lt;&gt;(); // 初始化监听器集合，后续可能在子 fragment 中用于通知加载完成 initSearchBarView(); // 初始化搜索框 // 注册生命周期观察者 HideNonSystemOverlayMixin，用于防止浮窗（如恶意悬浮窗）干扰 // Android 13+ 中常用于安全防护 getLifecycle().addObserver(new HideNonSystemOverlayMixin(this)); // 初始化并注册分类处理器 CategoryMixin，用于支持主界面分类和搜索索引 mCategoryMixin = new CategoryMixin(this); getLifecycle().addObserver(mCategoryMixin); // 获取当前需要高亮的菜单 key（比如通过 intent 参数传入，或上一次操作记忆） final String highlightMenuKey = getHighlightMenuKey(); // Only allow features on high ram devices. // 判断当前是否是低内存设备（low-RAM） if (!getSystemService(ActivityManager.class).isLowRamDevice()) { // 初始化用户头像 initAvatarView(); // 判断是否需要滚动到高亮菜单项（仅在双栏 + 非默认 key 的情况下启用） final boolean scrollNeeded = mIsEmbeddingActivityEnabled &amp;&amp; !TextUtils.equals(getString(DEFAULT_HIGHLIGHT_MENU_KEY), highlightMenuKey); // 显示 SuggestionFragment（Google 提示页模块） showSuggestionFragment(scrollNeeded); // 如果启用了 CONTEXTUAL_HOME 特性，则展示上下文推荐卡片（比如夜间模式推荐、音量调节等） // 同时启用动画支持 if (FeatureFlagUtils.isEnabled(this, FeatureFlags.CONTEXTUAL_HOME)) { showFragment(() -&gt; new ContextualCardsFragment(), R.id.contextual_cards_content); ((FrameLayout) findViewById(R.id.main_content)) .getLayoutTransition().enableTransitionType(LayoutTransition.CHANGING); } } // 创建主 Fragment（左栏），是 TopLevelSettings 实例 // 将高亮菜单 key 作为参数传入，加载到 main_content 容器（即左栏） mMainFragment = showFragment(() -&gt; { final TopLevelSettings fragment = new TopLevelSettings(); fragment.getArguments().putString(SettingsActivity.EXTRA_FRAGMENT_ARG_KEY, highlightMenuKey); return fragment; }, R.id.main_content); // Launch the intent from deep link for large screen devices. // 如果是 DeepLink 跳转，并且处于大屏，则把右栏也自动跳转显示目标页面 if (shouldLaunchDeepLinkIntentToRight()) { launchDeepLinkIntentToRight(); } // Settings app may be launched on an existing task. Reset SplitPairRule of SubSettings here // to prevent SplitPairRule of an existing task applied on a new started Settings app. // 如果支持双栏，且通过 FLAG_ACTIVITY_CLEAR_TOP 启动（重进首页），则重新初始化嵌套规则 // 防止之前的页面对新 Task 有影响 if (mIsEmbeddingActivityEnabled &amp;&amp; (getIntent().getFlags() &amp; Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0) { initSplitPairRules(); } updateHomepagePaddings(); // 更新界面 padding，适配是否是双栏 updateSplitLayout(); // 同时刷新布局，强制计算一次分屏区域 // 启用 Task 层级的多语言支持（从 Android 13 起支持） // 允许每个任务独立语言（比如一个任务是英文，另一个是中文） enableTaskLocaleOverride(); } } 所以我们可以梳理下 onCreate 方法的关键逻辑： 模块 作用 前置校验 检查设备是否已初始化、是否是企业 Profile 嵌套判断 是否支持双栏嵌套、是否已嵌套 页面初始化 设置布局、加载左栏、右栏内容、SuggestionFragment deepLink 跳转 根据 intent 自动拉起右栏页面 Split 规则初始化 清空旧规则，注册嵌套分屏规则 双栏适配 padding、背景、AppBar、语言等多维度适配 ActivityEmbeddingUtils分栏的核心代码逻辑为： 12// 判断是否启用双栏嵌套显示能力，背后逻辑是看系统是否支持 WindowEmbedding 组件mIsEmbeddingActivityEnabled = ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this); 追踪下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class ActivityEmbeddingUtils { /** * Checks whether to support embedding activity feature with following conditions: * &lt;ul&gt; * &lt;li&gt;Whether {@link #isSettingsSplitEnabled(Context)}&lt;/li&gt; * &lt;li&gt;Whether {@link FeatureFlagUtils#SETTINGS_SUPPORT_LARGE_SCREEN} is enabled&lt;/li&gt; * &lt;li&gt;Whether User setup is completed&lt;/li&gt; * &lt;/ul&gt; * * 注释解释得很清楚了：双栏功能生效的前提条件有 3 个： * 1. isSettingsSplitEnabled(context) 为 true，表示系统支持嵌套组件 * 2. FeatureFlagUtils 中设置的开关（SETTINGS_SUPPORT_LARGE_SCREEN）是打开的 * 3. 用户已经完成首次设备初始化 */ public static boolean isEmbeddingActivityEnabled(Context context) { // Activity Embedding feature is not enabled if Settings doesn't enable large screen // optimization or the device is not supported. // 判断是否启用了分屏支持，如果系统压根不支持大屏适配，这里直接返回 false if (!isSettingsSplitEnabled(context)) { Log.d(TAG, &quot;isSettingsSplitSupported = false&quot;); return false; } // Activity Embedding feature is not enabled if a user chooses to disable the feature. // 判断 FeatureFlagUtils 中控制大屏适配的开关是否打开 // 这是 Google 为了动态控制新特性而设计的 flag 系统 if (!FeatureFlagUtils.isEnabled(context, FeatureFlagUtils.SETTINGS_SUPPORT_LARGE_SCREEN)) { Log.d(TAG, &quot;isFlagEnabled = false&quot;); return false; } // Don't enable Activity embedding for setup wizard. // 判断用户是否已经完成 Setup Wizard // 如果是首次启动、尚未完成初始引导流程，不允许进入嵌套显示（避免干扰引导界面） if (!WizardManagerHelper.isUserSetupComplete(context)) { Log.d(TAG, &quot;isUserSetupComplete = false&quot;); return false; } // 满足以上 3 个条件后，才真正启用嵌套 Activity 功能 Log.d(TAG, &quot;isEmbeddingActivityEnabled = true&quot;); return true; }} 总结：双栏功能是否启用，受以下 3 个条件共同控制： 条件 方法/开关 说明 系统是否支持嵌套 isSettingsSplitEnabled() 底层支持（如 SplitController 可用） 项目是否开启支持 FeatureFlagUtils.SETTINGS_SUPPORT_LARGE_SCREEN 项目级特性开关 用户是否完成引导 WizardManagerHelper.isUserSetupComplete() 防止进入未初始化设备的双栏界面 isSettingsSplitEnabled()123456789101112131415public class ActivityEmbeddingUtils { /** * Returns {@code true} to indicate that Settings app support the Activity Embedding feature on * this device. Returns {@code false}, otherwise. * * 这个方法是判断当前设备是否支持 Settings 的嵌套（Activity Embedding）功能 */ public static boolean isSettingsSplitEnabled(Context context) { return SHOULD_ENABLE_LARGE_SCREEN_OPTIMIZATION &amp;&amp; SplitController.getInstance(context).getSplitSupportStatus() == SplitController.SplitSupportStatus.SPLIT_AVAILABLE; }} SHOULD_ENABLE_LARGE_SCREEN_OPTIMIZATION 是一个静态布尔常量，在 ActivityEmbeddingUtils 类中被定义： 12private static final boolean SHOULD_ENABLE_LARGE_SCREEN_OPTIMIZATION = SystemProperties.getBoolean(&quot;persist.settings.large_screen_opt.enabled&quot;, false);","link":"/2025/06/26/settings/Settings%20--%20%E5%8F%8C%E6%A0%8F%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"状态订阅 &amp; 自动更新","slug":"状态订阅-自动更新","link":"/tags/%E7%8A%B6%E6%80%81%E8%AE%A2%E9%98%85-%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0/"},{"name":"协程","slug":"协程","link":"/tags/%E5%8D%8F%E7%A8%8B/"},{"name":"源码解析","slug":"源码解析","link":"/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"}],"categories":[{"name":"Compose","slug":"Compose","link":"/categories/Compose/"},{"name":"Kotlin","slug":"Kotlin","link":"/categories/Kotlin/"},{"name":"状态订阅 &amp; 自动更新","slug":"Compose/状态订阅-自动更新","link":"/categories/Compose/%E7%8A%B6%E6%80%81%E8%AE%A2%E9%98%85-%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0/"},{"name":"协程","slug":"Kotlin/协程","link":"/categories/Kotlin/%E5%8D%8F%E7%A8%8B/"},{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"Settings","slug":"Android/Settings","link":"/categories/Android/Settings/"}],"pages":[]}