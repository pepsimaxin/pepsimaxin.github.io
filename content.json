{"posts":[{"title":"LoaderTask 的数据加载奥秘 -- 初探","text":"核心类 路径 Launcher.java package/app/Launcher3/src/com/android/launcher3/Launcher.java LoaderTask package/app/Launcher3/src/com/android/launcher3/model/LoaderTask.java LauncherSettings.java package/app/Launcher3/src/com/android/launcher3/LauncherSettings.java LauncherProvider.java package/app/Launcher3/src/com/android/launcher3/LauncherProvider.java ModelDbController.java package/app/Launcher3/src/com/android/launcher3/model/ModelDbController.java InvariantDeviceProfile.java package/app/Launcher3/src/com/android/launcher3/InvariantDeviceProfile.java LauncherAppState.java package/app/Launcher3/src/com/android/launcher3/LauncherAppState.java Launcher.oncreate()Launcher 被 AMS 拉起后，就进入了自己的生命流程，Launcher.java 中的 onCreate() 函数会被调用，准备开始加载桌面。 12345678910111213141516171819202122232425📄 源码路径：package/app/Launcher3/src/com/android/launcher3/Launcher.javapublic class Launcher extends StatefulActivity&lt;LauncherState&gt; implements LauncherExterns, Callbacks, InvariantDeviceProfile.OnIDPChangeListener, PluginListener&lt;LauncherOverlayPlugin&gt; { private LauncherModel mModel; protected void onCreate(Bundle savedInstanceState) { ... LauncherAppState app = LauncherAppState.getInstance(this); mModel = app.getModel(); // 执行 LauncherModel 的 addCallbacksAndLoad() 方法 if (!mModel.addCallbacksAndLoad(this)) { if (!internalStateHandled) { mOnInitialBindListener = Boolean.FALSE::booleanValue; } } ... } } 我们来看看 addCallbacksAndLoad() 在 LauncherModel.java 中实现。 12345678910111213📄 源码路径：package/app/Launcher3/src/com/android/launcher3/LauncherModel.javapublic class LauncherModel extends LauncherApps.Callback implements InstallSessionTracker.Callback { public boolean addCallbacksAndLoad(@NonNull final Callbacks callbacks) { synchronized (mLock) { addCallbacks(callbacks); // 调用 startLoader() 方法 return startLoader(new Callbacks[] { callbacks }); } }} 调用了 startLoader() 方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445📄 源码路径：package/app/Launcher3/src/com/android/launcher3/LauncherModel.javapublic class LauncherModel extends LauncherApps.Callback implements InstallSessionTracker.Callback { private boolean startLoader(@NonNull final Callbacks[] newCallbacks) { // Enable queue before starting loader. It will get disabled in Launcher#finishBindingItems ItemInstallQueue.INSTANCE.get(mApp.getContext()) .pauseModelPush(ItemInstallQueue.FLAG_LOADER_RUNNING); synchronized (mLock) { ... if (callbacksList.length &gt; 0) { # Clear any pending bind-runnables from the synchronized load process. for (Callbacks cb : callbacksList) { MAIN_EXECUTOR.execute(cb::clearPendingBinds); } LauncherBinder launcherBinder = new LauncherBinder( mApp, mBgDataModel, mBgAllAppsList, callbacksList); // 非首次启动，Launcher 直接从数据库中同步加载 if (bindDirectly) { launcherBinder.bindWorkspace(bindAllCallbacks, /* isBindSync= */ true); launcherBinder.bindAllApps(); launcherBinder.bindDeepShortcuts(); launcherBinder.bindWidgets(); launcherBinder.updateIconTheme(); if (FeatureFlags.CHANGE_MODEL_DELEGATE_LOADING_ORDER.get()) { mModelDelegate.bindAllModelExtras(callbacksList); } return true; } else { stopLoader(); // 首次启动走这里 mLoaderTask = new LoaderTask( mApp, mBgAllAppsList, mBgDataModel, mModelDelegate, launcherBinder); MODEL_EXECUTOR.post(mLoaderTask); } } } return false; }} 在 startLoader() 方法中会创建 LauncherBinder 对象。如果是首次启动情况下，会创建 LoaderTask 对象，然后会执行 LoaderTask.run() 方法，利用之前创建的 LauncherBinder 开始加载桌面。 LoaderTask.run()查看 run() 方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155📄 源码路径：package/app/Launcher3/src/com/android/launcher3/model/LoaderTask.java/** * Runnable for the thread that loads the contents of the launcher: * - workspace icons * - widgets * - all apps icons * - deep shortcuts within apps */public class LoaderTask implements Runnable { public void run() { synchronized (this) { // 如果已经停止，则快速跳过 if (mStopped) { return; } } Object traceToken = TraceHelper.INSTANCE.beginSection(TAG); LoaderMemoryLogger memoryLogger = new LoaderMemoryLogger(); // 这里与 LauncherModel.LoaderTransaction 关联上 try (LauncherModel.LoaderTransaction transaction = mApp.getModel().beginLoader(this)) { List&lt;ShortcutInfo&gt; allShortcuts = new ArrayList&lt;&gt;(); --------------------------------------------------------------------------- // 第 1 步：加载工作区 loadWorkspace(allShortcuts, &quot;&quot;, memoryLogger); // 根据从数据库加载的工作空间，清理数据重新同步小部件快捷方式 if (mApp.getInvariantDeviceProfile().dbFile.equals(mDbName)) { verifyNotStopped(); sanitizeFolders(mItemsDeleted); sanitizeWidgetsShortcutsAndPackages(); logASplit(&quot;sanitizeData&quot;); } verifyNotStopped(); // 绑定 Workspace 数据（绑定图标之类的数据，桌面及其上内容开始呈现） mLauncherBinder.bindWorkspace(true /* incrementBindId */, /* isBindSync= */ false); logASplit(&quot;bindWorkspace&quot;); mModelDelegate.workspaceLoadComplete(); // 发送首屏广播（开机后默认显示的第一个 Screen，如果图标多的话， // 会被分成多个 Screen，通过左右滑动显示其他的） sendFirstScreenActiveInstallsBroadcast(); logASplit(&quot;sendFirstScreenActiveInstallsBroadcast&quot;); // 等待桌面 (workspace) 加载完成再加载抽屉 (Allapps) waitForIdle(); logASplit(&quot;step 1 complete&quot;); verifyNotStopped(); --------------------------------------------------------------------------- // 第 2 步：加载全部应用 Trace.beginSection(&quot;LoadAllApps&quot;); List&lt;LauncherActivityInfo&gt; allActivityList; try { allActivityList = loadAllApps(); } finally { Trace.endSection(); } logASplit(&quot;loadAllApps&quot;); if (FeatureFlags.CHANGE_MODEL_DELEGATE_LOADING_ORDER.get()) { mModelDelegate.loadAndBindAllAppsItems(mUserManagerState, mLauncherBinder.mCallbacksList, mShortcutKeyToPinnedShortcuts); logASplit(&quot;allAppsDelegateItems&quot;); } verifyNotStopped(); // 绑定 All Apps mLauncherBinder.bindAllApps(); logASplit(&quot;bindAllApps&quot;); verifyNotStopped(); IconCacheUpdateHandler updateHandler = mIconCache.getUpdateHandler(); setIgnorePackages(updateHandler); updateHandler.updateIcons(allActivityList, LauncherActivityCachingLogic.newInstance(mApp.getContext()), mApp.getModel()::onPackageIconsUpdated); logASplit(&quot;update icon cache&quot;); verifyNotStopped(); logASplit(&quot;save shortcuts in icon cache&quot;); updateHandler.updateIcons(allShortcuts, new ShortcutCachingLogic(), mApp.getModel()::onPackageIconsUpdated); // 等待上一操作加载完成，再进行加载应用程序快捷方式 waitForIdle(); logASplit(&quot;step 2 complete&quot;); verifyNotStopped(); --------------------------------------------------------------------------- // 第 3 步：加载应用程序快捷方式 List&lt;ShortcutInfo&gt; allDeepShortcuts = loadDeepShortcuts(); logASplit(&quot;loadDeepShortcuts&quot;); verifyNotStopped(); // 数据同步绑定应用程序快捷方式 mLauncherBinder.bindDeepShortcuts(); logASplit(&quot;bindDeepShortcuts&quot;); verifyNotStopped(); logASplit(&quot;save deep shortcuts in icon cache&quot;); // 缓存对应图标 updateHandler.updateIcons(allDeepShortcuts, new ShortcutCachingLogic(), (pkgs, user) -&gt; { }); // 等待上一步操作完成，再进行加载小部件等 waitForIdle(); logASplit(&quot;step 3 complete&quot;); verifyNotStopped(); --------------------------------------------------------------------------- // 第 4 步：加载桌面小部件 List&lt;ComponentWithLabelAndIcon&gt; allWidgetsList = mBgDataModel.widgetsModel.update(mApp, null); logASplit(&quot;load widgets&quot;); verifyNotStopped(); // 绑定 Widgets mLauncherBinder.bindWidgets(); logASplit(&quot;bindWidgets&quot;); verifyNotStopped(); if (FeatureFlags.CHANGE_MODEL_DELEGATE_LOADING_ORDER.get()) { mModelDelegate.loadAndBindOtherItems(mLauncherBinder.mCallbacksList); logASplit(&quot;otherDelegateItems&quot;); verifyNotStopped(); } // 将小部件进行缓存 updateHandler.updateIcons(allWidgetsList, new ComponentWithIconCachingLogic(mApp.getContext(), true), mApp.getModel()::onWidgetLabelsUpdated); logASplit(&quot;save widgets in icon cache&quot;); --------------------------------------------------------------------------- // 第 5 步：加载文件夹名称 loadFolderNames(); verifyNotStopped(); updateHandler.finish(); logASplit(&quot;finish icon update&quot;); mModelDelegate.modelLoadComplete(); // 提交完成 transaction.commit(); memoryLogger.clearLogs(); } catch (CancellationException e) { // Loader stopped, ignore logASplit(&quot;Cancelled&quot;); } catch (Exception e) { memoryLogger.printLogs(); throw e; } TraceHelper.INSTANCE.endSection(traceToken); }} 所以我们可以很清晰的发现 LoaderTask 做了以下五件事： Step 1: Workspace：加载工作区+ 绑定 Workspace step 1.1: loading workspace step 1.2: bind workspace step 1.3: send first screen broadcast step 1 completed, wait for idle Step 2: AllApps：加载全部应用 + 绑定全部应用 step 2.1: loading all apps step 2.2: bind all apps step 2.3: update icon cache step 2 completed, wait for idle Step 3: DeepShortcuts：加载应用程序快捷方式 + 绑定应用程序快捷方式 step 3.1: loading deep shortcuts step 3.2: bind deep shortcuts step 3 completed, wait for idle Step 4: Widgets：加载桌面小部件 + 绑定桌面小部件 step 4.1: loading widgets step 4.2: bind widgets step 4.3: Update icon cache Step 5: FolderNames：加载文件夹名称 step 5: loading folder names 接下来我们会深入源码，深度解读 LoaderTask 的每一步工作！","link":"/2024/10/23/Android%20--%20Launcher3%20--%2001.%20%E6%8F%AD%E5%BC%80%20LoaderTask%20%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E5%A5%A5%E7%A7%98%EF%BC%88%E5%88%9D%E6%8E%A2%EF%BC%89/"},{"title":"揭开 LoaderTask 的数据加载奥秘 -- Folder","text":"Step5: FolderNames 加载文件夹名称 加载文件夹名称核心方法：loadFolderNames() 负责加载文件夹名称： 12345678910111213141516171819202122232425262728📄 源码路径：package/app/Launcher3/src/com/android/launcher3/model/LoaderTask.javapublic class LoaderTask implements Runnable { private void loadFolderNames() { // 创建一个新的 FolderNameProvider 实例 // 这个提供者类用于生成文件夹名称，通常基于文件夹内的应用来生成合适的名称。 FolderNameProvider provider = FolderNameProvider.newInstance(mApp.getContext(), mBgAllAppsList.data, mBgDataModel.folders); // 同步加载文件夹名称 synchronized (mBgDataModel) { // 遍历文件夹数据列表 for (int i = 0; i &lt; mBgDataModel.folders.size(); i++) { FolderNameInfos suggestionInfos = new FolderNameInfos(); // 获取文件夹的 FolderInfo 对象，该对象包含了文件夹的内容及相关信息 FolderInfo info = mBgDataModel.folders.valueAt(i); // 生成名称建议 if (info.suggestedFolderNames == null) { provider.getSuggestedFolderName(mApp.getContext(), info.contents, suggestionInfos); info.suggestedFolderNames = suggestionInfos; } } } }}","link":"/2024/11/23/Android%20--%20Launcher3%20--%2006.%20%E6%8F%AD%E5%BC%80%20LoaderTask%20%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E5%A5%A5%E7%A7%98%20--%20folder/"},{"title":"Android 14.0 Launcher -- Folder 解析","text":"先主观感受下原生 AOSP 默认的 Folder 效果： 加载文件夹12345678910111213141516171819202122📄 源码路径：packages/app/Launcher3/src/com/android/launcher3/model/LoaderTask.javapublic class LoaderTask implements Runnable { private void loadFolderNames() { FolderNameProvider provider = FolderNameProvider.newInstance(mApp.getContext(), mBgAllAppsList.data, mBgDataModel.folders); synchronized (mBgDataModel) { for (int i = 0; i &lt; mBgDataModel.folders.size(); i++) { FolderNameInfos suggestionInfos = new FolderNameInfos(); FolderInfo info = mBgDataModel.folders.valueAt(i); if (info.suggestedFolderNames == null) { provider.getSuggestedFolderName(mApp.getContext(), info.contents, suggestionInfos); info.suggestedFolderNames = suggestionInfos; } } } }} FolderIconFolderIcon.java 是 Launcher3 桌面绘制文件夹图标的一个关键的类。 init()1234567891011121314151617181920212223242526272829📄 源码路径：packages/app/Launcher3/src/com/android/launcher3/folder/FolderIcon.javapublic class FolderIcon extends FrameLayout implements FolderListener, IconLabelDotView, DraggableView, Reorderable { ClippedFolderIconLayoutRule mPreviewLayoutRule; private PreviewItemManager mPreviewItemManager; public FolderIcon(Context context, AttributeSet attrs) { super(context, attrs); // 调用 init() 方法初始化 init(); } public FolderIcon(Context context) { super(context); init(); } private void init() { mLongPressHelper = new CheckLongPressHelper(this); // 创建 ClippedFolderIconLayoutRule 对象，记住这个 mPreviewLayoutRule ！ mPreviewLayoutRule = new ClippedFolderIconLayoutRule(); // 创建 PreviewItemManager 对象 mPreviewItemManager = new PreviewItemManager(this); mDotParams = new DotRenderer.DrawParams(); }} dispatchDraw()123456789101112131415161718192021222324252627282930313233📄 源码路径：packages/app/Launcher3/src/com/android/launcher3/folder/FolderIcon.javapublic class FolderIcon extends FrameLayout implements FolderListener, IconLabelDotView, DraggableView, Reorderable { private PreviewItemManager mPreviewItemManager; @Override protected void dispatchDraw(Canvas canvas) { super.dispatchDraw(canvas); if (!mBackgroundIsVisible) return; // 核心 1: 重新计算图标的各项参数 mPreviewItemManager.recomputePreviewDrawingParams(); if (!mBackground.drawingDelegated()) { mBackground.drawBackground(canvas); } if (mCurrentPreviewItems.isEmpty() &amp;&amp; !mAnimating) return; // 核心 2: 绘制文件夹预览图 mPreviewItemManager.draw(canvas); if (!mBackground.drawingDelegated()) { mBackground.drawBackgroundStroke(canvas); } drawDot(canvas); }} PreviewItemManagerPreviewItemManager.java 类是用来管理 FolderIcon「文件夹预览图」中 PreviewItemDrawingParams「文件夹中应用预览项」– 「绘图」和「动画参数」的。 重新计算图标参数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100📄 源码路径：packages/app/Launcher3/src/com/android/launcher3/folder/PreviewItemManager.javapublic class PreviewItemManager { public void recomputePreviewDrawingParams() { if (mReferenceDrawable != null) { // 调用 computePreviewDrawingParams() 方法 computePreviewDrawingParams(mReferenceDrawable.getIntrinsicWidth(), mIcon.getMeasuredWidth()); } } private void computePreviewDrawingParams(int drawableSize, int totalSize) { if (mIntrinsicIconSize != drawableSize || mTotalWidth != totalSize || mPrevTopPadding != mIcon.getPaddingTop()) { mIntrinsicIconSize = drawableSize; mTotalWidth = totalSize; mPrevTopPadding = mIcon.getPaddingTop(); mIcon.mBackground.setup(mIcon.getContext(), mIcon.mActivity, mIcon, mTotalWidth, mIcon.getPaddingTop()); // 调用了 FolderIcon.mPreviewLayoutRule.init() 方法做一些初始化工作 mIcon.mPreviewLayoutRule.init(mIcon.mBackground.previewSize, mIntrinsicIconSize, Utilities.isRtl(mIcon.getResources())); // 调用 updatePreviewItems() 方法，注意参数传的是 false updatePreviewItems(false); } } void updatePreviewItems(boolean animate) { int numOfPrevItemsAux = mFirstPageParams.size(); // 调用 buildParamsForPage() 方法，注意：第 3 个参数是 false buildParamsForPage(0, mFirstPageParams, animate); mNumOfPrevItems = numOfPrevItemsAux; } void buildParamsForPage(int page, ArrayList&lt;PreviewItemDrawingParams&gt; params, boolean animate) { // 这个 items 是用来存储当前应用图标预览项列表的 List&lt;WorkspaceItemInfo&gt; items = mIcon.getPreviewItemsOnPage(page); // We adjust the size of the list to match the number of items in the preview. while (items.size() &lt; params.size()) { // 先移除 params 中的 items params.remove(params.size() - 1); } while (items.size() &gt; params.size()) { // 再一个个添加进去 params.add(new PreviewItemDrawingParams(0, 0, 0)); } int numItemsInFirstPagePreview = page == 0 ? items.size() : MAX_NUM_ITEMS_IN_PREVIEW; for (int i = 0; i &lt; params.size(); i++) { // 拿到单个 PreviewItemDrawingParams 对象，这里的 PreviewItemDrawingParams 就是单个应用图标预览项 PreviewItemDrawingParams p = params.get(i); setDrawable(p, items.get(i)); // 上面传递第三个参数 animate 为 false，所以会进入这个 if 判断 if (!animate) { if (p.anim != null) { p.anim.cancel(); } // 调用 computePreviewItemDrawingParams() 方法 computePreviewItemDrawingParams(i, numItemsInFirstPagePreview, p); if (mReferenceDrawable == null) { mReferenceDrawable = p.drawable; } } else { FolderPreviewItemAnim anim = new FolderPreviewItemAnim(this, p, i, mNumOfPrevItems, i, numItemsInFirstPagePreview, DROP_IN_ANIMATION_DURATION, null); if (p.anim != null) { if (p.anim.hasEqualFinalState(anim)) { // do nothing, let the current animation finish continue; } p.anim.cancel(); } p.anim = anim; p.anim.start(); } } } PreviewItemDrawingParams computePreviewItemDrawingParams(int index, int curNumItems, PreviewItemDrawingParams params) { // We use an index of -1 to represent an icon on the workspace for the destroy and // create animations // index 为文件夹中应用预览项的下标，一般来说 &gt;=0 if (index == -1) { return getFinalIconParams(params); } // 调用了 FolderIcon.mPreviewLayoutRule.computePreviewItemDrawingParams() 方法 return mIcon.mPreviewLayoutRule.computePreviewItemDrawingParams(index, curNumItems, params); } private final FolderIcon mIcon;} 还记得 FolderIcon.mPreviewLayoutRule 是什么吗？– ClippedFolderIconLayoutRule 对象！ 绘制文件夹预览图12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364```java📄 源码路径：packages/app/Launcher3/src/com/android/launcher3/folder/PreviewItemManager.javapublic class PreviewItemManager { public void draw(Canvas canvas) { int saveCount = canvas.getSaveCount(); // The items are drawn in coordinates relative to the preview offset PreviewBackground bg = mIcon.getFolderBackground(); Path clipPath = bg.getClipPath(); float firstPageItemsTransX = 0; if (mShouldSlideInFirstPage) { PointF firstPageOffset = new PointF(bg.basePreviewOffsetX + mCurrentPageItemsTransX, bg.basePreviewOffsetY); boolean shouldClip = mCurrentPageItemsTransX &gt; mClipThreshold; drawParams(canvas, mCurrentPageParams, firstPageOffset, shouldClip, clipPath); firstPageItemsTransX = -ITEM_SLIDE_IN_OUT_DISTANCE_PX + mCurrentPageItemsTransX; } PointF firstPageOffset = new PointF(bg.basePreviewOffsetX + firstPageItemsTransX, bg.basePreviewOffsetY); boolean shouldClipFirstPage = firstPageItemsTransX &lt; -mClipThreshold; // 调用 drawParams() 方法 drawParams(canvas, mFirstPageParams, firstPageOffset, shouldClipFirstPage, clipPath); canvas.restoreToCount(saveCount); } public void drawParams(Canvas canvas, ArrayList&lt;PreviewItemDrawingParams&gt; params, PointF offset, boolean shouldClipPath, Path clipPath) { // 这里传进来的 ArrayList&lt;PreviewItemDrawingParams&gt; params 就是每个文件夹中应用图标的 List // The first item should be drawn last (ie. on top of later items) for (int i = params.size() - 1; i &gt;= 0; i--) { PreviewItemDrawingParams p = params.get(i); if (!p.hidden) { // Exiting param should always be clipped. boolean isExiting = p.index == EXIT_INDEX; // 遍历文件夹中每个图标，进行绘制 drawPreviewItem(canvas, p, offset, isExiting | shouldClipPath, clipPath); } } } private void drawPreviewItem(Canvas canvas, PreviewItemDrawingParams params, PointF offset, boolean shouldClipPath, Path clipPath) { canvas.save(); if (shouldClipPath) { canvas.clipPath(clipPath); } canvas.translate(offset.x + params.transX, offset.y + params.transY); canvas.scale(params.scale, params.scale); Drawable d = params.drawable; if (d != null) { Rect bounds = d.getBounds(); canvas.save(); canvas.translate(-bounds.left, -bounds.top); canvas.scale(mIntrinsicIconSize / bounds.width(), mIntrinsicIconSize / bounds.height()); d.draw(canvas); canvas.restore(); } canvas.restore(); } } ClippedFolderIconLayoutRule 文件夹图标内部显示小图标缩略图的计算类，如果你要定制 Folder，让其缩略图显示为 9 宫格的样式，那么此类是关键！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166📄 源码路径：packages/app/Launcher3/src/com/android/launcher3/folder/ClippedFolderIconLayoutRule.javapublic class ClippedFolderIconLayoutRule { // 文件夹预览中的最大/最小显示图标数 public static final int MAX_NUM_ITEMS_IN_PREVIEW = 4; private static final int MIN_NUM_ITEMS_IN_PREVIEW = 2; // 缩放因子：当预览中的图标数量较多时使用 MIN_SCALE，较少时使用 MAX_SCALE private static final float MIN_SCALE = 0.44f; private static final float MAX_SCALE = 0.51f; // 最大半径膨胀比例 private static final float MAX_RADIUS_DILATION = 0.25f; // 重叠系数：允许图标部分重叠以优化视觉效果 public static final float ICON_OVERLAP_FACTOR = 1 + (MAX_RADIUS_DILATION / 2f); private static final float ITEM_RADIUS_SCALE_FACTOR = 1.15f; // 表示进入或退出文件夹时的图标索引，用于动画逻辑 public static final int EXIT_INDEX = -2; public static final int ENTER_INDEX = -3; // 临时数组，用于存储计算后的 x 和 y 坐标 private float[] mTmpPoint = new float[2]; private float mAvailableSpace; // 预览区域的可用空间 private float mRadius; // 布局中用于排列图标的圆形半径 private float mIconSize; // 图标大小 private boolean mIsRtl; // 标识布局是否为 RTL private float mBaselineIconScale; // 基准缩放因子 /** * 初始化文件夹图标布局的关键参数：空间大小、图标大小和布局方向（RTL） */ public void init(int availableSpace, float intrinsicIconSize, boolean rtl) { mAvailableSpace = availableSpace; mRadius = ITEM_RADIUS_SCALE_FACTOR * availableSpace / 2f; mIconSize = intrinsicIconSize; mIsRtl = rtl; mBaselineIconScale = availableSpace / (intrinsicIconSize * 1f); } /** * 计算预览中的图标绘制参数 */ public PreviewItemDrawingParams computePreviewItemDrawingParams(int index, int curNumItems, PreviewItemDrawingParams params) { float totalScale = scaleForItem(curNumItems); float transX; float transY; if (index == EXIT_INDEX) { // 0 1 * &lt;-- Exit position (row 0, col 2) // 2 3 getGridPosition(0, 2, mTmpPoint); } else if (index == ENTER_INDEX) { // 0 1 // 2 3 * &lt;-- Enter position (row 1, col 2) getGridPosition(1, 2, mTmpPoint); } else if (index &gt;= MAX_NUM_ITEMS_IN_PREVIEW) { // Items beyond those displayed in the preview are animated to the center mTmpPoint[0] = mTmpPoint[1] = mAvailableSpace / 2 - (mIconSize * totalScale) / 2; } else { getPosition(index, curNumItems, mTmpPoint); } transX = mTmpPoint[0]; transY = mTmpPoint[1]; if (params == null) { params = new PreviewItemDrawingParams(transX, transY, totalScale); } else { params.update(transX, transY, totalScale); } return params; } /** * Builds a grid based on the positioning of the items when there are * {@link #MAX_NUM_ITEMS_IN_PREVIEW} in the preview. * * Positions in the grid: 0 1 // 0 is row 0, col 1 * 2 3 // 3 is row 1, col 1 */ /** * 网格位置计算逻辑 */ private void getGridPosition(int row, int col, float[] result) { // 获取网格中左上角（0号位置）的坐标 getPosition(0, 4, result); float left = result[0]; float top = result[1]; // 获取网格中右下角（3号位置）的坐标 getPosition(3, 4, result); float dx = result[0] - left; float dy = result[1] - top; result[0] = left + (col * dx); result[1] = top + (row * dy); } /** * 计算具体位置 */ private void getPosition(int index, int curNumItems, float[] result) { // 确保当前显示的图标数量至少为 2 curNumItems = Math.max(curNumItems, 2); // We model the preview as a circle of items starting in the appropriate piece of the // upper left quadrant (to achieve horizontal and vertical symmetry). double theta0 = mIsRtl ? 0 : Math.PI; // In RTL we go counterclockwise int direction = mIsRtl ? 1 : -1; // 根据图标数量调整初始角度 double thetaShift = 0; if (curNumItems == 3) { thetaShift = Math.PI / 2; } else if (curNumItems == 4) { thetaShift = Math.PI / 4; } theta0 += direction * thetaShift; // We want the items to appear in reading order. For the case of 1, 2 and 3 items, this // is natural for the circular model. With 4 items, however, we need to swap the 3rd and // 4th indices to achieve reading order. if (curNumItems == 4 &amp;&amp; index == 3) { index = 2; } else if (curNumItems == 4 &amp;&amp; index == 2) { index = 3; } // We bump the radius up between 0 and MAX_RADIUS_DILATION % as the number of items increase float radius = mRadius * (1 + MAX_RADIUS_DILATION * (curNumItems - MIN_NUM_ITEMS_IN_PREVIEW) / (MAX_NUM_ITEMS_IN_PREVIEW - MIN_NUM_ITEMS_IN_PREVIEW)); double theta = theta0 + index * (2 * Math.PI / curNumItems) * direction; float halfIconSize = (mIconSize * scaleForItem(curNumItems)) / 2; // Map the location along the circle, and offset the coordinates to represent the center // of the icon, and to be based from the top / left of the preview area. The y component // is inverted to match the coordinate system. result[0] = mAvailableSpace / 2 + (float) (radius * Math.cos(theta) / 2) - halfIconSize; result[1] = mAvailableSpace / 2 + (float) (- radius * Math.sin(theta) / 2) - halfIconSize; } /** * 缩放因子计算 */ public float scaleForItem(int numItems) { // Scale is determined by the number of items in the preview. final float scale; if (numItems &lt;= 3) { scale = MAX_SCALE; } else { scale = MIN_SCALE; } return scale * mBaselineIconScale; } public float getIconSize() { return mIconSize; }} 计算图标位置：getPosition()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667private void getPosition(int index, int curNumItems, float[] result) { // 确保当前显示的图标数量至少为 2 curNumItems = Math.max(curNumItems, 2); /** * 确定初始角度，RTL 布局从 0 度开始，非 RTL 从 π（180 度）开始 * * 这里我们不考虑 RTL 的情况，所以后续分析默认以 0 度为初始角度 */ double theta0 = mIsRtl ? 0 : Math.PI; /** * 确定方向：RTL 顺时针，非 RTL 逆时针 * * 这里我们不考虑 RTL 的情况，所以后续默认为：逆时针方向 */ int direction = mIsRtl ? 1 : -1; /** * 根据子项数量调整角度偏移 * * 我们先以 curNumItems = 4 个图标为例 */ double thetaShift = 0; if (curNumItems == 3) { thetaShift = Math.PI / 2; // 90 度偏移 } else if (curNumItems == 4) { thetaShift = Math.PI / 4; // 45 度偏移 } /** * 初始角度：direction -&gt; -1 * index: 0 -&gt; theta0 = 135 度（2.356194490192345） * index: 1 -&gt; theta0 = 135 度（2.356194490192345） * index: 2 -&gt; theta0 = 135 度（2.356194490192345） * index: 3 -&gt; theta0 = 135 度（2.356194490192345） */ theta0 += direction * thetaShift; // 确保 4 个子项时，第 3 和第 4 项互换，保证阅读顺序 if (curNumItems == 4 &amp;&amp; index == 3) { index = 2; } else if (curNumItems == 4 &amp;&amp; index == 2) { index = 3; } // 根据子项数量增加半径，越多图标，半径越大，确保图标合理地分散开 // MAX_RADIUS_DILATION 控制了图标最大能膨胀的比例 float radius = mRadius * (1 + MAX_RADIUS_DILATION * (curNumItems - MIN_NUM_ITEMS_IN_PREVIEW) / (MAX_NUM_ITEMS_IN_PREVIEW - MIN_NUM_ITEMS_IN_PREVIEW)); /** * 计算当前子项的角度： * index: 0 -&gt; theta = PI*3/4 - 0 = PI*3/4 (2.356194490192345) * index: 1 -&gt; theta = PI*3/4 - PI*1/2 = PI/4 (0.7853981633974483) * index: 2 -&gt; theta = PI*3/4 - PI = -PI/4 (-0.7853981633974483) * index: 3 -&gt; theta = PI*3/4 - PI*3/2 = -PI*3/4 (-2.356194490192345) */ double theta = theta0 + index * (2 * Math.PI / curNumItems) * direction; // 计算图标大小的一半，用于调整位置到图标中心 float halfIconSize = (mIconSize * scaleForItem(curNumItems)) / 2; // 使用极坐标计算 x 和 y 坐标，并调整为从预览区域的中心开始 result[0] = mAvailableSpace / 2 + (float) (radius * Math.cos(theta) / 2) - halfIconSize; result[1] = mAvailableSpace / 2 + (float) (- radius * Math.sin(theta) / 2) - halfIconSize;} 总结下 getPosition() 方法的计算思路： 1. 在文件夹预览图标布局中，图标不是随机分布的，而是「围绕文件夹图标中心」均匀排列的。 实现方法就是：以中心点为圆心绘制一个圆，各个应用的图标中心都在圆上，且各个图标之间的距离(角度)相等即可； 2. 计算应用图标中心距离文件夹图标中心的半径 图标数量不同时，绘制的大小和区域也不一样，这里使用一个线性插值公式，根据当前预览图标数量(curNumItems)相对于预览图标的最小和最大数量(2 和 4)的比例，来调整半径 radius 的大小： 1234567891011121314private static final float ITEM_RADIUS_SCALE_FACTOR = 1.15f;mRadius = ITEM_RADIUS_SCALE_FACTOR * availableSpace / 2f;// 初始 mRadius:mRadius = 1.15 * availableSpace / 2f;// 根据预览图数量重新设定半径 radius:private static final float MAX_RADIUS_DILATION = 0.25f;float radius = mRadius * (1 + MAX_RADIUS_DILATION * (curNumItems - MIN_NUM_ITEMS_IN_PREVIEW) / (MAX_NUM_ITEMS_IN_PREVIEW - MIN_NUM_ITEMS_IN_PREVIEW));curNumItems = 2，radius = mRadiuscurNumItems = 3，radius = 1.125 * mRadiuscurNumItems = 4，radius = 1.25 * mRadius 3. 根据当前预览图标数量(curNumItems)将这个圆平均，并根据「极坐标系」计算每个应用图标中心点的「极坐标」 123456789101112131415161718192021222324252627// 计算每个应用的初始化角度double theta = theta0 + index * (2 * Math.PI / curNumItems) * direction;curNumItems = 2：两个应用在中心点的两侧，两个图标在同一水平线上 | | index: 0 -&gt; theta = PI -(0)-+-(1)- index: 1 -&gt; theta = 0 | |curNumItems = 3：三个图标按品字排列，第一个在顶部，顺时针排列 | (0) index: 0 -&gt; theta = PI/2 -----+----- index: 1 -&gt; theta = -PI/6 (2) | (1) index: 2 -&gt; theta = -PI*5/6； |curNumItems = 4：四个图标按 2x2 排列 | (0) | (1) index: 0 -&gt; theta = PI*3/4 -----+----- index: 1 -&gt; theta = PI/4 (2) | (3) index: 2 -&gt; index = 3 -&gt; theta = -PI/4 | index: 3 -&gt; index = 2 -&gt; theta = -PI*3/4 4. 计算应用图标左上角的 x、y 坐标 12result[0] = mAvailableSpace / 2 + (float) (radius * Math.cos(theta) / 2) - halfIconSize;result[1] = mAvailableSpace / 2 + (float) (-radius * Math.sin(theta) / 2) - halfIconSize; 我们来看下 4 个图标的位置确定过程： 第 1 个图标：index = 0 theta = PI*3/4 第 2 个图标：index = 1 theta = PI/4 这两张图已经完美诠释了位置获取的算法逻辑，index = 2 / index = 3 我就不再画图了，留给大家自己研究吧。 由上面的分析我们发现，影响位置计算结果的主要参数为： mAvailableSpace: 文件夹图标大小，我们一般不会对他做改动 mIconSize: 缩放系数 radius: 半径，影响应用图标离中心点的距离 theta: 角坐标 九宫格定制硬核改法如果你理解透彻了 getPosition() 方法的图标计算逻辑，那接下来我们看看如何自己分析处理 9 宫格的布局算法： 通用改法 既然需要支持 9 宫格布局，那首先最大支持图标数得修改为 9: 1public static final int MAX_NUM_ITEMS_IN_PREVIEW = 9; 意料之中的情况，我们必须重新定义 getPositon() 的算法： 123456789101112131415161718192021222324252627282930public PreviewItemDrawingParams computePreviewItemDrawingParams(int index, int curNumItems, PreviewItemDrawingParams params) { float totalScale = scaleForItem(curNumItems); float transX; float transY; if (index == EXIT_INDEX) { ... } else { // getPosition(index, curNumItems, mTmpPoint); // 固定九宫格的样式，我们无需 curNumItems 参数 get9Position(index, mTmpPoint); } ...}// 重新定义 getPosition() 算法private void get9Position(int index, float[] result) { int x = index % 3; // 第几列 int y = index / 3; // 第几行 float iconSize = mAvailableSpace / 3; if (mIsRtl) { result[0] = iconSize * (2 - x); } else { result[0] = iconSize * x; } result[1] = iconSize * y;} 图标太大了，我们调整下缩放因子： 12// private static final float MIN_SCALE = 0.44f;private static final float MIN_SCALE = 0.28f; 现在的图标位置是有问题的，因为我们之前的代码是强制图标占据空间为：mAvailableSpace/3，是需要进行调整的： 1234567891011121314private void get9Position(int index, float[] result) { int x = index % 3; int y = index / 3; // float iconSize = mAvailableSpace / 3; float iconSize = mAvailableSpace * MIN_SCALE; if (mIsRtl) { result[0] = iconSize * (2 - x); } else { result[0] = iconSize * x; } result[1] = iconSize * y;} 现在我们剩下最后一步，就是调整 9 宫格图，让图标彼此之间的间距平均： 1234567891011121314151617181920212223// 新定义预览图间距 private float mPreviewGap; public void init(int availableSpace, float intrinsicIconSize, boolean rtl) { ... // 总可用空间 - 3 个图标占用空间 = 剩余空间 // 将剩余空间平均分配成 4 段，因为有 3 个图标就有 4 个间隔 mPreviewGap = (mAvailableSpace - mAvailableSpace * MIN_SCALE * 3) / 4f; } private void get9Position(int index, float[] result) { int x = index % 3; int y = index / 3; float iconSize = mAvailableSpace * MIN_SCALE; if (mIsRtl) { result[0] = mPreviewGap + (iconSize + mPreviewGap) * (2 - x); } else { result[0] = mPreviewGap + (iconSize + mPreviewGap) * x; } result[1] = mPreviewGap + (iconSize + mPreviewGap) * y; } 参考https://blog.csdn.net/baidu_41666295/article/details/134936794","link":"/2024/11/29/Android%20--%20Launcher3%20--%2011.%20Folder%20%E4%B9%9D%E5%AE%AB%E6%A0%BC%E8%A7%A3%E6%9E%90/"},{"title":"揭开 LoaderTask 的数据加载奥秘 -- Workspace","text":"前言我们先大概了解本篇文章涉及到的几个重要的类： 核心类 路径 LauncherModel Launcher 数据处理核心类 LoaderTask 主要任务负责加载数据（workspace、all apps）和绑定数据（workspace、all apps） AutoInstallsLayout InvariantDeviceProfile 桌面的一些配置，比如默认布局文件 BgDataModel 用来放布局相关的集合 WorkspaceItemInfoFolderInfoLauncherAppWidgetInfo 都是继承自 ItemInfo，保存桌面图标的一些信息：图标位置，宽高，类型等信息 Step1: Workspace Workspace 的工作主要分为：「加载」和「绑定」，我们一个个来分析。 加载 Workspace 流程解析核心方法：loadWorkspace() 负责加载 Workspace，它主要做 2 件事情： 获取数据库 从数据库读取信息存放到 sBgDataModel 中 你先有个概念，然后我们开始分析源码，代码走起～ 12345678910111213141516171819202122232425262728293031323334353637383940414243📄 源码路径：package/app/Launcher3/src/com/android/launcher3/model/LoaderTask.javapublic class LoaderTask implements Runnable { /** * run() -&gt; loadWorkspace(allShortcuts, &quot;&quot;, memoryLogger); * * 1. allDeepShortcuts: 存储应用快捷方式的列表，默认是空的 * 2. selection: 可以指定选择条件，用于过滤，默认是没有传入任何条件的 * 3. memoryLogger: 是一个 LoaderMemoryLogger，是一个辅助记录器，用于捕获记录 * LoaderTask 的 run() 方法执行过程中可能产生的异常及内存使用情况 */ protected void loadWorkspace( List&lt;ShortcutInfo&gt; allDeepShortcuts, String selection, LoaderMemoryLogger memoryLogger) { // 开始性能追踪，用于性能调试和监控 Trace.beginSection(&quot;LoadWorkspace&quot;); try { /*********************************** * 核心方法：负责加载工作区内容的主要逻辑 ***********************************/ loadWorkspaceImpl(allDeepShortcuts, selection, memoryLogger); } finally { // 结束性能跟踪 Trace.endSection(); } // 记录工作区加载过程的日志，用于性能分析或调试 logASplit(&quot;loadWorkspace&quot;); if (FeatureFlags.CHANGE_MODEL_DELEGATE_LOADING_ORDER.get()) { // 确保 Loader 加载过程没有被中止 verifyNotStopped(); // 使用 ModelDelegate 加载并绑定工作区项（Workspace Items） mModelDelegate.loadAndBindWorkspaceItems(mUserManagerState, mLauncherBinder.mCallbacksList, mShortcutKeyToPinnedShortcuts); // 标记 ModelDelegate 为活动状态，表示它已成功加载并绑定工作区项。 mModelDelegate.markActive(); logASplit(&quot;workspaceDelegateItems&quot;); } }} 我们继续跟踪 loadWorkspaceImpl() 方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071📄 源码路径：package/app/Launcher3/src/com/android/launcher3/model/LoaderTask.javapublic class LoaderTask implements Runnable { protected final LauncherAppState mApp; /** * run() -&gt; loadWorkspace(allShortcuts, &quot;&quot;, memoryLogger); * -&gt; loadWorkspaceImpl(allDeepShortcuts, selection, memoryLogger); * * 1. allDeepShortcuts: 存储应用快捷方式的列表，默认是空的 * 2. selection: 可以指定选择条件，用于过滤，默认是没有传入任何条件的 * 3. memoryLogger: 是一个 LoaderMemoryLogger，是一个辅助记录器，用于捕获记录 * LoaderTask 的 run() 方法执行过程中可能产生的异常及内存使用情况 */ private void loadWorkspaceImpl( List&lt;ShortcutInfo&gt; allDeepShortcuts, String selection, @Nullable LoaderMemoryLogger memoryLogger) { // mApp 就是：LauncherAppState，它会持有应用的 Context 对象，使得应用的各个部分 // 能够访问全局的 Context，从而进行资源访问、启动服务、广播等操作 final Context context = mApp.getContext(); // 后续用于查询、插入、删除或更新数据 final ContentResolver contentResolver = context.getContentResolver(); // 自定义的包管理的辅助类 final PackageManagerHelper pmHelper = new PackageManagerHelper(context); // 检查设备是否处于安全模式 final boolean isSafeMode = pmHelper.isSafeMode(); // 检查设备的启动是否已完成，通常这意味着 SD 卡已经挂载并可以访问 final boolean isSdCardReady = Utilities.isBootCompleted(); // 用于管理桌面小部件的帮助类 final WidgetManagerHelper widgetHelper = new WidgetManagerHelper(context); // 设定了一个清除数据库的标志位 boolean clearDb = false; /** 检查是否需要进行数据库迁移。如果迁移失败，则清理整个数据库，这通常发生在数据模型发生较大变更时 * * mApp.getModel() -&gt; LauncherModel * mApp.getModel().getModelDbController() -&gt; ModelDbController * * 一般是无需迁移的，这边默认为 true，所以不会走此分支，clearDb 仍为 false */ if (!mApp.getModel().getModelDbController().migrateGridIfNeeded()) { // Migration failed. Clear workspace. // 迁移失败 clearDb = true; } // 重置数据库 if (clearDb) { Log.d(TAG, &quot;loadWorkspace: resetting launcher database&quot;); Settings.call(contentResolver, Settings.METHOD_CREATE_EMPTY_DB); } Log.d(TAG, &quot;loadWorkspace: loading default favorites&quot;); /********************************************************************* * 核心关注点 1：加载默认桌面布局 * * 会调用到 LauncherProvider 的 loadDefaultFavoritesIfNecessary() 方法， * 这个方法来判断是否需要加载默认的布局，如果清除了桌面数据 * 或者手机恢复了出厂设置，就会加载默认的布局 ********************************************************************/ Settings.call(contentResolver, Settings.METHOD_LOAD_DEFAULT_FAVORITES); // 加载数据库（我们放在后面分析） ... } } 加载默认桌面布局Settings.call() 是 LauncherSettings 内部的静态方法： 1234567891011121314151617181920212223📄 源码路径：package/app/Launcher3/src/com/android/launcher3/LauncherSettings.javapublic class LauncherSettings { /** * Launcher settings */ public static final class Settings { // CONTENT_URI 是一个 Uri 对象，表示内容提供者的 URI 地址，这是与 LauncherProvider 交互的入口点 public static final Uri CONTENT_URI = Uri.parse(&quot;content://&quot; + LauncherProvider.AUTHORITY + &quot;/settings&quot;); public static final String METHOD_LOAD_DEFAULT_FAVORITES = &quot;load_default_favorites&quot;; public static Bundle call(ContentResolver cr, String method) { return call(cr, method, null /* arg */); } public static Bundle call(ContentResolver cr, String method, String arg) { return cr.call(CONTENT_URI, method, arg, null); } }} 紧接着进入 LauncherProvider.call() 方法： 123456789101112131415161718192021222324📄 源码路径：package/app/Launcher3/src/com/android/launcher3/LauncherProvider.javapublic class LauncherProvider extends ContentProvider { /** * method: &quot;load_default_favorites&quot; * arg. : null * extras: null */ @Override public Bundle call(String method, final String arg, final Bundle extras) { switch (method) { ... case LauncherSettings.Settings.METHOD_LOAD_DEFAULT_FAVORITES: { getModelDbController().loadDefaultFavoritesIfNecessary(); return null; } ... } }} 继续跟踪 loadDefaultFavoritesIfNecessary() 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384📄 源码路径：package/app/Launcher3/src/com/android/launcher3/model/ModelDbController.javapublic class ModelDbController { /** * Loads the default workspace based on the following priority scheme: * 1) From the app restrictions * 2) From a package provided by play store * 3) From a partner configuration APK, already in the system image * 4) The default configuration for the particular device * * 1) 来自应用限制 * 2) 来自 Play 商店提供的软件包 * 3) 来自已集成在 image 中的合作伙伴配置的 APK * 4) 特定设备的默认配置 */ @WorkerThread public synchronized void loadDefaultFavoritesIfNecessary() { // 确保数据库已创建。如果数据库不存在，则会创建一个新的数据库文件 createDbIfNotExists(); // 检查是否创建了空数据库，如果清除了 Launcher 数据，则会为 true if (LauncherPrefs.get(mContext).get(getEmptyDbCreatedKey(mOpenHelper.getDatabaseName()))) { // LauncherWidgetHolder 是一个用于管理小部件的容器，在加载布局时用来保存和处理小部件信息 LauncherWidgetHolder widgetHolder = mOpenHelper.newLauncherWidgetHolder(); try { // 1. 尝试从系统配置的 launcher3.layout.provider 提供的 provider 里面获取布局资源 AutoInstallsLayout loader = createWorkspaceLoaderFromAppRestriction(widgetHolder); if (loader == null) { /** * 2. 尝试从带有 * android.autoinstalls.config.action.PLAY_AUTO_INSTALL 的 apk 里面 * 获取布局资源 */ loader = AutoInstallsLayout.get(mContext, widgetHolder, mOpenHelper); } if (loader == null) { /** * 3. 尝试从系统内置的 Partner 应用里获取 workspace 默认配置 * 这个功能是提供给提供布局的第三方应用 */ final Partner partner = Partner.get(mContext.getPackageManager()); if (partner != null) { int workspaceResId = partner.getXmlResId(RES_PARTNER_DEFAULT_LAYOUT); if (workspaceResId != 0) { loader = new DefaultLayoutParser(mContext, widgetHolder, mOpenHelper, partner.getResources(), workspaceResId); } } } // 确定是否使用了外部提供的布局 final boolean usingExternallyProvidedLayout = loader != null; if (loader == null) { // 4. 尝试获取 Launcher 里的默认资源，比如 @xml/default_workspace_5x5 loader = getDefaultLayoutParser(widgetHolder); } // There might be some partially restored DB items, due to buggy restore logic in // previous versions of launcher. // 清空数据库 mOpenHelper.createEmptyDB(mOpenHelper.getWritableDatabase()); // Populate favorites table with initial favorites // 解析布局文件并写入数据库 // 首先使用上面得到的 loader 获取，如果该 loader 提供的方式里面为空的布局， // 那么还是使用上面第 4 步的 loader if ((mOpenHelper.loadFavorites(mOpenHelper.getWritableDatabase(), loader) &lt;= 0) &amp;&amp; usingExternallyProvidedLayout) { // Unable to load external layout. Cleanup and load the internal layout. mOpenHelper.createEmptyDB(mOpenHelper.getWritableDatabase()); mOpenHelper.loadFavorites(mOpenHelper.getWritableDatabase(), getDefaultLayoutParser(widgetHolder)); } // 清理空数据库创建的标志，表示数据库已经准备好了。 clearFlagEmptyDbCreated(); } finally { // 无论方法是否成功执行，都销毁 widgetHolder 实例，释放相关资源 widgetHolder.destroy(); } } }} 我们来看下第 4 步加载 Launcher 默认的布局资源相关逻辑： 123456789101112131415161718192021222324252627📄 源码路径：package/app/Launcher3/src/com/android/launcher3/model/ModelDbController.javapublic class ModelDbController { private DefaultLayoutParser getDefaultLayoutParser(LauncherWidgetHolder widgetHolder) { /** * 获取 InvariantDeviceProfile 实例，它代表了设备的配置文件，包含布局相关的设置 */ InvariantDeviceProfile idp = LauncherAppState.getIDP(mContext); /** * 获取默认布局资源id，比如：@xml/default_workspace_5x5 * * demoModeLayoutId：是否为演示模式 * 1. 如果是则调用演示模式的布局 id -&gt; idp.demoModeLayoutId * 2. 如不是则调用内部默认的布局 id -&gt; idp.defaultLayoutId -&gt; 我们只需要关心这个 */ int defaultLayout = idp.demoModeLayoutId != 0 &amp;&amp; mContext.getSystemService(UserManager.class).isDemoUser() ? idp.demoModeLayoutId : idp.defaultLayoutId; // 创建 DefaultLayoutParser 实例 return new DefaultLayoutParser(mContext, widgetHolder, mOpenHelper, mContext.getResources(), defaultLayout); }} 要想弄清楚 idp.defaultLayoutId 是哪个布局，我们得先来看 LauncherAppState.getIDP() 方法： 12345678910📄 源码路径：package/app/Launcher3/src/com/android/launcher3/LauncherAppState.javapublic class LauncherAppState implements SafeCloseable { public static InvariantDeviceProfile getIDP(Context context) { // 获取 InvariantDeviceProfile 单例 return InvariantDeviceProfile.INSTANCE.get(context); }} 继续跟踪源码： 123456789101112131415161718192021222324252627282930313233343536📄 源码路径：package/app/Launcher3/src/com/android/launcher3/InvariantDeviceProfile.javapublic class InvariantDeviceProfile { private InvariantDeviceProfile(Context context) { // 获取当前的网格名称 String gridName = getCurrentGridName(context); // 初始化网格，可能会返回新的网格名称 String newGridName = initGrid(context, gridName); if (!newGridName.equals(gridName)) { // 如果新的网格名称与当前网格名称不同，则更新 LauncherPrefs 中的网格名称 LauncherPrefs.get(context).put(GRID_NAME, newGridName); } // 当用户解锁时执行指定的操作 LockedUserState.get(context).runOnUserUnlocked(() -&gt; { // 创建一个 DeviceGridState 实例并调用 writeToPrefs(context)， // 将设备网格状态写入偏好设置 new DeviceGridState(this).writeToPrefs(context); }); // 设置一个监听器来处理设备显示配置的更改 DisplayController.INSTANCE.get(context).setPriorityListener( (displayContext, info, flags) -&gt; { /** * 监听器的回调方法检查标志 flags 是否包含配置更改的 * 相关标志（如密度、支持的边界、导航模式等） */ if ((flags &amp; (CHANGE_DENSITY | CHANGE_SUPPORTED_BOUNDS | CHANGE_NAVIGATION_MODE)) != 0) { // 如果有变化，调用 onConfigChanged() 方法处理这些变化 onConfigChanged(displayContext); } }); } } 我们关注 initGrid() 方法： 12345678910111213141516171819202122232425📄 源码路径：package/app/Launcher3/src/com/android/launcher3/InvariantDeviceProfile.javapublic class InvariantDeviceProfile { private String initGrid(Context context, String gridName) { // 获取当前设备的显示信息 Info displayInfo = DisplayController.INSTANCE.get(context).getInfo(); // 根据显示信息确定设备类型（如手机、平板等） @DeviceType int deviceType = getDeviceType(displayInfo); // 根据上下文、网格名称、设备类型和数据库恢复任务的状态，获取所有预定义的显示选项 ArrayList&lt;DisplayOption&gt; allOptions = getPredefinedDeviceProfiles(context, gridName, deviceType, RestoreDbTask.isPending(context)); // 使用加权插值方法从所有预定义的显示选项中选择一个合适的选项， // 此方法考虑设备的显示信息和设备类型来做出选择。 DisplayOption displayOption = invDistWeightedInterpolate(displayInfo, allOptions, deviceType); // 使用选定的显示选项初始化网格，这个方法可能会设置设备的显示网格以适应所选的显示选项 initGrid(context, displayInfo, displayOption, deviceType); // 返回所选显示选项的网格名称 return displayOption.grid.name; }} 现在重点就来到了 getPredefinedDeviceProfiles() 方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107📄 源码路径：package/app/Launcher3/src/com/android/launcher3/InvariantDeviceProfile.javapublic class InvariantDeviceProfile { private static ArrayList&lt;DisplayOption&gt; getPredefinedDeviceProfiles(Context context, String gridName, @DeviceType int deviceType, boolean allowDisabledGrid) { // 初始化一个空的 DisplayOption 列表，profiles 用于存储从 XML 解析出的所有显示配置文件 ArrayList&lt;DisplayOption&gt; profiles = new ArrayList&lt;&gt;(); /** * 开始解析 XML -&gt; 解析哪个 XML ？ * 熟悉的 XML 文件来了 -&gt; device_profiles.xml * * 使用 XmlResourceParser 解析 R.xml.device_profiles 资源文件， * 该文件包含所有预定义的设备配置文件 */ try (XmlResourceParser parser = context.getResources().getXml(R.xml.device_profiles)) { // 获取当前 XML 标签的深度，用于确定解析结束的条件 final int depth = parser.getDepth(); int type; // 循环解析 XML 文件，直到遇到 END_TAG（标签结束）或文档结束 while (((type = parser.next()) != XmlPullParser.END_TAG || parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) { /** * 看 if 判断里面的 GridOption.TAG_NAME -&gt; &quot;grid-option&quot; -&gt; 是不是很熟悉 ？ * * 插播一点 device_profiles.xml 的内容 * &lt;grid-option * launcher:name=&quot;4_by_6&quot; * launcher:numRows=&quot;6&quot; * launcher:defaultLayoutId=&quot;@xml/default_workspace_4x6&quot; * launcher:deviceCategory=&quot;phone|multi_display&quot; * ... /&gt; * * &lt;display-option * launcher:name=&quot;Large Phone&quot; * ... /&gt; * &lt;/grid-option&gt; */ if ((type == XmlPullParser.START_TAG) &amp;&amp; GridOption.TAG_NAME.equals(parser.getName())) { /** * 当遇到 &quot;grid-option&quot; 对应标签，创建一个 GridOption 实例 * * GridOption 的源码我们一会就要跟，这里先注意一下！！！ */ GridOption gridOption = new GridOption(context, Xml.asAttributeSet(parser)); // 检查 GridOption 是否启用，或根据 allowDisabledGrid 参数决定是否处理禁用的网格选项 if (gridOption.isEnabled(deviceType) || allowDisabledGrid) { final int displayDepth = parser.getDepth(); while (((type = parser.next()) != XmlPullParser.END_TAG || parser.getDepth() &gt; displayDepth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) { // 如果满足条件，继续解析这个网格选项下的 display-option 标签 if ((type == XmlPullParser.START_TAG) &amp;&amp; &quot;display-option&quot;.equals( parser.getName())) { // 将其添加到 profiles 列表中 profiles.add(new DisplayOption(gridOption, context, Xml.asAttributeSet(parser))); } } } } } } catch (IOException | XmlPullParserException e) { throw new RuntimeException(e); } // 创建一个空的 filteredProfiles 列表，用于存储符合条件的 DisplayOption ArrayList&lt;DisplayOption&gt; filteredProfiles = new ArrayList&lt;&gt;(); /** * 如果提供了 gridName，则遍历 profiles 列表，找到与 gridName 匹配且启用的选项， * 将其添加到 filteredProfiles 列表中 * * 我的设备测试 Log： * [ @@@ Pepsimarco ] 日志输出：===&gt; gridName = 5_by_5 */ if (!TextUtils.isEmpty(gridName)) { for (DisplayOption option : profiles) { if (gridName.equals(option.grid.name) &amp;&amp; (option.grid.isEnabled(deviceType) || allowDisabledGrid)) { filteredProfiles.add(option); } } } // 如果 filteredProfiles 为空（即没有匹配到合适的显示选项） if (filteredProfiles.isEmpty()) { // No grid found, use the default options // 则从 profiles 列表中选择可以作为默认选项 (canBeDefault) 的显示选项 for (DisplayOption option : profiles) { if (option.canBeDefault) { filteredProfiles.add(option); } } } if (filteredProfiles.isEmpty()) { throw new RuntimeException(&quot;No display option with canBeDefault=true&quot;); } // 返回 filteredProfiles，即符合条件的显示选项列表 return filteredProfiles; }} 至此，对于 device_profiles.xml 的解析，我们已经完全掌握了，还记得我们前面还遗漏的 GridOption 吗？ 我们来跟源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111📄 源码路径：package/app/Launcher3/src/com/android/launcher3/InvariantDeviceProfile.javapublic class InvariantDeviceProfile { public static final class GridOption { /** * GridOption 主要功能： * 1. 从传入的 AttributeSet 中获取并解析与网格布局相关的属性； * 2. 初始化 GridOption 类的成员变量，以便后续使用这些配置参数来设置或调整应用程序的显示布局。 */ public GridOption(Context context, AttributeSet attrs) { TypedArray a = context.obtainStyledAttributes( attrs, R.styleable.GridDisplayOption); // 网格布局的名称 name = a.getString(R.styleable.GridDisplayOption_name); // 网格的行数 numRows = a.getInt(R.styleable.GridDisplayOption_numRows, 0); // 网格的列数 numColumns = a.getInt(R.styleable.GridDisplayOption_numColumns, 0); // 搜索容器的列数，如果未指定，则默认与 numColumns 一致 numSearchContainerColumns = a.getInt( R.styleable.GridDisplayOption_numSearchContainerColumns, numColumns); // 数据库文件的名称 dbFile = a.getString(R.styleable.GridDisplayOption_dbFile); // 默认布局资源 ID defaultLayoutId = a.getResourceId( R.styleable.GridDisplayOption_defaultLayoutId, 0); // 演示模式下的布局资源 ID，如果未指定，则使用 defaultLayoutId demoModeLayoutId = a.getResourceId( R.styleable.GridDisplayOption_demoModeLayoutId, defaultLayoutId); // 抽屉的样式资源 ID allAppsStyle = a.getResourceId(R.styleable.GridDisplayOption_allAppsStyle, R.style.AllAppsStyleDefault); // 抽屉中的列数 numAllAppsColumns = a.getInt( R.styleable.GridDisplayOption_numAllAppsColumns, numColumns); // 数据库中应用程序抽屉的扩展列数，默认为 numAllAppsColumns 的两倍 numDatabaseAllAppsColumns = a.getInt( R.styleable.GridDisplayOption_numExtendedAllAppsColumns, 2 * numAllAppsColumns); // HotSeat 图标数量 numHotseatIcons = a.getInt( R.styleable.GridDisplayOption_numHotseatIcons, numColumns); // 数据库中 Hotseat 的扩展图标数量，默认为 numHotseatIcons 的两倍 numDatabaseHotseatIcons = a.getInt( R.styleable.GridDisplayOption_numExtendedHotseatIcons, 2 * numHotseatIcons); // Hotseat 在不同屏幕方向和模式下的列跨度 hotseatColumnSpan[INDEX_DEFAULT] = a.getInt( R.styleable.GridDisplayOption_hotseatColumnSpan, numColumns); hotseatColumnSpan[INDEX_LANDSCAPE] = a.getInt( R.styleable.GridDisplayOption_hotseatColumnSpanLandscape, numColumns); hotseatColumnSpan[INDEX_TWO_PANEL_LANDSCAPE] = a.getInt( R.styleable.GridDisplayOption_hotseatColumnSpanTwoPanelLandscape, numColumns); hotseatColumnSpan[INDEX_TWO_PANEL_PORTRAIT] = a.getInt( R.styleable.GridDisplayOption_hotseatColumnSpanTwoPanelPortrait, numColumns); // 导航按钮 End 间距资源 ID inlineNavButtonsEndSpacing = a.getResourceId(R.styleable.GridDisplayOption_inlineNavButtonsEndSpacing, R.dimen.taskbar_button_margin_default); // 文件夹内的行数 numFolderRows = a.getInt( R.styleable.GridDisplayOption_numFolderRows, numRows); // 文件夹内的列数 numFolderColumns = a.getInt( R.styleable.GridDisplayOption_numFolderColumns, numColumns); // 文件夹的样式资源 ID folderStyle = a.getResourceId(R.styleable.GridDisplayOption_folderStyle, INVALID_RESOURCE_HANDLE); // 单元格的样式资源 ID cellStyle = a.getResourceId(R.styleable.GridDisplayOption_cellStyle, R.style.CellStyleDefault); // 网格是否可以缩放 isScalable = a.getBoolean( R.styleable.GridDisplayOption_isScalable, false); // 设备填充的资源 ID devicePaddingId = a.getResourceId( R.styleable.GridDisplayOption_devicePaddingId, INVALID_RESOURCE_HANDLE); // 设备类别 deviceCategory = a.getInt(R.styleable.GridDisplayOption_deviceCategory, DEVICE_CATEGORY_ALL); // 工作区规格的资源 ID if (FeatureFlags.ENABLE_RESPONSIVE_WORKSPACE.get()) { mWorkspaceSpecsId = a.getResourceId( R.styleable.GridDisplayOption_workspaceSpecsId, INVALID_RESOURCE_HANDLE); } else { mWorkspaceSpecsId = INVALID_RESOURCE_HANDLE; } // 搜索栏在不同屏幕方向和模式下是否内联 int inlineForRotation = a.getInt(R.styleable.GridDisplayOption_inlineQsb, DONT_INLINE_QSB); inlineQsb[INDEX_DEFAULT] = (inlineForRotation &amp; INLINE_QSB_FOR_PORTRAIT) == INLINE_QSB_FOR_PORTRAIT; inlineQsb[INDEX_LANDSCAPE] = (inlineForRotation &amp; INLINE_QSB_FOR_LANDSCAPE) == INLINE_QSB_FOR_LANDSCAPE; inlineQsb[INDEX_TWO_PANEL_PORTRAIT] = (inlineForRotation &amp; INLINE_QSB_FOR_TWO_PANEL_PORTRAIT) == INLINE_QSB_FOR_TWO_PANEL_PORTRAIT; inlineQsb[INDEX_TWO_PANEL_LANDSCAPE] = (inlineForRotation &amp; INLINE_QSB_FOR_TWO_PANEL_LANDSCAPE) == INLINE_QSB_FOR_TWO_PANEL_LANDSCAPE; // 释放 TypedArray，以避免内存泄漏 a.recycle(); } }} 至此，我们再来看 idp.defaultLayoutId： 12345678910111213141516171819202122232425📄 源码路径：package/app/Launcher3/src/com/android/launcher3/InvariantDeviceProfile.javapublic class InvariantDeviceProfile { public int defaultLayoutId; // 这个默认布局是哪个，你清楚了吗？ ==&gt; defaultLayoutId = a.getResourceId( R.styleable.GridDisplayOption_defaultLayoutId, 0); ==&gt; 就看你的 gridName 是哪个，比如我的设备是：5_by_5 ==&gt; &lt;grid-option launcher:name=&quot;5_by_5&quot; launcher:numRows=&quot;5&quot; launcher:numColumns=&quot;5&quot; launcher:numFolderRows=&quot;4&quot; launcher:numFolderColumns=&quot;4&quot; launcher:numHotseatIcons=&quot;5&quot; launcher:numExtendedHotseatIcons=&quot;6&quot; launcher:dbFile=&quot;launcher.db&quot; launcher:inlineNavButtonsEndSpacing=&quot;@dimen/taskbar_button_margin_split&quot; launcher:defaultLayoutId=&quot;@xml/default_workspace_5x5&quot; launcher:deviceCategory=&quot;phone|multi_display&quot; &gt;} 讲到这，我们就完全讲通了 Launcher 何时会解析 device_profiles.xml 文件，并且去找对应的某一个 default_workspace_xxx 了。 加载数据库分析完默认布局的流程外，我们继续 loadWorkspaceImpl() 中遗留的数据库的加载逻辑： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166📄 源码路径：package/app/Launcher3/src/com/android/launcher3/model/LoaderTask.javapublic class LoaderTask implements Runnable { protected final LauncherAppState mApp; private void loadWorkspaceImpl( List&lt;ShortcutInfo&gt; allDeepShortcuts, String selection, @Nullable LoaderMemoryLogger memoryLogger) { ... /********************************************************************* * 核心 1: 加载默认桌面布局 * * 会调用到 LauncherProvider 的 loadDefaultFavoritesIfNecessary() 方法， * 这个方法来判断是否需要加载默认的布局，如果清除了桌面数据 * 或者手机恢复了出厂设置，就会加载默认的布局 ********************************************************************/ Settings.call(contentResolver, Settings.METHOD_LOAD_DEFAULT_FAVORITES); /********************************************************************* * 核心 2: * * 加载数据库 ********************************************************************/ synchronized (mBgDataModel) { mBgDataModel.clear(); // 清除数据模型（内存中的工作区数据） mPendingPackages.clear(); // 清除待处理的应用包信息 // 获取当前正在进行的安装会话的列表 final HashMap&lt;PackageUserKey, SessionInfo&gt; installingPkgs = mSessionHelper.getActiveSessions(); // 将每个安装会话的信息更新到图标缓存中 (IconCache)，确保 Launcher 能够正确显示应用安装状态 installingPkgs.forEach(mApp.getIconCache()::updateSessionCache); // 用于暂存包名和用户键值的临时对象 final PackageUserKey tempPackageKey = new PackageUserKey(null, null); // 初始化一个广播对象，用于在 Launcher 加载时广播状态信息 mFirstScreenBroadcast = new FirstScreenBroadcast(installingPkgs); // 存储固定在 Launcher 上的快捷方式信息的映射 mShortcutKeyToPinnedShortcuts = new HashMap&lt;&gt;(); ModelDbController dbController = mApp.getModel().getModelDbController(); /*********************************************** * 通过 LoaderCursor 查询数据库，获取工作空间的数据项 ***********************************************/ final LoaderCursor c = new LoaderCursor( dbController.query(TABLE_NAME, null, selection, null, null), mApp, mUserManagerState); final Bundle extras = c.getExtras(); // 从数据库查询结果的额外信息 (extras) 中获取数据库名称 -&gt; launcher.db mDbName = extras == null ? null : extras.getString(Settings.EXTRA_DB_NAME); try { // 一个稀疏数组 (LongSparseArray)，用于存储用户的解锁状态 final LongSparseArray&lt;Boolean&gt; unlockedUsers = new LongSparseArray&lt;&gt;(); mUserManagerState.init(mUserCache, mUserManager); // 遍历用户配置文件，对每个用户： for (UserHandle user : mUserCache.getUserProfiles()) { long serialNo = mUserCache.getSerialNumberForUser(user); // 检查用户是否解锁 boolean userUnlocked = mUserManager.isUserUnlocked(user); // 向 LauncherAppsService 获取 Pinned Shortcuts if (userUnlocked) { QueryResult pinnedShortcuts = new ShortcutRequest(context, user) .query(ShortcutRequest.PINNED); if (pinnedShortcuts.wasSuccess()) { for (ShortcutInfo shortcut : pinnedShortcuts) { // 如果用户解锁，查询固定的快捷方式， // 并将其存储在 mShortcutKeyToPinnedShortcuts 中 mShortcutKeyToPinnedShortcuts.put(ShortcutKey.fromInfo(shortcut), shortcut); } } else { // Shortcut manager can fail due to some race condition when the // lock state changes too frequently. For the purpose of the loading // shortcuts, consider the user is still locked. userUnlocked = false; } } // 将用户的解锁状态存储在 unlockedUsers 中 unlockedUsers.put(serialNo, userUnlocked); } // 一个列表，存储了需要批量加载的图标请求信息 List&lt;IconRequestInfo&lt;WorkspaceItemInfo&gt;&gt; iconRequestInfos = new ArrayList&lt;&gt;(); /** * 开始遍历数据库，一次读取数据库内容，遍历 LoaderCursor 中的每一行， * 使用 processWorkspaceItem() 方法 * 处理每个工作空间项目，包括应用图标、小部件和快捷方式 * * 核心方法，下面我们要跟踪！！！ */ while (!mStopped &amp;&amp; c.moveToNext()) { processWorkspaceItem(c, memoryLogger, installingPkgs, isSdCardReady, tempPackageKey, widgetHelper, pmHelper, iconRequestInfos, unlockedUsers, isSafeMode, allDeepShortcuts); } // 批量加载工作空间图标，以提高加载性能 tryLoadWorkspaceIconsInBulk(iconRequestInfos); } finally { IOUtils.closeSilently(c); } if (!FeatureFlags.CHANGE_MODEL_DELEGATE_LOADING_ORDER.get()) { // mModelDelegate: 负责将数据绑定到 UI 上的委托对象 // 加载并绑定 WorkspaceItems mModelDelegate.loadAndBindWorkspaceItems(mUserManagerState, mLauncherBinder.mCallbacksList, mShortcutKeyToPinnedShortcuts); // 加载并绑定 AllAppsItems mModelDelegate.loadAndBindAllAppsItems(mUserManagerState, mLauncherBinder.mCallbacksList, mShortcutKeyToPinnedShortcuts); // 加载并绑定 OtherItems mModelDelegate.loadAndBindOtherItems(mLauncherBinder.mCallbacksList); // 标记加载过程完成，Launcher 可以开始响应用户操作 mModelDelegate.markActive(); } // Break early if we have stopped loading if (mStopped) { mBgDataModel.clear(); return; } // Remove dead items，删除 processWorkspaceItem 中标记 delete 的数据 mItemsDeleted = c.commitDeleted(); // Sort the folder items, update ranks, and make sure all preview items are high res. // 文件夹内容的排序和更新 // FolderGridOrganizer: 用于组织和验证文件夹网格布局 FolderGridOrganizer verifier = new FolderGridOrganizer(mApp.getInvariantDeviceProfile()); // 遍历每一个文件夹 for (FolderInfo folder : mBgDataModel.folders) { // 对文件夹内容进行排序 Collections.sort(folder.contents, Folder.ITEM_POS_COMPARATOR); verifier.setFolderInfo(folder); int size = folder.contents.size(); // Update ranks here to ensure there are no gaps caused by removed folder items. // Ranks are the source of truth for folder items, so cellX and cellY can be ignored // for now. Database will be updated once user manually modifies folder. // 更新项目的 rank，确保显示顺序正确 for (int rank = 0; rank &lt; size; ++rank) { WorkspaceItemInfo info = folder.contents.get(rank); info.rank = rank; // 对于使用低分辨率图标且显示在文件夹预览中的项目，加载高分辨率图标 if (info.usingLowResIcon() &amp;&amp; info.itemType == Favorites.ITEM_TYPE_APPLICATION &amp;&amp; verifier.isItemInPreview(info.rank)) { mIconCache.getTitleAndIcon(info, false); } } } // 最后，将所有处理后的工作区项提交到数据库中 c.commitRestoredItems(); } } } 接下来我们就要开始重点分析 processWorkspaceItem() 的源码了： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465📄 源码路径：package/app/Launcher3/src/com/android/launcher3/model/LoaderTask.javapublic class LoaderTask implements Runnable { /** * 处理从数据库加载的桌面项目（如快捷方式、文件夹、应用小部件等） * * c : 用于读取数据库中存储的桌面项目数据的游标 * memoryLogger : 用于记录内存消耗的日志工具 * installingPkgs : 一个哈希表，用于跟踪正在安装的应用包 * isSdCardReady : 标识 SD 卡是否已准备就绪的标志 * tempPackageKey : 一个临时的 PackageUserKey 对象，用于处理包名和用户信息 * widgetHelper : 用于管理小部件的辅助类 * pmHelper : 用于处理包管理的辅助类 * iconRequestInfos: 用于存储要加载图标的请求信息的列表 * unlockedUsers : 用于存储已解锁用户的标识符的稀疏数组 * isSafeMode : 是否处于安全模式的标志 * allDeepShortcuts: 用于存储所有深层快捷方式的信息列表 */ private void processWorkspaceItem(LoaderCursor c, LoaderMemoryLogger memoryLogger, HashMap&lt;PackageUserKey, SessionInfo&gt; installingPkgs, boolean isSdCardReady, PackageUserKey tempPackageKey, WidgetManagerHelper widgetHelper, PackageManagerHelper pmHelper, List&lt;IconRequestInfo&lt;WorkspaceItemInfo&gt;&gt; iconRequestInfos, LongSparseArray&lt;Boolean&gt; unlockedUsers, boolean isSafeMode, List&lt;ShortcutInfo&gt; allDeepShortcuts) { try { if (c.user == null) { // User has been deleted, remove the item. // 首先检查用户是否存在。如果不存在，则标记为删除 c.markDeleted(&quot;User has been deleted&quot;); return; } // 用于标记是否允许丢失目标应用的情况 boolean allowMissingTarget = false; /** * 接下来就是实际的处理逻辑了，开始处理不同类型的桌面项目： * * Favorites.ITEM_TYPE_SHORTCUT : 处理普通快捷方式 * Favorites.ITEM_TYPE_APPLICATION : 处理应用快捷方式 * Favorites.ITEM_TYPE_DEEP_SHORTCUT: 处理深层快捷方式 * Favorites.ITEM_TYPE_FOLDER : 处理文件夹 * Favorites.ITEM_TYPE_APPWIDGET : 处理应用小部件 */ switch (c.itemType) { case Favorites.ITEM_TYPE_SHORTCUT: // 如果是快捷方式 case Favorites.ITEM_TYPE_APPLICATION: // 如果是应用程序 case Favorites.ITEM_TYPE_DEEP_SHORTCUT: // 如果是深层快捷方式 case Favorites.ITEM_TYPE_FOLDER // 如果是文件夹 case Favorites.ITEM_TYPE_APPWIDGET // 如果是应用小部件 ... // 代码太多，我们分类分析 } } catch (Exception e) { Log.e(TAG, &quot;Desktop items loading interrupted&quot;, e); } }} 应用/快捷方式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246📄 源码路径：package/app/Launcher3/src/com/android/launcher3/model/LoaderTask.javapublic class LoaderTask implements Runnable { private void processWorkspaceItem(LoaderCursor c, LoaderMemoryLogger memoryLogger, HashMap&lt;PackageUserKey, SessionInfo&gt; installingPkgs, boolean isSdCardReady, PackageUserKey tempPackageKey, WidgetManagerHelper widgetHelper, PackageManagerHelper pmHelper, List&lt;IconRequestInfo&lt;WorkspaceItemInfo&gt;&gt; iconRequestInfos, LongSparseArray&lt;Boolean&gt; unlockedUsers, boolean isSafeMode, List&lt;ShortcutInfo&gt; allDeepShortcuts) { try { ... switch (c.itemType) { case Favorites.ITEM_TYPE_SHORTCUT: // 如果是快捷方式 case Favorites.ITEM_TYPE_APPLICATION: // 如果是应用程序 case Favorites.ITEM_TYPE_DEEP_SHORTCUT: // 如果是深层快捷方式 // 从 LoaderCursor 中解析 Intent 对象 Intent intent = c.parseIntent(); // 验证 intent 有效性 if (intent == null) { // 如果 Intent 为空或无效，则标记为已删除 c.markDeleted(&quot;Invalid or null intent&quot;); return; } // 根据用户管理器状态判断该用户是否为静默用户 int disabledState = mUserManagerState.isUserQuiet(c.serialNumber) ? WorkspaceItemInfo.FLAG_DISABLED_QUIET_USER : 0; // 从 Intent 中获取组件名称 ComponentName cn = intent.getComponent(); String targetPkg = cn == null ? intent.getPackage() : cn.getPackageName(); // 如果目标包名为空且项目类型不是快捷方式，则标记为已删除 if (TextUtils.isEmpty(targetPkg) &amp;&amp; c.itemType != Favorites.ITEM_TYPE_SHORTCUT) { c.markDeleted(&quot;Only legacy shortcuts can have null package&quot;); return; } // 检查目标包是否有效（如果没有目标包名，则表示这是一个隐式 Intent，始终有效） boolean validTarget = TextUtils.isEmpty(targetPkg) || mLauncherApps.isPackageEnabled(targetPkg, c.user); // 如果组件名不为空且目标有效且项目不是深度快捷方式 if (cn != null &amp;&amp; validTarget &amp;&amp; c.itemType != Favorites.ITEM_TYPE_DEEP_SHORTCUT) { // If the apk is present and the shortcut points to a specific component. // 如果目标活动存在，标记项目为已恢复 if (mLauncherApps.isActivityEnabled(cn, c.user)) { // no special handling necessary for this item c.markRestored(); // 标记为已恢复 } else { // 否则，尝试找到一个备用的启动活动 intent = pmHelper.getAppLaunchIntent(targetPkg, c.user); // 如果找到了启动活动，更新 Intent 并重置恢复标志 if (intent != null) { c.restoreFlag = 0; c.updater().put( Favorites.INTENT, intent.toUri(0)).commit(); // 更新组件名称 cn = intent.getComponent(); } else { // 如果找不到启动活动，则标记项目为已删除并返回 c.markDeleted(&quot;Unable to find a launch target&quot;); return; } } } // 如果目标包无效，则处理恢复状态 if (!TextUtils.isEmpty(targetPkg) &amp;&amp; !validTarget) { if (c.restoreFlag != 0) { // 如果应用程序还未恢复 FileLog.d(TAG, &quot;package not yet restored: &quot; + targetPkg); tempPackageKey.update(targetPkg, c.user); if (c.hasRestoreFlag(WorkspaceItemInfo.FLAG_RESTORE_STARTED)) { // 恢复已经开始，不做任何操作 } else if (installingPkgs.containsKey(tempPackageKey)) { // 恢复正在进行，更新恢复标记 c.restoreFlag |= WorkspaceItemInfo.FLAG_RESTORE_STARTED; c.updater().put(Favorites.RESTORED, c.restoreFlag).commit(); } else { // 否则标记项目为已删除并返回 c.markDeleted(&quot;Unrestored app removed: &quot; + targetPkg); return; } } else if (pmHelper.isAppOnSdcard(targetPkg, c.user)) { // 如果包在 SD 卡上但不可用，标记应用不可用 disabledState |= WorkspaceItemInfo.FLAG_DISABLED_NOT_AVAILABLE; // 允许丢失目标，仍然将图标添加到工作区 allowMissingTarget = true; } else if (!isSdCardReady) { // 如果 SD 卡未准备好，将包名添加到待处理列表中 Log.d(TAG, &quot;Missing pkg, will check later: &quot; + targetPkg); mPendingPackages.add(new PackageUserKey(targetPkg, c.user)); // 允许丢失目标，仍然将图标添加到工作区 allowMissingTarget = true; } else { // 如果包无效且 SD 卡已准备好，标记项目为已删除并返回 c.markDeleted(&quot;Invalid package removed: &quot; + targetPkg); return; } } // 如果恢复标志包含 Web UI 支持标志，设置目标无效 if ((c.restoreFlag &amp; WorkspaceItemInfo.FLAG_SUPPORTS_WEB_UI) != 0) { validTarget = false; } if (validTarget) { // 如果快捷方式指向一个有效的目标，标记为已恢复 c.markRestored(); } // 决定是否使用低分辨率的图标 boolean useLowResIcon = !c.isOnWorkspaceOrHotseat(); WorkspaceItemInfo info; if (c.restoreFlag != 0) { // 如果恢复标记不为 0，获取恢复的 item 信息 info = c.getRestoredItemInfo(intent); } else if (c.itemType == Favorites.ITEM_TYPE_APPLICATION) { // 创建应用程序快捷方式信息 info = c.getAppShortcutInfo( intent, allowMissingTarget, useLowResIcon, true); } else if (c.itemType == Favorites.ITEM_TYPE_DEEP_SHORTCUT) { // 处理深层快捷方式 ShortcutKey key = ShortcutKey.fromIntent(intent, c.user); if (unlockedUsers.get(c.serialNumber)) { // 如果用户已解锁，获取深度快捷方式信息 ShortcutInfo pinnedShortcut = mShortcutKeyToPinnedShortcuts.get(key); if (pinnedShortcut == null) { // 如果未找到固定快捷方式，标记项目为已删除并返回 c.markDeleted(&quot;Pinned shortcut not found&quot;); return; } // 创建深度快捷方式的信息对象 info = new WorkspaceItemInfo(pinnedShortcut, mApp.getContext()); // If the pinned deep shortcut is no longer published, // use the last saved icon instead of the default. mIconCache.getShortcutIcon(info, pinnedShortcut, c::loadIcon); // 检查应用是否被挂起 if (pmHelper.isAppSuspended( pinnedShortcut.getPackage(), info.user)) { info.runtimeStatusFlags |= FLAG_DISABLED_SUSPENDED; } // 更新 Intent intent = info.getIntent(); allDeepShortcuts.add(pinnedShortcut); } else { // 如果用户被锁定，创建一个简单的工作区项目信息 info = c.loadSimpleWorkspaceItem(); info.runtimeStatusFlags |= FLAG_DISABLED_LOCKED_USER; } } else { // 处理普通快捷方式 info = c.loadSimpleWorkspaceItem(); // Shortcuts are only available on the primary profile if (!TextUtils.isEmpty(targetPkg) &amp;&amp; pmHelper.isAppSuspended(targetPkg, c.user)) { disabledState |= FLAG_DISABLED_SUSPENDED; } info.options = c.getOptions(); // App shortcuts that used to be automatically added to Launcher // did not always have the correct intent flags set, so do that here // 修复某些旧快捷方式的 Intent 标志 if (intent.getAction() != null &amp;&amp; intent.getCategories() != null &amp;&amp; intent.getAction().equals(Intent.ACTION_MAIN) &amp;&amp; intent.getCategories().contains(Intent.CATEGORY_LAUNCHER)) { intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED); } } // 检查 info 是否为空 if (info != null) { if (info.itemType != Favorites.ITEM_TYPE_DEEP_SHORTCUT) { // Skip deep shortcuts; their title and icons have already been // loaded above. // 将图标请求信息添加到列表 iconRequestInfos.add(c.createIconRequestInfo(info, useLowResIcon)); } // 应用通用属性 c.applyCommonProperties(info); // 更新信息对象的 Intent 和其他属性 info.intent = intent; info.rank = c.getRank(); info.spanX = 1; info.spanY = 1; info.runtimeStatusFlags |= disabledState; // 如果处于安全模式且目标应用不是系统应用，标记其为禁用 if (isSafeMode &amp;&amp; !isSystemApp(mApp.getContext(), intent)) { info.runtimeStatusFlags |= FLAG_DISABLED_SAFEMODE; } // 获取启动活动信息 LauncherActivityInfo activityInfo = c.getLauncherActivityInfo(); if (activityInfo != null) { // 设置下载进度 info.setProgressLevel( PackageManagerHelper.getLoadingProgress(activityInfo), PackageInstallInfo.STATUS_INSTALLED_DOWNLOADING); } if (c.restoreFlag != 0 &amp;&amp; !TextUtils.isEmpty(targetPkg)) { tempPackageKey.update(targetPkg, c.user); SessionInfo si = installingPkgs.get(tempPackageKey); if (si == null) { info.runtimeStatusFlags &amp;= ~ItemInfoWithIcon.FLAG_INSTALL_SESSION_ACTIVE; } else if (activityInfo == null) { int installProgress = (int) (si.getProgress() * 100); info.setProgressLevel(installProgress, PackageInstallInfo.STATUS_INSTALLING); } } // 检查并添加 item 信息到数据模型 c.checkAndAddItem(info, mBgDataModel, memoryLogger); } else { throw new RuntimeException(&quot;Unexpected null WorkspaceItemInfo&quot;); } break; // ===&gt;&gt;&gt; 应用/快捷方式处理完毕 ... } } catch (Exception e) { Log.e(TAG, &quot;Desktop items loading interrupted&quot;, e); } }} 我们来看看 checkAndAddItem() 方法： 12345678910111213141516171819202122232425262728📄 源码路径：package/app/Launcher3/src/com/android/launcher3/model/LoaderCursor.javapublic class LoaderCursor extends CursorWrapper { // 检查并添加一个 ItemInfo 项目到数据模型中 public void checkAndAddItem( ItemInfo info, BgDataModel dataModel, LoaderMemoryLogger logger) { // 检查项目类型是否为深层快捷方式 if (info.itemType == Favorites.ITEM_TYPE_DEEP_SHORTCUT) { // 从 ItemInfo 中生成 ShortcutKey。这是确保快捷方式的 Intent 是有效的， // 如果 ShortcutKey 创建失败，可能会抛出异常，从而跳过加载该项目 ShortcutKey.fromItemInfo(info); } // 验证项目在布局中的位置是否有效（例如，检查是否与其他项目重叠） if (checkItemPlacement(info)) { /** * 重点方法：如果位置有效，将项目添加到 dataModel 中 */ dataModel.addItem(mContext, info, false, logger); } else { // 如果位置无效，调用 markDeleted 方法标记项目为已删除， // 原因是 “Item position overlap”（项目位置重叠） markDeleted(&quot;Item position overlap&quot;); } }} 跟踪 BgDataModel 的 addItem() 方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465📄 源码路径：package/app/Launcher3/src/com/android/launcher3/model/BgDataModel.javapublic class BgDataModel { public synchronized void addItem( Context context, ItemInfo item, boolean newItem, @Nullable LoaderMemoryLogger logger) { // 日志记录 if (logger != null) { logger.addLog( Log.DEBUG, TAG, String.format(&quot;Adding item to ID map: %s&quot;, item.toString()), /* stackTrace= */ null); } // 将 ItemInfo 的 ID 和项目本身添加到 itemsIdMap 映射中。这是一个 ID 到 ItemInfo 对象的映射，用于快速查找项目 itemsIdMap.put(item.id, item); // 根据 ItemInfo 类型进行分类处理 switch (item.itemType) { case LauncherSettings.Favorites.ITEM_TYPE_FOLDER: // 文件夹 case LauncherSettings.Favorites.ITEM_TYPE_APP_PAIR: // 应用对 // 将文件夹的 ID 和 FolderInfo 对象存储到 folders 映射中 folders.put(item.id, (FolderInfo) item); // 同时添加到 workspaceItems 集合，以便在工作区显示 workspaceItems.add(item); break; case LauncherSettings.Favorites.ITEM_TYPE_DEEP_SHORTCUT: // 深层快捷方式 case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION: // 应用 case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT: // 快捷方式 // 检查 container 值决定存储位置 if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP || item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) { // 如果是桌面或者 HotSeat 区域，则直接添加到 workspaceItems workspaceItems.add(item); } else { // 如果 item 应添加到文件夹内部，先检查该文件夹是否存在 if (newItem) { // 若是新 item 且文件夹不存在，记录错误日志，表明尝试添加到不存在的文件夹 if (!folders.containsKey(item.container)) { // Adding an item to a nonexistent collection. String msg = &quot;attempted to add item: &quot; + item + &quot; to a nonexistent app&quot; + &quot; collection&quot;; Log.e(TAG, msg); } } else { // 若文件夹存在，调用 findOrMakeFolder 方法获取文件夹，并将项目添加到该文件夹 findOrMakeFolder(item.container).add((WorkspaceItemInfo) item, false); } } break; case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET: // 小部件 case LauncherSettings.Favorites.ITEM_TYPE_CUSTOM_APPWIDGET: // 自定义小部件 // 强制转换为 LauncherAppWidgetInfo 类型，并将其添加到 appWidgets 集合 appWidgets.add((LauncherAppWidgetInfo) item); break; } // 如果 item 是新添加的深层快捷方式，调用 updateShortcutPinnedState 方法更新快捷方式的固定状态 if (newItem &amp;&amp; item.itemType == LauncherSettings.Favorites.ITEM_TYPE_DEEP_SHORTCUT) { // 该方法使用上下文和用户信息更新快捷方式的固定状态（Pinned 状态） updateShortcutPinnedState(context, item.user); } }} 文件夹1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253📄 源码路径：package/app/Launcher3/src/com/android/launcher3/model/LoaderTask.javapublic class LoaderTask implements Runnable { private void processWorkspaceItem(LoaderCursor c, LoaderMemoryLogger memoryLogger, HashMap&lt;PackageUserKey, SessionInfo&gt; installingPkgs, boolean isSdCardReady, PackageUserKey tempPackageKey, WidgetManagerHelper widgetHelper, PackageManagerHelper pmHelper, List&lt;IconRequestInfo&lt;WorkspaceItemInfo&gt;&gt; iconRequestInfos, LongSparseArray&lt;Boolean&gt; unlockedUsers, boolean isSafeMode, List&lt;ShortcutInfo&gt; allDeepShortcuts) { try { ... switch (c.itemType) { case Favorites.ITEM_TYPE_SHORTCUT: // 如果是快捷方式 case Favorites.ITEM_TYPE_APPLICATION: // 如果是应用程序 case Favorites.ITEM_TYPE_DEEP_SHORTCUT: // 如果是深层快捷方式 ... // 应用/快捷方式处理逻辑 ---------------------------------------------------------------------- case Favorites.ITEM_TYPE_FOLDER: // 如果是文件夹类型 // 从后台数据模型中查找或创建文件夹信息对象 FolderInfo folderInfo = mBgDataModel.findOrMakeFolder(c.id); // 应用通用属性到文件夹信息对象 c.applyCommonProperties(folderInfo); // 不要使用 c.getTitle()，因为此方法已将其缓存在 FolderInfo 中 folderInfo.title = c.getString(c.mTitleIndex); // 设置文件夹在工作区的占用宽度和高度（单位是格子） folderInfo.spanX = 1; folderInfo.spanY = 1; // 应用文件夹的其他选项 folderInfo.options = c.getOptions(); // 恢复标记为已恢复，无需特殊处理恢复的文件夹 c.markRestored(); // 检查并添加文件夹信息到数据模型，并记录内存使用情况 c.checkAndAddItem(folderInfo, mBgDataModel, memoryLogger); break; // ===&gt;&gt;&gt; 文件夹类型处理完毕 ... } } catch (Exception e) { Log.e(TAG, &quot;Desktop items loading interrupted&quot;, e); } }} 这里我们看下 findOrMakeFolder() 方法： 123456789101112131415161718📄 源码路径：package/app/Launcher3/src/com/android/launcher3/model/BgDataModel.javapublic class BgDataModel { public synchronized FolderInfo findOrMakeFolder(int id) { // 通过 id 从 folders 映射中获取对应的 FolderInfo 对象 FolderInfo folderInfo = folders.get(id); if (folderInfo == null) { // 如果文件夹不存在，创建一个新的 FolderInfo 实例 folderInfo = new FolderInfo(); // 新的 FolderInfo 实例以 id 为键存入 folders 映射中， // 确保下次访问同一 id 时可以直接获取该对象 folders.put(id, folderInfo); } return folderInfo; }} Widget123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216📄 源码路径：package/app/Launcher3/src/com/android/launcher3/model/LoaderTask.javapublic class LoaderTask implements Runnable { private void processWorkspaceItem(LoaderCursor c, LoaderMemoryLogger memoryLogger, HashMap&lt;PackageUserKey, SessionInfo&gt; installingPkgs, boolean isSdCardReady, PackageUserKey tempPackageKey, WidgetManagerHelper widgetHelper, PackageManagerHelper pmHelper, List&lt;IconRequestInfo&lt;WorkspaceItemInfo&gt;&gt; iconRequestInfos, LongSparseArray&lt;Boolean&gt; unlockedUsers, boolean isSafeMode, List&lt;ShortcutInfo&gt; allDeepShortcuts) { try { ... switch (c.itemType) { case Favorites.ITEM_TYPE_SHORTCUT: // 如果是快捷方式 case Favorites.ITEM_TYPE_APPLICATION: // 如果是应用程序 case Favorites.ITEM_TYPE_DEEP_SHORTCUT: // 如果是深层快捷方式 ... // 应用/快捷方式处理逻辑 ---------------------------------------------------------------------- case Favorites.ITEM_TYPE_FOLDER: // 如果是文件夹类型 ... // 文件夹类型处理逻辑 ---------------------------------------------------------------------- case Favorites.ITEM_TYPE_APPWIDGET: // 如果类型是应用小部件 // 检查是否禁用所有小部件，如果是，则标记为已删除并返回 if (WidgetsModel.GO_DISABLE_WIDGETS) { c.markDeleted(&quot;Only legacy shortcuts can have null package&quot;); return; } // Follow through，继续处理其他小部件类型 case Favorites.ITEM_TYPE_CUSTOM_APPWIDGET: // 如果类型是自定义的应用小部件 // 读取所有 Launcher 特定的小部件详细信息 boolean customWidget = c.itemType == Favorites.ITEM_TYPE_CUSTOM_APPWIDGET; // 获取小部件的 ID int appWidgetId = c.getAppWidgetId(); // 为应用小部件恢复获取 Provider 的字符串 String savedProvider = c.getAppWidgetProvider(); final ComponentName component; // 如果选项中包含搜索小部件标志 if ((c.getOptions() &amp; LauncherAppWidgetInfo.OPTION_SEARCH_WIDGET) != 0) { // 获取搜索小部件的组件名称 component = QsbContainerView.getSearchComponentName(mApp.getContext()); if (component == null) { // 如果组件为空，则标记为已删除并返回 c.markDeleted(&quot;Discarding SearchWidget without packagename &quot;); return; } } else { // 从保存的字符串中解析组件名称 component = ComponentName.unflattenFromString(savedProvider); } // 检查小部件的 ID 是否有效 final boolean isIdValid = !c.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_ID_NOT_VALID); // 检查小部件的 Provider 是否已准备好 final boolean wasProviderReady = !c.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY); // 创建一个包含组件名称和用户的 ComponentKey ComponentKey providerKey = new ComponentKey(component, c.user); // 如果 mWidgetProvidersMap 不包含该键，则查找并添加小部件 Provider if (!mWidgetProvidersMap.containsKey(providerKey)) { mWidgetProvidersMap.put(providerKey, widgetHelper.findProvider(component, c.user)); } // 从 mWidgetProvidersMap 中获取小部件 Provider 信息 final AppWidgetProviderInfo provider = mWidgetProvidersMap.get(providerKey); // 检查小部件 Provider 是否有效 final boolean isProviderReady = isValidProvider(provider); // 如果不是安全模式、不是自定义小部件、小部件 Provider 曾经准备好但现在不再准备好 if (!isSafeMode &amp;&amp; !customWidget &amp;&amp; wasProviderReady &amp;&amp; !isProviderReady) { // 标记为已删除并返回 c.markDeleted(&quot;Deleting widget that isn't installed anymore: &quot; + provider); } else { // 处理小部件恢复状态 LauncherAppWidgetInfo appWidgetInfo; if (isProviderReady) { // 如果小部件 Provider 准备好，则创建小部件信息 appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId, provider.provider); // Provider 可用，小部件要么可用，要么不可用，不需要跟踪未来的恢复更新 int status = c.restoreFlag &amp; ~LauncherAppWidgetInfo.FLAG_RESTORE_STARTED &amp; ~LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY; if (!wasProviderReady) { // 如果 Provider 之前未准备好，则更新状态和 UI 标志 if (isIdValid) { status |= LauncherAppWidgetInfo.FLAG_UI_NOT_READY; } } appWidgetInfo.restoreStatus = status; } else { // 如果 Provider 不可用，记录恢复状态并创建小部件信息 Log.v(TAG, &quot;Widget restore pending id=&quot; + c.id + &quot; appWidgetId=&quot; + appWidgetId + &quot; status =&quot; + c.restoreFlag); appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId, component); appWidgetInfo.restoreStatus = c.restoreFlag; // 更新临时包键并获取安装进度 tempPackageKey.update(component.getPackageName(), c.user); SessionInfo si = installingPkgs.get(tempPackageKey); Integer installProgress = si == null ? null : (int) (si.getProgress() * 100); if (c.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_RESTORE_STARTED)) { // 恢复已经开始一次 } else if (installProgress != null) { // 应用恢复已经开始，更新标志 appWidgetInfo.restoreStatus |= LauncherAppWidgetInfo.FLAG_RESTORE_STARTED; } else if (!isSafeMode) { // 如果不是安全模式，则标记为已删除并返回 c.markDeleted(&quot;Unrestored widget removed: &quot; + component); return; } // 设置安装进度 appWidgetInfo.installProgress = installProgress == null ? 0 : installProgress; } // 如果恢复标志包含直接配置标志，则设置绑定选项 if (appWidgetInfo.hasRestoreFlag( LauncherAppWidgetInfo.FLAG_DIRECT_CONFIG)) { appWidgetInfo.bindOptions = c.parseIntent(); } // 应用通用属性到小部件信息 c.applyCommonProperties(appWidgetInfo); // 设置小部件的占用格子数量 appWidgetInfo.spanX = c.getSpanX(); appWidgetInfo.spanY = c.getSpanY(); // 设置小部件的选项 appWidgetInfo.options = c.getOptions(); // 设置用户信息 appWidgetInfo.user = c.user; // 设置小部件的来源容器 appWidgetInfo.sourceContainer = c.getAppWidgetSource(); // 如果小部件的大小无效，则标记为已删除并返回 if (appWidgetInfo.spanX &lt;= 0 || appWidgetInfo.spanY &lt;= 0) { c.markDeleted(&quot;Widget has invalid size: &quot; + appWidgetInfo.spanX + &quot;x&quot; + appWidgetInfo.spanY); return; } // 获取小部件 Provider 的信息并检查其最小尺寸要求 LauncherAppWidgetProviderInfo widgetProviderInfo = widgetHelper.getLauncherAppWidgetInfo(appWidgetId); if (widgetProviderInfo != null &amp;&amp; (appWidgetInfo.spanX &lt; widgetProviderInfo.minSpanX || appWidgetInfo.spanY &lt; widgetProviderInfo.minSpanY)) { FileLog.d(TAG, &quot;Widget &quot; + widgetProviderInfo.getComponent() + &quot; minSizes not meet: span=&quot; + appWidgetInfo.spanX + &quot;x&quot; + appWidgetInfo.spanY + &quot; minSpan=&quot; + widgetProviderInfo.minSpanX + &quot;x&quot; + widgetProviderInfo.minSpanY); logWidgetInfo(mApp.getInvariantDeviceProfile(), widgetProviderInfo); } // 如果小部件不在工作区或 HotSeat 中，则标记为已删除并返回 if (!c.isOnWorkspaceOrHotseat()) { c.markDeleted(&quot;Widget found where container != CONTAINER_DESKTOP&quot; + &quot;nor CONTAINER_HOTSEAT - ignoring!&quot;); return; } // 如果不是自定义小部件，检查 Provider 名称是否匹配，更新状态 if (!customWidget) { String providerName = appWidgetInfo.providerName.flattenToString(); if (!providerName.equals(savedProvider) || (appWidgetInfo.restoreStatus != c.restoreFlag)) { c.updater() .put(Favorites.APPWIDGET_PROVIDER, providerName) .put(Favorites.RESTORED, appWidgetInfo.restoreStatus) .commit(); } } // 如果恢复状态不是完成，则创建待处理的小部件信息并获取标题和图标 if (appWidgetInfo.restoreStatus != LauncherAppWidgetInfo.RESTORE_COMPLETED) { appWidgetInfo.pendingItemInfo = WidgetsModel.newPendingItemInfo( mApp.getContext(), appWidgetInfo.providerName, appWidgetInfo.user); mIconCache.getTitleAndIconForApp( appWidgetInfo.pendingItemInfo, false); } // 检查并添加小部件信息到数据模型中 c.checkAndAddItem(appWidgetInfo, mBgDataModel); } break; } } catch (Exception e) { Log.e(TAG, &quot;Desktop items loading interrupted&quot;, e); } }} 至此，loadWorkspace() 的工作算是分析完了，接下来我们看看绑定的流程！ 绑定 Workspace 流程解析绑定 Workspace 是通过 LauncherBinder 的 bindWorkspace() 函数，在其父类 BaseLauncherBinder 中定义。 1234567891011121314151617181920212223242526📄 源码路径：package/app/Launcher3/src/com/android/launcher3/model/BaseLauncherBinder.javapublic abstract class BaseLauncherBinder { /* * Binds all loaded data to actual views on the main thread. */ public void bindWorkspace(boolean incrementBindId, boolean isBindSync) { /** * ENABLE_WORKSPACE_LOADING_OPTIMIZATION 标志主要用于： * * 控制一系列与工作区加载过程相关的优化措施。这些优化可能涵盖了加载速度、 * 内存使用、I/O 操作等方面的改进，以提升用户体验。 * Log 实测为 false，所以我们可以略过这个条件判断。 */ if (FeatureFlags.ENABLE_WORKSPACE_LOADING_OPTIMIZATION.get()) { DisjointWorkspaceBinder workspaceBinder = initWorkspaceBinder(incrementBindId, mBgDataModel.collectWorkspaceScreens()); workspaceBinder.bindCurrentWorkspacePages(isBindSync); workspaceBinder.bindOtherWorkspacePages(); } else { bindWorkspaceAllAtOnce(incrementBindId, isBindSync); } } } 所以，现在我们继续跟踪 bindWorkspaceAllAtOnce() 方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061📄 源码路径：package/app/Launcher3/src/com/android/launcher3/model/BaseLauncherBinder.javapublic abstract class BaseLauncherBinder { // 一次性绑定工作区中的所有项目（应用图标、小部件、屏幕等） private void bindWorkspaceAllAtOnce(boolean incrementBindId, boolean isBindSync) { /** * 初始化集合： * workspaceItems : 用于存储工作区中的项目（应用图标、快捷方式等） * appWidgets : 用于存储工作区中的小部件 * orderedScreenIds: 保存工作区的屏幕 ID，确保所有 Item 按屏幕顺序排列 * extraItems : 存储固定容器中的额外项目，通常是一些特殊的固定元素 */ ArrayList&lt;ItemInfo&gt; workspaceItems = new ArrayList&lt;&gt;(); ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets = new ArrayList&lt;&gt;(); final IntArray orderedScreenIds = new IntArray(); ArrayList&lt;FixedContainerItems&gt; extraItems = new ArrayList&lt;&gt;(); final int workspaceItemCount; /** * 从后台数据模型中获取数据 */ synchronized (mBgDataModel) { /** * 将 mBgDataModel 中的所有工作区项目复制到 workspaceItems */ workspaceItems.addAll(mBgDataModel.workspaceItems); /** * 将所有小部件复制到 appWidgets */ appWidgets.addAll(mBgDataModel.appWidgets); /** * 从 mBgDataModel 中收集并排序屏幕 ID */ orderedScreenIds.addAll(mBgDataModel.collectWorkspaceScreens()); /** * 复制固定容器中的额外项目 */ mBgDataModel.extraItems.forEach(extraItems::add); if (incrementBindId) { mBgDataModel.lastBindId++; } mMyBindingId = mBgDataModel.lastBindId; workspaceItemCount = mBgDataModel.itemsIdMap.size(); } /** * 批量绑定到前台 * * 遍历回调列表 mCallbacksList，对每个回调实例执行绑定操作 */ for (Callbacks cb : mCallbacksList) { // 创建 UnifiedWorkspaceBinder 实例并调用其 bind 方法 new UnifiedWorkspaceBinder(cb, mUiExecutor, mApp, mBgDataModel, mMyBindingId, workspaceItems, appWidgets, extraItems, orderedScreenIds) .bind(isBindSync, workspaceItemCount); } }} 该函数中，创建了 workspaceItems、appWidgets、orderedScreenIds（屏幕数）等信息的数组。然后创建 UnifiedWorkspaceBinder，调用其 bind() 函数开始绑定。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128📄 源码路径：package/app/Launcher3/src/com/android/launcher3/model/BaseLauncherBinder.javapublic abstract class BaseLauncherBinder { private class UnifiedWorkspaceBinder { /** * 按顺序将工作区中的项目绑定到 UI 上，分批加载当前屏幕和其他屏幕的项目 */ private void bind(boolean isBindSync, int workspaceItemCount) { /** * 获取当前屏幕 ID 集合 */ final IntSet currentScreenIds = mCallbacks.getPagesToBindSynchronously(mOrderedScreenIds); /** * 保获取到的屏幕 ID 集合非空，否则抛出异常 */ Objects.requireNonNull(currentScreenIds, &quot;Null screen ids provided by &quot; + mCallbacks); /** * 筛选当前屏幕的项目： * currentWorkspaceItems: 当前屏幕的应用项目 * otherWorkspaceItems : 其他屏幕的应用项目 * currentAppWidgets : 当前屏幕的小部件 * otherAppWidgets : 其他屏幕的小部件 */ ArrayList&lt;ItemInfo&gt; currentWorkspaceItems = new ArrayList&lt;&gt;(); ArrayList&lt;ItemInfo&gt; otherWorkspaceItems = new ArrayList&lt;&gt;(); ArrayList&lt;LauncherAppWidgetInfo&gt; currentAppWidgets = new ArrayList&lt;&gt;(); ArrayList&lt;LauncherAppWidgetInfo&gt; otherAppWidgets = new ArrayList&lt;&gt;(); /** * 将 mWorkspaceItems 和 mAppWidgets 中的项目分成当前屏幕和其他屏幕的两部分 */ filterCurrentWorkspaceItems(currentScreenIds, mWorkspaceItems, currentWorkspaceItems, otherWorkspaceItems); filterCurrentWorkspaceItems(currentScreenIds, mAppWidgets, currentAppWidgets, otherAppWidgets); /** * 空间排序 * * 获取设备配置文件，包含屏幕布局和网格信息 */ final InvariantDeviceProfile idp = mApp.getInvariantDeviceProfile(); /** * 当前屏幕和其他屏幕的项目分别进行空间排序，确保项目在屏幕上按位置显示 */ sortWorkspaceItemsSpatially(idp, currentWorkspaceItems); sortWorkspaceItemsSpatially(idp, otherWorkspaceItems); /** * 通知 UI 开始绑定 */ executeCallbacksTask(c -&gt; { c.clearPendingBinds(); // 清除 UI 中待绑定的项目，准备新项目的绑定 c.startBinding(); // 通知回调开始绑定操作 }, mUiExecutor); /** * 绑定屏幕 ID */ executeCallbacksTask(c -&gt; c.bindScreens(mOrderedScreenIds), mUiExecutor); /** * 往当前的屏幕上绑定数据内容 * bindWorkspaceItems : 将当前屏幕的应用项目绑定到 UI * bindAppWidgets : 将当前屏幕的小部件绑定到 UI */ bindWorkspaceItems(currentWorkspaceItems, mUiExecutor); bindAppWidgets(currentAppWidgets, mUiExecutor); /** * 绑定额外容器中的项目 */ if (!FeatureFlags.CHANGE_MODEL_DELEGATE_LOADING_ORDER.get()) { mExtraItems.forEach(item -&gt; executeCallbacksTask(c -&gt; c.bindExtraContainerItems(item), mUiExecutor)); } /** * 加载其他屏幕的项目 * * 创建一个 RunnableList 用于收集其他屏幕的项目绑定任务，将任务添加到 pendingTasks 列表 */ RunnableList pendingTasks = new RunnableList(); Executor pendingExecutor = pendingTasks::add; /** * 将其他屏幕的应用项目和小部件绑定到待执行列表，延后显示 */ bindWorkspaceItems(otherWorkspaceItems, pendingExecutor); bindAppWidgets(otherAppWidgets, pendingExecutor); /** * 在其他屏幕的项目加载完成后，通知 UI 绑定已完成 */ executeCallbacksTask(c -&gt; c.finishBindingItems(currentScreenIds), pendingExecutor); /** * 执行异步加载完成操作 */ pendingExecutor.execute( () -&gt; { MODEL_EXECUTOR.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT); ItemInstallQueue.INSTANCE.get(mApp.getContext()) .resumeModelPush(FLAG_LOADER_RUNNING); }); /** * 回调初始绑定完成事件 */ executeCallbacksTask( c -&gt; { MODEL_EXECUTOR.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); c.onInitialBindComplete( currentScreenIds, pendingTasks, workspaceItemCount, isBindSync); }, mUiExecutor); /** * 绑定字符串缓存 */ mCallbacks.bindStringCache(mBgDataModel.stringCache.clone()); } }} UnifiedWorkspaceBinder 的 bind() 函数中，首先拿到当前屏幕（就是呈现给用户的第一个屏幕）ID，然后优先往第一个屏幕上绑定内容，之后再绑定其他屏幕的内容。 绑定屏幕1234567891011121314151617181920212223242526272829303132333435363738📄 源码路径：package/app/Launcher3/src/com/android/launcher3/Launcher.javapublic class Launcher extends StatefulActivity&lt;LauncherState&gt; implements LauncherExterns, Callbacks, InvariantDeviceProfile.OnIDPChangeListener, PluginListener&lt;LauncherOverlayPlugin&gt; { @Override public void bindScreens(IntArray orderedScreenIds) { /** * 义第一个屏幕的位置索引，通常为 0 */ int firstScreenPosition = 0; /** * 调整首屏（默认屏幕）的位置 */ if (FeatureFlags.QSB_ON_FIRST_SCREEN &amp;&amp; orderedScreenIds.indexOf(Workspace.FIRST_SCREEN_ID) != firstScreenPosition) { // 这一操作确保在启用了 QSB_ON_FIRST_SCREEN (Google Search 框)的情况下，默认屏幕始终位于第一个位置 orderedScreenIds.removeValue(Workspace.FIRST_SCREEN_ID); orderedScreenIds.add(firstScreenPosition, Workspace.FIRST_SCREEN_ID); } else if (!FeatureFlags.QSB_ON_FIRST_SCREEN &amp;&amp; orderedScreenIds.isEmpty()) { // 如果特性未启用且没有任何屏幕，则添加一个空屏幕 mWorkspace.addExtraEmptyScreens(); } /** * 将 orderedScreenIds 绑定到工作区，这一步会将屏幕 ID 列表正式添加到 UI 中，使这些屏幕出现在工作区 */ bindAddScreens(orderedScreenIds); /** * 解锁壁纸偏移锁定，确保屏幕布局后壁纸位置正确 */ mWorkspace.unlockWallpaperFromDefaultPageOnNextLayout(); } } 我们继续跟踪 Launcher.bindAddScreens() 方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950📄 源码路径：package/app/Launcher3/src/com/android/launcher3/Launcher.javapublic class Launcher extends StatefulActivity&lt;LauncherState&gt; implements LauncherExterns, Callbacks, InvariantDeviceProfile.OnIDPChangeListener, PluginListener&lt;LauncherOverlayPlugin&gt; { private void bindAddScreens(IntArray orderedScreenIds) { /** * 检查设备配置 mDeviceProfile 是否启用了双面板模式（例如平板或大屏手机在横屏模式下显示左右分屏） * * 这里我们可以暂时不用关注 */ if (mDeviceProfile.isTwoPanels) { // Some empty pages might have been removed while the phone was in a single panel // mode, so we want to add those empty pages back. IntSet screenIds = IntSet.wrap(orderedScreenIds); orderedScreenIds.forEach(screenId -&gt; screenIds.add(mWorkspace.getScreenPair(screenId))); orderedScreenIds = screenIds.getArray(); } /** * 获取屏幕 ID 列表的总数 */ int count = orderedScreenIds.size(); /** * 遍历 orderedScreenIds 中的每个屏幕 ID，依次进行绑定处理 */ for (int i = 0; i &lt; count; i++) { int screenId = orderedScreenIds.get(i); /** * 如果 QSB_ON_FIRST_SCREEN 特性启用，并且当前屏幕 ID 为默认首屏 ID，则跳过绑定 * * 原因：默认首屏在初始化时通常已经绑定，因此无需重复绑定，节省性能开销 */ if (FeatureFlags.QSB_ON_FIRST_SCREEN &amp;&amp; screenId == Workspace.FIRST_SCREEN_ID) { // No need to bind the first screen, as its always bound. continue; } /** * 插入新的屏幕 * * 对于未跳过的屏幕 ID，将屏幕插入到空屏之前。这确保屏幕列表的有序显示，且空屏在屏幕序列的最后显示。 */ mWorkspace.insertNewWorkspaceScreenBeforeEmptyScreen(screenId); } } } 继续跟踪 Workspace.insertNewWorkspaceScreenBeforeEmptyScreen() 方法： 123456789101112131415161718192021222324252627📄 源码路径：package/app/Launcher3/src/com/android/launcher3/Workspace.javapublic class Workspace&lt;T extends View &amp; PageIndicator&gt; extends PagedView&lt;T&gt; implements DropTarget, DragSource, View.OnTouchListener, DragController.DragListener, Insettable, StateHandler&lt;LauncherState&gt;, WorkspaceLayoutManager, LauncherBindableItemsContainer, LauncherOverlayCallbacks { /** * 将新屏幕插入到空屏（如果存在空屏）之前 */ public void insertNewWorkspaceScreenBeforeEmptyScreen(int screenId) { /** * 首先查找 EXTRA_EMPTY_SCREEN_ID 在 mScreenOrder 中的位置 * * mScreenOrder 维护了当前屏幕的顺序 */ int insertIndex = mScreenOrder.indexOf(EXTRA_EMPTY_SCREEN_ID); if (insertIndex &lt; 0) { /** * 如果未找到空屏，表示将新屏幕插入到最后 */ insertIndex = mScreenOrder.size(); } insertNewWorkspaceScreen(screenId, insertIndex); }} 跟踪 Workspace.insertNewWorkspaceScreen() 方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778📄 源码路径：package/app/Launcher3/src/com/android/launcher3/Workspace.javapublic class Workspace&lt;T extends View &amp; PageIndicator&gt; extends PagedView&lt;T&gt; implements DropTarget, DragSource, View.OnTouchListener, DragController.DragListener, Insettable, StateHandler&lt;LauncherState&gt;, WorkspaceLayoutManager, LauncherBindableItemsContainer, LauncherOverlayCallbacks { /** * 负责实际的屏幕布局创建和插入操作 */ public CellLayout insertNewWorkspaceScreen(int screenId, int insertIndex) { /** * 检查屏幕是否已存在 * * 如果 mWorkspaceScreens 中已经存在相同的 screenId，则抛出异常，避免重复插入相同 ID 的屏幕 */ if (mWorkspaceScreens.containsKey(screenId)) { throw new RuntimeException(&quot;Screen id &quot; + screenId + &quot; already exists!&quot;); } /** * 获取设备配置 DeviceProfile，用于决定布局文件的选择 */ DeviceProfile dp = mLauncher.getDeviceProfile(); /** * 定义新的 CellLayout 实例 */ CellLayout newScreen; /** * 选择布局文件，根据特性标志 FOLDABLE_SINGLE_PAGE 和设备是否为双面板模式选择布局文件 * * 折叠设备：如果为折叠屏设备并处于双面板模式，使用 R.layout.workspace_screen_foldable 布局文件 * 普通设备：否则使用标准布局文件 R.layout.workspace_screen */ if (FOLDABLE_SINGLE_PAGE.get() &amp;&amp; dp.isTwoPanels) { newScreen = (CellLayout) LayoutInflater.from(getContext()).inflate( R.layout.workspace_screen_foldable, this, false /* attachToRoot */); } else { newScreen = (CellLayout) LayoutInflater.from(getContext()).inflate( R.layout.workspace_screen, this, false /* attachToRoot */); } /** * 将新创建的 CellLayout 以 screenId 为键添加到 mWorkspaceScreens 映射中 */ mWorkspaceScreens.put(screenId, newScreen); /** * 将 screenId 按顺序插入 mScreenOrder 中，以维护正确的屏幕顺序 */ mScreenOrder.add(insertIndex, screenId); /** * 将新屏幕布局视图插入到 Workspace 视图的 insertIndex 位置 */ addView(newScreen, insertIndex); /** * 根据当前状态为新屏幕应用过渡动画，确保新屏幕以正确的动画效果出现在工作区中 */ mStateTransitionAnimation.applyChildState( mLauncher.getStateManager().getState(), newScreen, insertIndex); /** * 更新页面滚动值，使得页面滚动效果适应新布局 */ updatePageScrollValues(); /** * 整新布局的填充（padding），确保布局之间的间距统一 */ updateCellLayoutPadding(); return newScreen; }} 绑定数据内容123456789101112131415161718192021222324252627282930313233343536373839404142📄 源码路径：package/app/Launcher3/src/com/android/launcher3/model/BaseLauncherBinder.javapublic abstract class BaseLauncherBinder { private class UnifiedWorkspaceBinder { /** * 将工作区中的项目分块绑定到 UI */ private void bindWorkspaceItems( final ArrayList&lt;ItemInfo&gt; workspaceItems, final Executor executor) { /** * 获取 workspaceItems 列表中的项目总数 */ int count = workspaceItems.size(); /** * 分块绑定项目 * * ITEMS_CHUNK 是块大小的常量，用于定义每次绑定的最大项目数量，默认为 6 */ for (int i = 0; i &lt; count; i += ITEMS_CHUNK) { /** * 块的起始位置 */ final int start = i; /** * 当前块的大小 */ final int chunkSize = (i + ITEMS_CHUNK &lt;= count) ? ITEMS_CHUNK : (count - i); /** * 执行绑定任务 */ executeCallbacksTask( c -&gt; c.bindItems(workspaceItems.subList(start, start + chunkSize), false), executor); } } }} 调用 Launcher.bindItems() 方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206📄 源码路径：package/app/Launcher3/src/com/android/launcher3/Launcher.javapublic class Launcher extends StatefulActivity&lt;LauncherState&gt; implements LauncherExterns, Callbacks, InvariantDeviceProfile.OnIDPChangeListener, PluginListener&lt;LauncherOverlayPlugin&gt; { @Override public void bindItems(final List&lt;ItemInfo&gt; items, final boolean forceAnimateIcons) { bindItems(items, forceAnimateIcons, /* focusFirstItemForAccessibility= */ false); } public void bindItems( final List&lt;ItemInfo&gt; items, final boolean forceAnimateIcons, final boolean focusFirstItemForAccessibility) { /** * 用于存储新 Item 的动画效果 */ final Collection&lt;Animator&gt; bounceAnims = new ArrayList&lt;&gt;(); /** * 判断是否允许页面切换动画 */ boolean canAnimatePageChange = canAnimatePageChange(); /** * workspace : 获取工作区引用，便于操作屏幕和布局 * newItemsScreenId : 用于跟踪新项目的屏幕 ID，以便后续页面切换 * newView : 将保存第一个绑定的视图，以便在无障碍模式下获得焦点 */ Workspace&lt;?&gt; workspace = mWorkspace; int newItemsScreenId = -1; int end = items.size(); View newView = null; /** * 遍历 items 列表中的每个 ItemInfo 项目 */ for (int i = 0; i &lt; end; i++) { final ItemInfo item = items.get(i); /** * 如果项目属于 Hotseat 容器，但 mHotseat 为 null，则跳过该项目， * 因为 Hotseat 为空时不能加载这些项目 */ if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT &amp;&amp; mHotseat == null) { continue; } /** * 根据 item 类型创建视图 */ final View view; switch (item.itemType) { // 快捷方式或应用 case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION: case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT: case LauncherSettings.Favorites.ITEM_TYPE_DEEP_SHORTCUT: { WorkspaceItemInfo info = (WorkspaceItemInfo) item; // 创建快捷方式视图 view = createShortcut(info); break; } // 文件夹 case LauncherSettings.Favorites.ITEM_TYPE_FOLDER: { // 创建文件夹视图 view = FolderIcon.inflateFolderAndIcon(R.layout.folder_icon, this, (ViewGroup) workspace.getChildAt(workspace.getCurrentPage()), (FolderInfo) item); break; } // 应用对 case LauncherSettings.Favorites.ITEM_TYPE_APP_PAIR: { FolderInfo info = (FolderInfo) item; // TODO (jeremysim b/274189428): Create app pair icon // 暂未实现绑定逻辑 view = null; break; } // 小部件 case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET: case LauncherSettings.Favorites.ITEM_TYPE_CUSTOM_APPWIDGET: { // 生成小部件视图 view = inflateAppWidget((LauncherAppWidgetInfo) item); if (view == null) { continue; } break; } // 其他类型将抛出异常 default: throw new RuntimeException(&quot;Invalid Item Type&quot;); } /** * 主要处理位置冲突 * * presenterPos: 映射项目在布局中的位置 */ CellPos presenterPos = getCellPosMapper().mapModelToPresenter(item); if (item.container == CONTAINER_DESKTOP) { /** * 检查 CellLayout 中的位置是否已被占用 */ CellLayout cl = mWorkspace.getScreenWithId(presenterPos.screenId); if (cl != null &amp;&amp; cl.isOccupied(presenterPos.cellX, presenterPos.cellY)) { View v = cl.getChildAt(presenterPos.cellX, presenterPos.cellY); if (v == null) { Log.e(TAG, &quot;bindItems failed when removing colliding item=&quot; + item); } Object tag = v.getTag(); String desc = &quot;Collision while binding workspace item: &quot; + item + &quot;. Collides with &quot; + tag; if (FeatureFlags.IS_STUDIO_BUILD) { throw (new RuntimeException(desc)); } else { /** * 从数据库删除冲突项目，避免重复显示 */ getModelWriter().deleteItemFromDatabase(item, desc); continue; } } } /** * 将项目视图添加到工作区的指定屏幕和位置 */ workspace.addInScreenFromBind(view, item); /** * 动画处理 * * 如果 forceAnimateIcons 为 true，为新添加的项目执行动画 */ if (forceAnimateIcons) { // 初始化视图的透明度和缩放，准备动画 view.setAlpha(0f); view.setScaleX(0f); view.setScaleY(0f); // 创建并添加 &quot;弹跳&quot; 动画 bounceAnims.add(createNewAppBounceAnimation(view, i)); newItemsScreenId = presenterPos.screenId; } if (newView == null) { newView = view; } } View viewToFocus = newView; // Animate to the correct pager if (forceAnimateIcons &amp;&amp; newItemsScreenId &gt; -1) { AnimatorSet anim = new AnimatorSet(); anim.playTogether(bounceAnims); /** * 无障碍焦点 */ if (focusFirstItemForAccessibility &amp;&amp; viewToFocus != null) { anim.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { /** * 如果启用了无障碍焦点并且有可聚焦视图，则在动画结束后触发无障碍事件 */ viewToFocus.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_FOCUSED); } }); } /** * 页面切换逻辑 */ int currentScreenId = mWorkspace.getScreenIdForPageIndex(mWorkspace.getNextPage()); final int newScreenIndex = mWorkspace.getPageIndexForScreenId(newItemsScreenId); final Runnable startBounceAnimRunnable = anim::start; if (canAnimatePageChange &amp;&amp; newItemsScreenId != currentScreenId) { // We post the animation slightly delayed to prevent slowdowns // when we are loading right after we return to launcher. mWorkspace.postDelayed(new Runnable() { public void run() { if (mWorkspace != null) { closeOpenViews(false); mWorkspace.snapToPage(newScreenIndex); mWorkspace.postDelayed(startBounceAnimRunnable, NEW_APPS_ANIMATION_DELAY); } } }, NEW_APPS_PAGE_MOVE_DELAY); } else { mWorkspace.postDelayed(startBounceAnimRunnable, NEW_APPS_ANIMATION_DELAY); } } else if (focusFirstItemForAccessibility &amp;&amp; viewToFocus != null) { viewToFocus.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_FOCUSED); } /** * 刷新工作区布局，确保项目正确显示 */ workspace.requestLayout(); }} 跟踪 WorkspaceLayoutManager.addInScreenFromBind() 方法： 123456789101112131415161718192021222324252627282930313233📄 源码路径：package/app/Launcher3/src/com/android/launcher3/WorkspaceLayoutManager.javapublic interface WorkspaceLayoutManager { default void addInScreenFromBind(View child, ItemInfo info) { /** * 将 ItemInfo 的布局信息映射到视图的呈现位置 */ CellPos presenterPos = getCellPosMapper().mapModelToPresenter(info); /** * x 和 y 是项目在工作区布局中的网格坐标，初始值为映射得到的 cellX 和 cellY */ int x = presenterPos.cellX; int y = presenterPos.cellY; /** * 如果 ItemInfo 表示的项目属于 Hotseat 容器，则需要根据 Hotseat 的位置规则来计算准确的坐标 */ if (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT || info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT_PREDICTION) { int screenId = presenterPos.screenId; x = getHotseat().getCellXFromOrder(screenId); y = getHotseat().getCellYFromOrder(screenId); } /** * 将 child 视图添加到工作区中 */ addInScreen(child, info.container, presenterPos.screenId, x, y, info.spanX, info.spanY); }} 跟踪 WorkspaceLayoutManager.addInScreen() 方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138📄 源码路径：package/app/Launcher3/src/com/android/launcher3/WorkspaceLayoutManager.javapublic interface WorkspaceLayoutManager { /** * child ：要添加的视图组件 * container ：容器类型，决定了视图应放置的位置（例如桌面或 Hotseat） * screenId ：屏幕 ID，用于标识视图所在的屏幕 * x/y ：视图在网格中的坐标 * spanX/spanY：视图占用的网格跨度，决定了视图的大小 */ default void addInScreen(View child, int container, int screenId, int x, int y, int spanX, int spanY) { /** * 检查 Desktop 屏幕的有效性 * * 若容器为 Desktop（桌面），首先检查 screenId 是否有效 * 如果对应的屏幕不存在，记录错误信息并打印堆栈跟踪，便于调试，然后直接返回，跳过添加操作 */ if (container == LauncherSettings.Favorites.CONTAINER_DESKTOP) { if (getScreenWithId(screenId) == null) { Log.e(TAG, &quot;Skipping child, screenId &quot; + screenId + &quot; not found&quot;); // DEBUGGING - Print out the stack trace to see where we are adding from new Throwable().printStackTrace(); return; } } /** * 检查是否为额外的空屏 */ if (EXTRA_EMPTY_SCREEN_IDS.contains(screenId)) { // This should never happen throw new RuntimeException(&quot;Screen id should not be extra empty screen: &quot; + screenId); } /** * 根据容器类型（Desktop 或 Hotseat）确定目标布局 */ final CellLayout layout; /** * 容器类型：Hotseat */ if (container == LauncherSettings.Favorites.CONTAINER_HOTSEAT || container == LauncherSettings.Favorites.CONTAINER_HOTSEAT_PREDICTION) { /** * 调用 getHotseat() 获取 Hotseat 布局 */ layout = getHotseat(); /** * 隐藏文件夹图标的标题（FolderIcon） */ if (child instanceof FolderIcon) { ((FolderIcon) child).setTextVisible(false); } } else { /** * 容器类型：Desktop * * 显示文件夹图标的标题 */ if (child instanceof FolderIcon) { ((FolderIcon) child).setTextVisible(true); } /** * 通过 screenId 获取屏幕对应的 CellLayout */ layout = getScreenWithId(screenId); } /** * 设置布局参数 */ ViewGroup.LayoutParams genericLp = child.getLayoutParams(); CellLayoutLayoutParams lp; /** * 新建或重用布局参数 */ if (genericLp == null || !(genericLp instanceof CellLayoutLayoutParams)) { lp = new CellLayoutLayoutParams(x, y, spanX, spanY); } else { lp = (CellLayoutLayoutParams) genericLp; lp.setCellX(x); lp.setCellY(y); lp.cellHSpan = spanX; lp.cellVSpan = spanY; } /** * 是否锁定网格 */ if (spanX &lt; 0 &amp;&amp; spanY &lt; 0) { lp.isLockedToGrid = false; } /** * 获取子视图的唯一 ID * * 获取视图的 ItemInfo 数据，从中提取唯一的 childId，便于后续在布局中标识该视图 */ ItemInfo info = (ItemInfo) child.getTag(); int childId = info.getViewId(); /** * 如果视图是文件夹（Folder），不标记单元格为已占用，否则标记为已占用 */ boolean markCellsAsOccupied = !(child instanceof Folder); /** * 调用 layout.addViewToCellLayout 将视图添加到布局网格中 */ if (!layout.addViewToCellLayout(child, -1, childId, lp, markCellsAsOccupied)) { // 若添加失败（即视图超出网格限制），记录错误日志 Log.e(TAG, &quot;Failed to add to item at (&quot; + lp.getCellX() + &quot;,&quot; + lp.getCellY() + &quot;) to CellLayout&quot;); } /** * 禁用触觉反馈 */ child.setHapticFeedbackEnabled(false); /** * 设置长按监听器，以支持长按操作（通常用于拖放或显示选项） */ child.setOnLongClickListener(getWorkspaceChildOnLongClickListener()); /** * 如果视图是 DropTarget（可拖放的目标），调用 onAddDropTarget 进行注册 */ if (child instanceof DropTarget) { onAddDropTarget((DropTarget) child); } }} 继续跟踪：CellLayout.addViewToCellLayout() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960📄 源码路径：package/app/Launcher3/src/com/android/launcher3/CellLayout.javapublic class CellLayout extends ViewGroup { public boolean addViewToCellLayout(View child, int index, int childId, CellLayoutLayoutParams params, boolean markCells) { /** * 将传入的布局参数 params 赋值给 lp，便于后续使用 */ final CellLayoutLayoutParams lp = params; /** * 处理 Hotseat 图标文本可见性 */ if (child instanceof BubbleTextView) { BubbleTextView bubbleChild = (BubbleTextView) child; bubbleChild.setTextVisibility(mContainerType != HOTSEAT); } /** * 设置视图缩放 */ child.setScaleX(mChildScale); child.setScaleY(mChildScale); /** * 验证并设置位置和跨度 */ if (lp.getCellX() &gt;= 0 &amp;&amp; lp.getCellX() &lt;= mCountX - 1 &amp;&amp; lp.getCellY() &gt;= 0 &amp;&amp; lp.getCellY() &lt;= mCountY - 1) { // If the horizontal or vertical span is set to -1, it is taken to // mean that it spans the extent of the CellLayout if (lp.cellHSpan &lt; 0) lp.cellHSpan = mCountX; if (lp.cellVSpan &lt; 0) lp.cellVSpan = mCountY; /** * 为 child 视图设置唯一的 ID（childId），便于后续操作中唯一标识该视图 */ child.setId(childId); if (LOGD) { Log.d(TAG, &quot;Adding view to ShortcutsAndWidgetsContainer: &quot; + child); } /** * 将视图添加到 mShortcutsAndWidgets（包含所有图标和小部件的容器）中， * 位置由 index 指定，布局参数由 lp 提供 */ mShortcutsAndWidgets.addView(child, index, lp); /** * 标记单元格为已占用，防止其他项目重叠在相同位置 */ if (markCells) markCellsAsOccupiedForView(child); return true; } return false; } } 绑定 Widget12345678910111213141516171819202122232425262728293031📄 源码路径：package/app/Launcher3/src/com/android/launcher3/model/BaseLauncherBinder.javapublic abstract class BaseLauncherBinder { private class UnifiedWorkspaceBinder { private void bindAppWidgets(List&lt;LauncherAppWidgetInfo&gt; appWidgets, Executor executor) { /** * 计算小部件列表的大小，以便在循环中逐个绑定每个小部件 */ int count = appWidgets.size(); /** * 遍历 appWidgets 列表中的每个小部件 */ for (int i = 0; i &lt; count; i++) { /** * 将当前小部件信息保存到 widget 变量中 */ final ItemInfo widget = appWidgets.get(i); /** * 将当前小部件绑定到工作区 */ executeCallbacksTask( c -&gt; c.bindItems(Collections.singletonList(widget), false), executor); } } }} 调用 Launcher.bindItems() 方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152📄 源码路径：package/app/Launcher3/src/com/android/launcher3/Launcher.javapublic class Launcher extends StatefulActivity&lt;LauncherState&gt; implements LauncherExterns, Callbacks, InvariantDeviceProfile.OnIDPChangeListener, PluginListener&lt;LauncherOverlayPlugin&gt; { public void bindItems( final List&lt;ItemInfo&gt; items, final boolean forceAnimateIcons, final boolean focusFirstItemForAccessibility) { ... /** * 遍历 items 列表中的每个 ItemInfo 项目 */ for (int i = 0; i &lt; end; i++) { final ItemInfo item = items.get(i); ... /** * 根据 item 类型创建视图 */ final View view; switch (item.itemType) { ... // 小部件 case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET: case LauncherSettings.Favorites.ITEM_TYPE_CUSTOM_APPWIDGET: { // 生成小部件视图 view = inflateAppWidget((LauncherAppWidgetInfo) item); if (view == null) { continue; } break; } // 其他类型将抛出异常 default: throw new RuntimeException(&quot;Invalid Item Type&quot;); } ... } ... /** * 刷新工作区布局，确保项目正确显示 */ workspace.requestLayout(); }} 所以我们继续跟踪 inflateAppWidget() 方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186📄 源码路径：package/app/Launcher3/src/com/android/launcher3/Launcher.javapublic class Launcher extends StatefulActivity&lt;LauncherState&gt; implements LauncherExterns, Callbacks, InvariantDeviceProfile.OnIDPChangeListener, PluginListener&lt;LauncherOverlayPlugin&gt; { private View inflateAppWidget(LauncherAppWidgetInfo item) { /** * 搜索小部件处理 */ if (item.hasOptionFlag(LauncherAppWidgetInfo.OPTION_SEARCH_WIDGET)) { item.providerName = QsbContainerView.getSearchComponentName(this); if (item.providerName == null) { getModelWriter().deleteItemFromDatabase(item, &quot;search widget removed because search component cannot be found&quot;); return null; } } final AppWidgetHostView view; /** * 如果设备处于安全模式，使用 PendingAppWidgetHostView 创建一个挂起的小部件视图，并返回该视图 */ if (mIsSafeModeEnabled) { view = new PendingAppWidgetHostView(this, item, mIconCache, true); prepareAppWidget(view, item); return view; } /** * 性能跟踪初始化 */ Object traceToken = TraceHelper.INSTANCE.beginSection(&quot;BIND_WIDGET_id=&quot; + item.appWidgetId); /** * 绑定小部件的状态检查与处理 */ try { final LauncherAppWidgetProviderInfo appWidgetInfo; String removalReason = &quot;&quot;; /** * 表示小部件提供者未准备好 */ if (item.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY)) { // If the provider is not ready, bind as a pending widget. appWidgetInfo = null; removalReason = &quot;the provider isn't ready.&quot;; } else if (item.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_ID_NOT_VALID)) { /** * 小部件 ID 无效，，根据 providerName 找到小部件的提供者 */ appWidgetInfo = mAppWidgetManager.findProvider(item.providerName, item.user); if (appWidgetInfo == null) { if (WidgetsModel.GO_DISABLE_WIDGETS) { removalReason = &quot;widgets are disabled on go device.&quot;; } else { removalReason = &quot;WidgetManagerHelper cannot find a provider from provider info.&quot;; } } } else { /** * 正常绑定 */ appWidgetInfo = mAppWidgetManager.getLauncherAppWidgetInfo(item.appWidgetId); if (appWidgetInfo == null) { if (item.appWidgetId &lt;= LauncherAppWidgetInfo.CUSTOM_WIDGET_ID) { removalReason = &quot;CustomWidgetManager cannot find provider from that widget id.&quot;; } else { removalReason = &quot;AppWidgetManager cannot find provider for that widget id.&quot; + &quot; It could be because AppWidgetService is not available, or the&quot; + &quot; appWidgetId has not been bound to a the provider yet, or you&quot; + &quot; don't have access to that appWidgetId.&quot;; } } } // If the provider is ready, but the width is not yet restored, try to restore it. if (!item.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY) &amp;&amp; (item.restoreStatus != LauncherAppWidgetInfo.RESTORE_COMPLETED)) { if (appWidgetInfo == null) { getModelWriter().deleteItemFromDatabase(item, &quot;Removing restored widget: id=&quot; + item.appWidgetId + &quot; belongs to component &quot; + item.providerName + &quot; user &quot; + item.user + &quot;, as the provider is null and &quot; + removalReason); return null; } // If we do not have a valid id, try to bind an id. if (item.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_ID_NOT_VALID)) { if (!item.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_ID_ALLOCATED)) { // Id has not been allocated yet. Allocate a new id. item.appWidgetId = mAppWidgetHolder.allocateAppWidgetId(); item.restoreStatus |= LauncherAppWidgetInfo.FLAG_ID_ALLOCATED; // Also try to bind the widget. If the bind fails, the user will be shown // a click to setup UI, which will ask for the bind permission. PendingAddWidgetInfo pendingInfo = new PendingAddWidgetInfo(appWidgetInfo, item.sourceContainer); pendingInfo.spanX = item.spanX; pendingInfo.spanY = item.spanY; pendingInfo.minSpanX = item.minSpanX; pendingInfo.minSpanY = item.minSpanY; Bundle options = pendingInfo.getDefaultSizeOptions(this); boolean isDirectConfig = item.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_DIRECT_CONFIG); if (isDirectConfig &amp;&amp; item.bindOptions != null) { Bundle newOptions = item.bindOptions.getExtras(); if (options != null) { newOptions.putAll(options); } options = newOptions; } boolean success = mAppWidgetManager.bindAppWidgetIdIfAllowed( item.appWidgetId, appWidgetInfo, options); // We tried to bind once. If we were not able to bind, we would need to // go through the permission dialog, which means we cannot skip the config // activity. item.bindOptions = null; item.restoreStatus &amp;= ~LauncherAppWidgetInfo.FLAG_DIRECT_CONFIG; // Bind succeeded if (success) { // If the widget has a configure activity, it is still needs to set it // up, otherwise the widget is ready to go. item.restoreStatus = (appWidgetInfo.configure == null) || isDirectConfig ? LauncherAppWidgetInfo.RESTORE_COMPLETED : LauncherAppWidgetInfo.FLAG_UI_NOT_READY; } getModelWriter().updateItemInDatabase(item); } } else if (item.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_UI_NOT_READY) &amp;&amp; (appWidgetInfo.configure == null)) { // The widget was marked as UI not ready, but there is no configure activity to // update the UI. item.restoreStatus = LauncherAppWidgetInfo.RESTORE_COMPLETED; getModelWriter().updateItemInDatabase(item); } else if (item.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_UI_NOT_READY) &amp;&amp; appWidgetInfo.configure != null) { if (mAppWidgetManager.isAppWidgetRestored(item.appWidgetId)) { item.restoreStatus = LauncherAppWidgetInfo.RESTORE_COMPLETED; getModelWriter().updateItemInDatabase(item); } } } /** * 小部件视图创建与返回 */ if (item.restoreStatus == LauncherAppWidgetInfo.RESTORE_COMPLETED) { // Verify that we own the widget if (appWidgetInfo == null) { FileLog.e(TAG, &quot;Removing invalid widget: id=&quot; + item.appWidgetId); getModelWriter().deleteWidgetInfo(item, getAppWidgetHolder(), removalReason); return null; } item.minSpanX = appWidgetInfo.minSpanX; item.minSpanY = appWidgetInfo.minSpanY; view = mAppWidgetHolder.createView(this, item.appWidgetId, appWidgetInfo); } else if (!item.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_ID_NOT_VALID) &amp;&amp; appWidgetInfo != null) { mAppWidgetHolder.addPendingView(item.appWidgetId, new PendingAppWidgetHostView(this, item, mIconCache, false)); view = mAppWidgetHolder.createView(this, item.appWidgetId, appWidgetInfo); } else { view = new PendingAppWidgetHostView(this, item, mIconCache, false); } /** * 小部件准备 */ prepareAppWidget(view, item); } finally { TraceHelper.INSTANCE.endSection(traceToken); } return view; }}","link":"/2024/10/25/Android%20--%20Launcher3%20--%2002.%20%E6%8F%AD%E5%BC%80%20LoaderTask%20%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E5%A5%A5%E7%A7%98%20--%20workspace/"},{"title":"解析 Modifier、CombinedModifier","text":"# 前言众所周知：原理性分析的文章，真的很难讲的通俗易懂，讲的简单了就没必要写了，讲的繁琐杂乱往往大家也不乐意看，所以只能尽量找个好的角度（比如从 Demo 代码示例出发）慢慢带着大家去钻源码，如果确实能帮助到大家理解清楚原理，那就点个赞呗～😄 在正式开始分析 Modifier 相关原理之前，建议你先看看 【Compose 是如何将数据转换成 UI 的？】这篇文章，当你了解了 Compose 的“组合”、“布局”、“绘制”的思维模型后，有助于你更透彻的了解 Modifier 的本质！ 一、什么是 Modifier ？ 当你想深入了解 Modifier 的时候，你应该已经在实际代码中用起来了，因为随处可见各种 Modifier，比如： 12345678Modifier.size() // 尺寸Modifier.width() // 宽度Modifier.height() // 高度Modifier.padding() // 间距Modifier.background() // 背景Modifier.clip() // 裁切Modifier.clickable() // 点击... ... 那么你有没有思考过一个问题：这个像根部（起点）一样的 Modifier 是个啥？ 我们来看下它的定义： 12345678910111213141516📄 androidx.compose.ui.Modifier.ktinterface Modifier { // 重点：申明一个 Modifier 的伴生对象（单例对象） companion object : Modifier { // 里面全部都是最简单的实现，这里面的方法我们后面会详细了解到，暂时不用关心 override fun &lt;R&gt; foldIn(initial: R, operation: (R, Element) -&gt; R): R = initial override fun &lt;R&gt; foldOut(initial: R, operation: (Element, R) -&gt; R): R = initial override fun any(predicate: (Element) -&gt; Boolean): Boolean = false override fun all(predicate: (Element) -&gt; Boolean): Boolean = true override infix fun then(other: Modifier): Modifier = other override fun toString() = &quot;Modifier&quot; }} 所以如果你单写一个 Modifier，就可以获取到一个最简单的 Modifier 接口的对象（即伴生对象），它的作用就是作为一个起点用于链式调用。 OK，现在我们来看一段简单的代码： 12345678910111213141516class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Custom() } } }}@Composablefun Custom() { Box(Modifier.size(40.dp).background(Color.Blue)) {}} 这里我们自定义了一个 Composable 函数 custom()，内部就是一个 Box，同时对 Box 添加了尺寸和背景。 效果如下： ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/16dd22b4cc9a4a60ba2254adb18083d2.png =600x) 现在我们定义的这个 Custom() 就是一个通用的可组合函数，如果现在我希望外部调用这个 Custom 函数的时候可以从外部去改变 Box 的透明度，该怎么写？ 我们可能会很自然的写出下面的代码： 12345678910111213141516class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Custom(modifier = Modifier.alpha(0.5f)) } } }}@Composablefun Custom(modifier: Modifier) { Box(modifier.size(40.dp).background(Color.Blue)) {}} 这段代码不难理解吧？效果如下： ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/3f609adcc58d4f30b3b31b42e004d92a.png =600x) 我们可以给 Custom() 加一个 Modifier 类型的参数，这样外部就可以通过传入一个 Modifier 来修改 Box 的尺寸了。 但是这就会存在一个问题：现在外部调用 custom() ，就必须传入一个 Modifier，这就不合理了，相当于强制要求外部必须加这个 Modifier 参数，所以针对这种情况，我们一般会像下面这么写： 1234567891011121314151617class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Custom(modifier = Modifier.alpha(0.5f)) // 传了，custom 就用传入的 Modifier Custom() // 不传，custom 就用默认的 Modifier } } }}@Composablefun Custom(modifier: Modifier = Modifier) { // 设定一个默认的 Modifier，作为一个占位符使用 Box(modifier.size(40.dp).background(Color.Blue)) {}} 现在是不是就能解决我们前面的问题了？请记住：这是一个很标准的写法！ 为什么说是一个标准写法呢？ 我们看下 Box 的源码定义： 1234567@Composableinline fun Box( modifier: Modifier = Modifier, // 这里 contentAlignment: Alignment = Alignment.TopStart, propagateMinConstraints: Boolean = false, content: @Composable BoxScope.() -&gt; Unit) 再换一个 Button 看看： 1234567@Composablefun Button( onClick: () -&gt; Unit, modifier: Modifier = Modifier, // 这里 enabled: Boolean = true, ... ...) 再换一个 Column 看看： 1234567@Composableinline fun Column( modifier: Modifier = Modifier, // 这里 verticalArrangement: Arrangement.Vertical = Arrangement.Top, horizontalAlignment: Alignment.Horizontal = Alignment.Start, content: @Composable ColumnScope.() -&gt; Unit) Compose 默认提供的函数的参数也是这种标准写法，所以以后我们写自定义的 Compose 函数，按照这种标准写法就会很方便。 二、Modifier 链 所谓的「 Modifier 链 」其实就是类似「 Modifier.padding().background() 」这样的链式调用。在实际开发过程中，这种链式调用对顺序的敏感度还是很强的，不同的调用顺序显示出来的结果会完全不一样。 接下来我们结合实际代码深入分析 Modifier 链的创建步骤。 1234567891011class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.background(Color.Blue)) } } }} 前面你应该知道了 Modifier 是什么了，它就相当于一个白板，现在我们来看看 Modifier.background() 做了什么： 123456789101112131415161718192021📄 androidx.compose.foundation.Background.ktfun Modifier.background( color: Color, shape: Shape = RectangleShape): Modifier { val alpha = 1.0f // for solid colors return this.then( // this：就是 Modifier，这里又调用了 then() BackgroundElement( color = color, shape = shape, alpha = alpha, inspectorInfo = debugInspectorInfo { name = &quot;background&quot; value = color properties[&quot;color&quot;] = color properties[&quot;shape&quot;] = shape } ) )} 我们可以发现 Modifier.backgroud 实际上又调用了 this.then(BackgroundElement())，此时 this 指针指向的是伴生对象 Modifier，接下来我们看看 then() 做了什么。 12345678📄 androidx.compose.ui.Modifier.ktinterface Modifier { infix fun then(other: Modifier): Modifier = if (other === Modifier) this else CombinedModifier(this, other) } 我们可以看到 then() 是有参数的，它的参数也是一个 Modifier 类型的，所以传递进来的 BackgroundElement() 也是一个 Modifier 吗？ 我们来看下它的定义： 123456789📄 androidx.compose.foundation.Background.ktprivate class BackgroundElement( private val color: Color = Color.Unspecified, private val brush: Brush? = null, private val alpha: Float, private val shape: Shape, private val inspectorInfo: InspectorInfo.() -&gt; Unit) : ModifierNodeElement&lt;BackgroundNode&gt;() {} 123📄 androidx.compose.ui.node.ModifierNodeElement.ktabstract class ModifierNodeElement&lt;N : Modifier.Node&gt;: Modifier.Element, InspectableValue {} 123📄 androidx.compose.ui.Modifier.ktinterface Element : Modifier {} 回归主题，现在我们再来看看 then() 的作用：它主要负责把调用的 Modifier（左边）和参数传入的 Modifier（右边）进行合并的。 1. if (other === Modifier) this 如果参数是一个最基本的 Modifier 伴生对象：**companion object**，则返回自己，即调用者。 比如我这么写： 123Box(Modifier.background(Color.Blue).then(Modifier))==&gt;就会直接返回 Box(Modifier.background(Color.Blue) 自身 那我们例子里的 Modifier.background() 返回的是什么呢？ 1234567891011121314151617Box(Modifier.background(Color.Blue))/** * 此时 then(Background()) 很明显不满足 other === Modifier 的条件 * 所以根据判断条件： * if (other === Modifier) this else CombinedModifier(this, other) * 此时应该走到 else 分支，执行 CombinedModifier(this, other) * * 是吗？ 🤔🤔🤔🤔🤔🤔🤔 * * 我们来回顾一下 Modifier 这个伴生对象，如果你够仔细的话，应该注意到了： * 它内部覆写了 then() 方法 */companion object : Modifier { ... override infix fun then(other: Modifier): Modifier = other} Modifier 内部对 then() 的操作极其简单：你传进来什么，我就给你返回什么！ 所以 Modifier.background() 这种调用方本身就是一个伴生对象的情况，会走到它自己内部的 then() 方法，返回的是 Background() 自身。 ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/b63c990911014b76ae4ed3e475ac7471.png =700x) 此时 Modifier 链的数据结构如下： ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/f6c97b32c44f4360a02dfc34cbfe9316.png =800x) 如果“调用者”和“传进来的参数”都不是 Modifier 伴生对象的话，就会走到下面一个条件。 2. else CombinedModifier(this, other) 调用 CombinedModifier() 进行两个 Modifier 的融合，并返回 CombinedModifier 自身。 比如我们现在再添加一个尺寸： 1Box(Modifier.background(Color.Blue).size(40.dp)) 查看 size() 函数： 12345678910111213141516📄 androidx.compose.foundation.layout.Size.kt@Stablefun Modifier.size(size: Dp) = this.then( SizeElement( minWidth = size, maxWidth = size, minHeight = size, maxHeight = size, enforceIncoming = true, inspectorInfo = debugInspectorInfo { name = &quot;size&quot; value = size } )) 这个时候的 this 就是 Background() 了（也就是 **BackgroudElement**），而 then() 内部的参数又是一个 **SizeElement**，所以就要用到 CombinedModifier 进行融合了。 我们来看下 CombinedModifier： 123456📄 androidx.compose.ui.Modifier.ktclass CombinedModifier( internal val outer: Modifier, internal val inner: Modifier) : Modifier {} CombinedModifier 具体怎么融合的，我们先不需要关注，下面会讲。 我们这里主要关注它的两个参数：「 outer 」 和 「 inner 」! 所以：**BackgroudElement** 是 outer，SizeElement 是 inner ！ 此时 Modifier 链的数据结构如下： ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/7717a13e88384c028f6ad40fee761422.png =800x) 现在我们再添加一个边距： 1Box(Modifier.background(Color.Blue).size(40.dp).padding(10.dp)) 查看 padding() 函数： 1234567891011121314📄 androidx.compose.foundation.layout.Padding.kt@Stablefun Modifier.padding(all: Dp) = this then PaddingElement( start = all, top = all, end = all, bottom = all, rtlAware = true, inspectorInfo = { name = &quot;padding&quot; value = all }) 这个时候的 this 指向的是 CombinedModifier 实例，而 then() 内部的参数又是一个 PaddingElement，所以又要用到 CombinedModifier 进行融合了。 此时 Modifier 链的数据结构如下： ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/89bbcf0f9dc34902a494ec79c33e9d31.png =800x) 到这里，你有没有发现？Modifier 链条内部都有一个 then() 作为最外层调用，它就相当于一个套子，打造一个一环套一环的链条。 三、CombinedModifier 现在我们开始正式研究 CombinedModifier 的源码本质！ 1234class CombinedModifier( internal val outer: Modifier, internal val inner: Modifier) : Modifier 前面我们知道了：CombinedModifier 连接的两个 Modifier 分别存储在 outer 与 inner 中，而 Compose 对 Modifier 的遍历，其实就是从外（outer）到内（inner）一层层访问的。 需要注意的是， outer 与 innner 字段都被 internal 关键字申明，意味着不能被外部模块直接访问，但官方为我们提供了 foldOut() 与 foldIn() 专门用来遍历 Modifier 链。 123456789101112131415161718192021222324252627📄 androidx.compose.ui.Modifier.ktclass CombinedModifier( internal val outer: Modifier, internal val inner: Modifier) : Modifier { override fun &lt;R&gt; foldIn(initial: R, operation: (R, Modifier.Element) -&gt; R): R = inner.foldIn(outer.foldIn(initial, operation), operation) // 正向遍历 override fun &lt;R&gt; foldOut(initial: R, operation: (Modifier.Element, R) -&gt; R): R = outer.foldOut(inner.foldOut(initial, operation), operation) // 反向遍历 override fun any(predicate: (Modifier.Element) -&gt; Boolean): Boolean = outer.any(predicate) || inner.any(predicate) // 或运算 override fun all(predicate: (Modifier.Element) -&gt; Boolean): Boolean = outer.all(predicate) &amp;&amp; inner.all(predicate) // 与运算 override fun equals(other: Any?): Boolean = other is CombinedModifier &amp;&amp; outer == other.outer &amp;&amp; inner == other.inner override fun hashCode(): Int = outer.hashCode() + 31 * inner.hashCode() override fun toString() = &quot;[&quot; + foldIn(&quot;&quot;) { acc, element -&gt; if (acc.isEmpty()) element.toString() else &quot;$acc, $element&quot; } + &quot;]&quot;} 例如我们之前写的 Modifier 链： 1Modifier.background(Color.Blue).size(40.dp).padding(10.dp) foldIn()：正向遍历 Modifier 链&nbsp;BackgroundElement -&gt; SizeElement -&gt; PaddingElement foldOut()：反向遍历 Modifier 链&nbsp;PaddingElement -&gt; SizeModifier -&gt; BackgroundElement foldIn() 解析 你应该也发现了，CombinedModifier 本身就是 Modifier 接口的实现类，它内部的 foldIn、foldOut 都是覆写了其父接口 Modifier 的内部方法，所以我们可以先来看看 Modifier 的 foldIn（因为它更简单）： 123interface Modifier { fun &lt;R&gt; foldIn(initial: R, operation: (R, Element) -&gt; R): R} 让我们分析一下这个 foldIn 函数： fun &lt;R&gt;：这是一个泛型函数，类型参数 R 表示结果的类型。 initial: R：作为累积操作的初始值，foldIn 从这个值开始，并在每次操作中更新它。 operation: (R, Element) -&gt; R：这是一个 lambda 表达式参数，它接受当前的累积值和修饰符链中的当前元素 Element，然后返回新的累积值。这个 lambda 表达式会被应用于修饰符链中的每一个元素。 举个例子，比如说我们希望统计 Modifier 链中 Modifier 的数量： 123456789val modifier = Modifier .background(Color.Blue) .size(40.dp) .padding(10.dp)val result = modifier.foldIn&lt;Int&gt;(0) { currentIndex, element -&gt; println(&quot;@@@ index: $currentIndex , element :$element&quot;) currentIndex + 1}println(&quot;@@@ result = $result&quot;) 看不懂？那我们直接看 Log： 1234@@@ index: 0 , element :androidx.compose.foundation.BackgroundElement@52227b59@@@ index: 1 , element :androidx.compose.foundation.layout.SizeElement@780004cf@@@ index: 2 , element :androidx.compose.foundation.layout.PaddingElement@b80004cf@@@ result = 3 看完最简单的 foldIn 函数，我们再来看 CombinedModifier 的 foldIn 函数： 123456// Modifier 接口的 foldIn 函数fun &lt;R&gt; foldIn(initial: R, operation: (R, Element) -&gt; R): R// Combinedmodifier 覆写的 foldIn 函数override fun &lt;R&gt; foldIn(initial: R, operation: (R, Modifier.Element) -&gt; R): R = inner.foldIn(outer.foldIn(initial, operation), operation) 看不懂是么？不急，你先来想想 Modifier 链条经过 CombinedModifier 转换后，是不是下面这个样子： 123456789101112131415161718192021222324252627Modifier.background(Color.Blue).size(40.dp).padding(10.dp)// 分步骤拆解1. Modifier.background(Color.Blue) ==&gt; 等同于 Modifier.then(Modifier.background()) ==&gt; Modifier.background()2. Modifier.background(Color.Blue).size(40.dp) ==&gt; 等同于 Modifier.background().then(Modifier.size()) ==&gt; 等同于 CombinedModifier [ outer: Modifier.background(), inner: Modifier.size() ]3. Modifier.background(Color.Blue).size(40.dp).padding(10.dp) ==&gt; 等同于 Modifier.background().then(Modifier.size()).then(Modifier.padding()) ==&gt; 等同于 CombinedModifier [ outer: CombinedModifier [ outer: Modifier.background(), inner: Modifier.size() ], inner: Modifier.padding() ] 再看个示例图，可能会更直观点： 现在再看 CombinedModifier 的 foldIn 函数： 12override fun &lt;R&gt; foldIn(initial: R, operation: (R, Modifier.Element) -&gt; R): R = inner.foldIn(outer.foldIn(initial, operation), operation) 在这个 foldIn 实现中，可以看到处理修饰符链的过程是递归的和分层的。让我们逐步解析这个函数： initial: R：是累积操作的初始值。 operation: (R, Modifier.Element) -&gt; R：是一个应用于每一个 Modifier.Element 的高阶函数，它接受两个参数：当前的累积值和 Modifier 的一个元素，并返回新的累积值。 inner.foldIn(outer.foldIn(initial, operation), operation)：将上一步的结果作为它的初始值，并在 inner 修改器链上执行相同的 operation 函数。 感觉好复杂啊，没关系不慌，看图： 到这里我们再来回顾下刚才统计 Modifier 数量的例子： 123456789val modifier = Modifier .background(Color.Blue) .size(40.dp) .padding(10.dp)val result = modifier.foldIn&lt;Int&gt;(0) { currentIndex, element -&gt; println(&quot;@@@ index: $currentIndex , element :$element&quot;) currentIndex + 1}println(&quot;@@@ result = $result&quot;) Log 如下： 1234@@@ index: 0 , element :androidx.compose.foundation.BackgroundElement@52227b59@@@ index: 1 , element :androidx.compose.foundation.layout.SizeElement@780004cf@@@ index: 2 , element :androidx.compose.foundation.layout.PaddingElement@b80004cf@@@ result = 3 现在是不是就能毫无压力的看明白了？再来一张图： foldOut() 解析 与 foldIn() 相反， 我们就不再单独展开分析它的参数了，还是以前面统计 Modifier 个数的例子看下 Log 输出： 1234567891011val modifier = Modifier .background(Color.Blue) .size(40.dp) .padding(10.dp)val result = modifier.foldOut&lt;Int&gt;(0) { element, currentIndex -&gt; println(&quot;@@@ index: $currentIndex , element :$element&quot;) currentIndex + 1}println(&quot;@@@ result = $result&quot;) 看下 Log： 1234@@@ index: 0 , element :androidx.compose.foundation.layout.PaddingElement@b80004cf@@@ index: 1 , element :element :androidx.compose.foundation.layout.SizeElement@780004cf@@@ index: 2 , element :element :androidx.compose.foundation.BackgroundElement@52227b59@@@ result = 3 是不是反过来的？另外注意 lambda 表达式内部的参数位置与 foldIn() 是反着来的，其它没有任何区别。 📓 Modifier.Element 在 Modifier 整个体系里面，有很多 Modifier 接口的子接口和实现类，除了我们之前提过的 companion object 伴生对象和 CombinedModifier 类之外，其他所有的 Modifier，不管是接口还是实现类，全部都直接或者间接的继承了 Modifier 的另外一个子接口：Element。 ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/2d30a20773f432e69488d2a94461fc1f.png#pic_center =700x) 比如我们前面遇到的 Background 背后的 BackgroundElement： 123456789private class BackgroundElement( private val color: Color = Color.Unspecified, private val brush: Brush? = null, private val alpha: Float, private val shape: Shape, private val inspectorInfo: InspectorInfo.() -&gt; Unit) : ModifierNodeElement&lt;BackgroundNode&gt;() {abstract class ModifierNodeElement&lt;N : Modifier.Node&gt; : Modifier.Element ... 又比如 SizeModifier： 12345678910private class SizeElement( private val minWidth: Dp = Dp.Unspecified, private val minHeight: Dp = Dp.Unspecified, private val maxWidth: Dp = Dp.Unspecified, private val maxHeight: Dp = Dp.Unspecified, private val enforceIncoming: Boolean, private val inspectorInfo: InspectorInfo.() -&gt; Unit) : ModifierNodeElement&lt;SizeNode&gt;() {abstract class ModifierNodeElement&lt;N : Modifier.Node&gt; : Modifier.Element ... 又比如 PaddingModifier： 12345678910private class PaddingElement( var start: Dp = 0.dp, var top: Dp = 0.dp, var end: Dp = 0.dp, var bottom: Dp = 0.dp, var rtlAware: Boolean, val inspectorInfo: InspectorInfo.() -&gt; Unit) : ModifierNodeElement&lt;PaddingNode&gt;() {abstract class ModifierNodeElement&lt;N : Modifier.Node&gt; : Modifier.Element ... 你会发现它们的根统统都是 Modifier.Element 这个接口。 像这类直接子接口或子类还有哪些呢，如图所示，这些接口和子类基本涵盖了 Modifier 所提供的所有能力。 ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/819a9fe1dc5621332ae5d280fa1c3c33.png#pic_center =500x)","link":"/2024/09/06/Compose%20--%20Modifier%20--%2001.%20%E8%A7%A3%E6%9E%90%20Modifier%20&%20CombinedModifier/"},{"title":"解析 ComposedModifier","text":"# 前言众所周知：原理性分析的文章，真的很难讲的通俗易懂，讲的简单了就没必要写了，讲的繁琐杂乱往往大家也不乐意看，所以只能尽量找个好的角度（比如从 Demo 代码示例出发）慢慢带着大家去钻源码，如果确实能帮助到大家理解清楚原理，那就点个赞呗～😄 在正式开始分析这篇文章的主角之前，建议你先看看 【深度解析 Compose 的 Modifier 原理 – Modifier、CombinedModifier】 一文，作为 Modifier 原理系列的第一篇开山之作，它是一个根，必须掌握！ 我们直接进入主题，查看 ComposedModifier 源码： 123456📄 androidx.compose.ui.ComposedModifier.ktprivate open class ComposedModifier( inspectorInfo: InspectorInfo.() -&gt; Unit, val factory: @Composable Modifier.() -&gt; Modifier) : Modifier.Element, InspectorValueInfo(inspectorInfo) 细心的你会发现 ComposedModifier 是个私有函数，你是没有办法直接创建的。所以如果我们要创建一个 ComposedModifier，则需要使用 Modifier.composed() 扩展函数： 1234567891011class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Modifier.composed { } } } }} 这样，Modifier.composed() 扩展函数会帮我们创建出一个 ComposedModifier。 12345678📄 androidx.compose.ui.ComposedModifier.ktfun Modifier.composed( inspectorInfo: InspectorInfo.() -&gt; Unit = NoInspectorInfo, factory: @Composable Modifier.() -&gt; Modifier): Modifier = this.then(ComposedModifier(inspectorInfo, factory))==&gt; this.then() ... 熟悉吧？是不是得到了一个 ComposedModifier？ 看到这里，你应该会有疑问三连了： 🤔🤔 ComposedModifier 是个啥？ 🤔🤔 为什么要创建一个 ComposedModifier ？ 🤔🤔 什么时候又该创建一个 ComposedModifier ？ 带着这三个疑问，我们开始继续探讨 ComposedModifier 的精髓 … … 首先我直接告诉你 ComposedModifier 的作用：ComposedModifier 的作用是通过 factory 工厂函数在组合过程中执行 factory 创建出 Modifier 并使用。 这段定义看不懂没关系，跟着我的节奏来，比如看下面这段简单的代码示例： 1234567891011class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Modifier.padding(10.dp) } } }} 正常情况下这么写，当执行到 Modifier.padding() 的时候，会立即创建出一个 PaddingElement，这个你应该很清楚了，如果不了解，可以先阅读 【 深度解析 Compose 的 Modifier 原理 – Modifier、CombinedModifier 】这篇文章。 现在我调整下代码： 1234567891011class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Modifier.composed { Modifier.padding(10.dp) } } } }} 这里我把 Modifier.padding() 给包进了 ComposedModifier 里面，那么当程序执行到这段代码的时候，你觉得 Modifier.padding() 还会立即执行吗？ 再回顾一遍 ComposedModifier 的定义：ComposedModifier 的作用是通过 factory 工厂函数在组合过程中执行 factory 创建出 Modifier 并使用。 这个时候我们可以拆分下定义了，主要就是两个核心： 组合过程中 执行 factory 创建出 Modifier 先来看下第二点，我们其实从刚刚 Modifier.composed 函数定义就能看出来了： 那么第一点：组合过程中，该如何理解？其实很好理解，你既然创建了 Modifier，肯定要用起来，那么我们就来看看在组合过程中 ComposedModifier 是如何发挥作用的。 我现在再来改下代码： 1234567891011class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.composed { Modifier.padding(10.dp) }) } } }} 再来看一遍 ComposedModifier 的定义：ComposedModifier 的作用是通过 factory 工厂函数在组合过程时执行 factory 创建出 Modifier 并使用。 所以现在我们就来看看 Box() 内部是在哪里执行 factory 工厂函数的。 跳转到 Box()： 123456📄 androidx.compose.foundation.layout.Box.kt@Composablefun Box(modifier: Modifier) { Layout({}, measurePolicy = EmptyBoxMeasurePolicy, modifier = modifier)} 跳转到 Layout()： 1234567891011121314151617181920212223📄 androidx.compose.ui.layout.Layout.kt@Composable inline fun Layout( content: @Composable @UiComposable () -&gt; Unit, modifier: Modifier = Modifier, measurePolicy: MeasurePolicy) { ... ... ReusableComposeNode&lt;ComposeUiNode, Applier&lt;Any&gt;&gt;( ... ... skippableUpdate = materializerOf(modifier), content = content )}@PublishedApiinternal fun materializerOf( modifier: Modifier): @Composable SkippableUpdater&lt;ComposeUiNode&gt;.() -&gt; Unit = { val compositeKeyHash = currentCompositeKeyHash val materialized = currentComposer.materialize(modifier) ... ...} 跳转 materialize() 12345678910111213141516171819202122📄 androidx.compose.ui.ComposedModifier.ktfun Composer.materialize(modifier: Modifier): Modifier { if (modifier.all { it !is ComposedModifier }) { return modifier } val result = modifier.foldIn&lt;Modifier&gt;(Modifier) { acc, element -&gt; acc.then( if (element is ComposedModifier) { @Suppress(&quot;UNCHECKED_CAST&quot;) val factory = element.factory as Modifier.(Composer, Int) -&gt; Modifier val composedMod = factory(Modifier, this, 0) materialize(composedMod) } else { element } ) } return result} 好熟悉呀，出现了 foldIn()！我们来解读一下这段代码： 这么一分解，现在你应该很清楚 ComposedModifer 的工厂函数在哪里调用了吧？ 但是问题又来了，这么费劲搞一个 ComposedModifier 有啥意义？ 12Box(Modifier.composed { Modifier.padding(10.dp) })Box(Modifier.padding(10.dp) // 我这么写不就行了？ 我们来看下 Modifier.composed 函数的说明： 注意几个关键词：1. stateful modifiers：有状态的 Modifier；2. reused：重用；3. element-specific state：状态独有。 该如何理解这几个词的意思呢？ 来看以下代码： 12345678910111213141516171819class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { // 写法 1 val modifier1 = Modifier.composed { Modifier.padding(10.dp) } Box(modifier1) Text(&quot;Compose&quot;, modifier1) // 写法 2 val modifier2 = Modifier.padding(10.dp) Box(modifier2) Text(&quot;Compose&quot;, modifier2) } } }} 请问：写法 1 和写法 2 有什么区别？ 我相信你经过上面 ComposedModifier 的解析流程，应该可以很清晰知道：写法 1 和写法 2 唯一的区别就在于，写法 1 的 Modifier.padding() 会延迟创建（由 ComposedModifier 的 factory 函数创建），它们两者的运行显示结果没有任何区别。 实际上 Modifier.composed() 不是用在案例写的这种场景下，而是用在有状态的 Modifier 的场景。 什么叫有状态的 Modifier？按上面的例子 10.dp 就是一个状态，不过因为在这里已经写死了数值所以 Modifier.padding() 是无状态的，进而 Modifier.composed() 也是无状态的。 现在我们来改下代码： 12345678910111213141516class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { val modifier = Modifier.composed { var padding by remember { mutableStateOf(10.dp) } Modifier.padding(padding) } Box(modifier) Text(&quot;Compose&quot;, modifier) } } }} 我们把 10.dp 提取出来，这样 Modifier.padding() 就是有状态的了。如果你对 Compose 所谓的有状态、无状态不了解的话，可以看看 【 聊聊 Jetpack Compose 的 “状态订阅&amp;自动刷新” – 有状态、无状态、状态提升？】 这篇文章。 现在 Modifier.padding() 就是有状态的，进而 Modifier.composed() 就是有状态的，现在我们再回顾下 Modifier.composed 函数注解： 1. stateful modifiers：有状态的 Modifier；2. reused：重用；3. element-specific state：状态独有 再结合这个例子： 12345678910111213141516class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { val modifier = Modifier.composed { var padding by remember { mutableStateOf(10.dp) } Modifier.padding(padding) // 1. stateful modifiers：有状态的 Modifier } Box(modifier) // 2. reused：重用 Text(&quot;Compose&quot;, modifier) // 2. reused：重用 } } }} 是不是满足了两条？那 “状态独有” 又是什么意思？该怎么验证呢？ 来，我们再改下代码： 1234567891011121314151617181920class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { val modifier = Modifier.composed { var padding by remember { mutableStateOf(10.dp) } Modifier .padding(padding) .clickable { padding = 0.dp } } Column { Box(Modifier.background(Color.Red) then modifier) Text(&quot;Compose&quot;, Modifier.background(Color.Blue) then modifier) } } } }} 这里我们对 Modifier 又加了一个点击操作：修改 padding 值为 0，看下运行效果： ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/9699b74351e0d93d270d83ad48112d77.gif =700x) 发现什么没？Text() 组件点击后，padding 修改为 0，却没有影响到 Box 的 padding，这就是 Modifier 状态独有！ 那我们再试试不用 Modifier.composed() 函数包起来的场景，比如代码如下： 123456789101112131415161718class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { var padding by remember { mutableStateOf(10.dp) } val modifier = Modifier .padding(padding) .clickable { padding = 0.dp } Column { Box(Modifier.background(Color.Red) then modifier) Text(&quot;Compose&quot;, Modifier.background(Color.Blue) then modifier) } } } }} 这段代码不难理解吧？来看下效果： ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/97a9e097adda9a1923c783e1516797f3.gif =700x) 发现没？它们恭喜了 padding，点击任何一个组件，都会影响到另外一个的 padding。 所以到这里，我们就可以总结下 Modifier.compose() 函数的作用了：它会创建一个带状态的 Modifier，这个 Modifier 可以重用，并且状态是独立的。 但是！但是！但是！细心的你应该又会有一个疑问：这有点费啊，我可以有更简单的写法啊，比如： 123456789101112131415161718class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { var padding1 by remember { mutableStateOf(10.dp) } val modifier1 = Modifier.padding(padding1).clickable { padding1 = 0.dp } var padding2 by remember { mutableStateOf(10.dp) } val modifier2 = Modifier.padding(padding2).clickable { padding2 = 0.dp } Column { Box(Modifier.background(Color.Red) then modifier1) Text(&quot;Compose&quot;, Modifier.background(Color.Blue) then modifier2) } } } }} 既然不想 Box() 和 Text() 的 padding 相互影响，那么分别给它们设置一个 Modifier 不就行了？何必要用 Modifier.composed() 这种花里胡哨，看上去更高端的方法呢？这段代码的逻辑看上去岂不是更清晰？ 实际上 Modifier.composed() 的使用场景是：当我们需要创建的 Modifier 需要给它添加一些内部状态，这时候我们需要使用 Modifier.composed() 来为它提供一个 Composable 的上下文环境，从而让我们可以使用 remember。 怎么理解这段话？你可以理解成：当我们需要自定义一个 Modifier 时，同时当 Modifier 内部需要用到 remember 时，就需要用到 ComposeModifier。 比如我们修改下前面的 Modifier.composed() 代码： 1234567891011121314151617181920212223class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Column { // 2. 给外部组件调用 Box(Modifier.background(Color.Red) then Modifier.paddingJumpModifier()) Text(&quot;Compose&quot;, Modifier.background(Color.Blue) then Modifier.paddingJumpModifier()) } } } }}// 1. 这里自定义了一个 Modifier.paddingJumpModifierfun Modifier.paddingJumpModifier() { var padding by remember { mutableStateOf(10.dp) } Modifier .padding(padding) .clickable { padding = 0.dp }} 如果你这么写会报错： 报错原因很简单，remember 是一个 Composable 函数，你必须要在 Composable 的上下文环境中才能调用。这时候我们就可以使用 Modifier.composed() 为它提供一个 Composable 的上下文环境，从而让我们可以使用 remember。 写法很简单： 123456fun Modifier.paddingJumpModifier() = composed { var padding by remember { mutableStateOf(10.dp) } Modifier .padding(padding) .clickable { padding = 0.dp }} 这样你的代码就不会报错了，并且所有调用 Modifier.paddingJumpModifier 的地方内部的 padding 状态也是独立的。 为什么 Modifier.composed() 函数内部就可以使用 remember ？ 1234fun Modifier.composed( inspectorInfo: InspectorInfo.() -&gt; Unit = NoInspectorInfo, factory: @Composable Modifier.() -&gt; Modifier // 看这里，它的工厂函数提供了 Composable 上下文环境): Modifier = this.then(ComposedModifier(inspectorInfo, factory)) 所以，factory 工厂函数提供了 Composable 上下文环境，我们就可以调用 remember。 除了可以调用 remember，我们也可以在 Modifier.compose() 内部开启协程： 123456789fun Modifier.paddingJumpModifier() = composed { var padding by remember { mutableStateOf(10.dp) } LaunchedEffect(Unit) { } Modifier .padding(padding) .clickable { padding = 0.dp }} 如果你不加 = composed，那么你调用 LaunchedEffect 就会报错，不信你试试。 最后总结一下 ComposedModifier 或 Modifier.composed()： 按照官方注释的说法，Modifier.composed() 能创建出带有状态的 Modifier，让这个 Modifier 在多处被重用； 有状态的 Modifier 就是被 remember 包着的变量和 Modifier 放在一起作为它的内部状态使用； 重用就是 Modifier.composed() 在每一个使用的地方都创建一个内部状态独立的 Modifier，而不会互相影响 Modifier.composed() 不仅能提供内部状态，在一些需要 Composable 上下文环境，例如 LaunchedEffect 或 CompositionLocal 等地方使用 Modifier，也可以使用它。","link":"/2024/09/10/Compose%20--%20Modifier%20--%2002.%20%E8%A7%A3%E6%9E%90%20ComposedModifier/"},{"title":"解析 DrawModifier","text":"“Jetpack Compose - - Modifier 原理系列文章 “ &nbsp;&nbsp;&nbsp;&nbsp;📑 《 深度解析 Compose 的 Modifier 原理 - - Modifier、CombinedModifier 》 &nbsp;&nbsp;&nbsp;&nbsp;📑 《 深度解析 Compose 的 Modifier 原理 - - Modifier.composed()、ComposedModifier 》 &nbsp;&nbsp;&nbsp;&nbsp;📑 《 深度解析 Compose 的 Modifier 原理 - - Modifier.layout()、LayoutModifier 》 &nbsp;&nbsp;&nbsp;&nbsp;📑 《 深度解析 Compose 的 Modifier 原理 - - DrawModifier 》 &nbsp;&nbsp;&nbsp;&nbsp;📑 《 深度解析 Compose 的 Modifier 原理 - - PointerInputModifier 》 &nbsp;&nbsp;&nbsp;&nbsp;📑 《 深度解析 Compose 的 Modifier 原理 - - ParentDataModifier 》 在正式开始分析 DrawModifier 之前，建议你先看看 【LayoutModifier 和 Modifier.layout 用法及原理】这篇文章，毕竟它是作为 Modifier 原理解析的第一篇文章，对你了解整个 Modifier 架构还是很有帮助的，或者说它是最基础的一篇文章，如果不熟悉，后面的系列 Modifier 你可能会看的比较费劲… 一、话题引入 老样子，我们从 Demo 开始，首先我们看两个简单的场景： 1.1 问题场景 1一个绿色背景的 Text()： 123456789101112class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.background(Color.Green)) { Text(&quot;Hi Compose&quot;) } } } }} 效果如下： ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/2f6fbfcdc180b9670cfce0abb8236bf4.png =500x) 如果我改动一下代码： 12345678910111213class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.background(Color.Green).size(120.dp)) { Text(&quot;Hi Compose&quot;) } } } }} 只是给 Box 加了一个尺寸： ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/14eca7bc86b124dccb8a26fb7e731a28.png =500x) 嗯，效果不错，那如果我再改一次呢？ 12345678910111213class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.background(Color.Green).size(120.dp).background(Color.Red)) { Text(&quot;Hi Compose&quot;) } } } }} 又加了一个 background，看下效果： ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/da9a778662bd7af48e1d253c5f9edb8f.png =500x) 思考一个问题：为什么此时的 Box 是红色，而不是绿色？ 如果你看了 LayoutModifier 的原理解析，这边就会产生一个困惑：Modifier 不是从右边开始，依次往左遍历，最终应该是绿色背景，而不应该是红色背景啊？ 所以，问题出在哪？我们不妨先简单看下 Modifier.background() 源码： 1234567891011fun Modifier.background( color: Color, shape: Shape = RectangleShape): Modifier { val alpha = 1.0f // for solid colors return this.then( BackgroundElement( ... ) )} 它又调用了 BackgroundElement： 123private class BackgroundElement( ...) : ModifierNodeElement&lt;BackgroundNode&gt;() { 看过之前 LayoutModifier 解析的文章的话，这边你应该不会陌生了吧？BackgroundElement 会转换成一个 BackgroundNode 对象，它是实际的链表节点。 123private class BackgroundNode( ...) : DrawModifierNode, Modifier.Node() { 它是一个 DrawModifierNode，所以是 DrawModifierNode 影响了背景的绘制？ 1.2 问题场景 2在之前我们分析 LayoutModifier 文章中提到过：如果我们需要自己创建一个 LayoutModifier，可以通过 Modifier.layout()，同样的如果我们要创建一个 DrawModifier，可以通过 Modifier.drawWithContent()，比如： 12345678910111213class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.background(Color.Green).size(120.dp).drawWithContent { }) { Text(&quot;Hi Compose&quot;) } } } }} 看下效果： ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/9f3a175fff1af88c1f664b79614393de.png =500x) ？？？不对啊，Text() 哪去了？我现在再来修改下代码： 12345678910111213class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.background(Color.Green).size(120.dp).drawWithContent { drawContent() }) { Text(&quot;Hi Compose&quot;) } } } }} 仅仅是在 drawWithContent 里面加了一个 drawContent()，再看下效果： ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/12aed22080dd8c7f7e7c25cc200a1ad4.png =500x) Text() 又出来了，为什么？为什么要加 drawContent()， drawContent() 又是什么？难道它负责绘制 Text()？ 接下来，我们就带着这两个问题正式进入这篇文章的主题！ 二、DrawModifierNode 查看 Modifier.background() 和 Modifier.drawWithContent() 的源码，发现它们背后的 BackgroundElement 和 DrawWithContentElement 都继承自 ModifierNodeElement&lt;N : Modifier.Node&gt;。 1234567891011121314151617181920212223242526272829303132&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Modifier.background() &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;fun Modifier.background(...): Modifier { val alpha = 1.0f // for solid colors return this.then( BackgroundElement( ... ) )}private class BackgroundElement( ...) : ModifierNodeElement&lt;BackgroundNode&gt;()private class BackgroundNode( ...) : DrawModifierNode, Modifier.Node()&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Modifier.drawWithContent() &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;fun Modifier.drawWithContent( onDraw: ContentDrawScope.() -&gt; Unit): Modifier = this then DrawWithContentElement(onDraw)private data class DrawWithContentElement( val onDraw: ContentDrawScope.() -&gt; Unit) : ModifierNodeElement&lt;DrawWithContentModifier&gt;()private class DrawWithContentModifier( var onDraw: ContentDrawScope.() -&gt; Unit) : Modifier.Node(), DrawModifierNode { ....} 而且泛型类型 BackgroundNode 和 DrawWithContentModifier 都实现了 DrawModifierNode 接口。 画了个图，看着更直观： 这个 DrawModifierNode 接口就是 Draw 修饰符的核心，它定义了 Draw 修饰符的核心逻辑。 123456789101112/** * A [Modifier.Node] that draws into the space of the layout. * * This is the [androidx.compose.ui.Modifier.Node] equivalent of * [androidx.compose.ui.draw.DrawModifier] * * @sample androidx.compose.ui.samples.DrawModifierNodeSample */interface DrawModifierNode : DelegatableNode { fun ContentDrawScope.draw() // draw 绘制方法 fun onMeasureResultChanged() {}} 那么，我们要探究 Draw 修饰符如何影响元素绘制过程，重点就是看元素的绘制在哪用到了 DrawModifierNode，或者更准确地说，DrawModifierNode 的 draw() 方法在何处被调用了。 三、 DrawModifierNode 对绘制的影响 现在我们已经很清楚 LayoutNode 是如何处理 DrawModifierNode 的了，接下来我们就看看 DrawModifierNode 是如何对绘制产生精细影响的。 在 LayoutNode 中，绘制是由 draw() 函数处理的。 1234567// LayoutNode.ktinternal class LayoutNode(...) : ... { internal val outerCoordinator: NodeCoordinator get() = nodes.outerCoordinator internal fun draw(canvas: Canvas) = outerCoordinator.draw(canvas)} 看过之前 LayoutModifierNode 解析的文章后，我们已经知道 outerCoordinator 是一个 NodeCoordinator。 3.1 NodeCoordinator.draw()现在我们来看看 NodeCoordinator 的 draw() 方法： 1234567891011121314151617181920// NodeCoordinator.ktinternal abstract class NodeCoordinator( override val layoutNode: LayoutNode,) : ... { fun draw(canvas: Canvas) { // layer: 是一个独立绘制的图层，它只是在一块额外的区域绘制而已，大多数时候是没有的 val layer = layer if (layer != null) { layer.drawLayer(canvas) } else { val x = position.x.toFloat() val y = position.y.toFloat() canvas.translate(x, y) drawContainedDrawModifiers(canvas) // 关键代码 canvas.translate(-x, -y) } }} 大多数情况下，我们并不需要考虑 layer 图层，所以这里可以当它为 null 处理。所以我们只需要关心 else 分支内部的逻辑，核心代码就一行：drawContainedDrawModifiers(canvas)。 3.2 drawContainedDrawModifiers()12345678910111213141516// NodeCoordinator.ktinternal abstract class NodeCoordinator( override val layoutNode: LayoutNode,) : ... { private fun drawContainedDrawModifiers(canvas: Canvas) { val head = head(Nodes.Draw) if (head == null) { performDraw(canvas) } else { val drawScope = layoutNode.mDrawScope drawScope.draw(canvas, size.toSize(), this, head) } } } 这段代码的逻辑很清晰，主要就是三步： 获取当前 NodeCoordinator 范围内的的第一个 Draw 修饰符 1val head = head(Nodes.Draw) 表头如果为空，也就是没有设置过 DrawModifier 123if (head == null) { performDraw(canvas)} 那么就会执行 performDraw()，我们来看看它做了什么： 123open fun performDraw(canvas: Canvas) { wrapped?.draw(canvas)} wrapped 是什么？ 1internal open val wrapped: LayoutNodeWrapper? get() = null 它就是当前的 LayoutNodeWrapper 对象，而 LayoutNodeWrapper 是一个抽象类。 注意： 我们现在分析的场景是没有设置 DrawModifier，那么实际代码可能是这样： 1Box(Modifier.padding(10.dp).size(120.dp)) 对应的内部 Modifier 的结构大概是这个样子： 123456789ModifiedLayoutNode[ LayoutModifier // padding(10.dp) + ModifiedLayoutNode[ LayoutModifier // size(120.dp) + innerLayoutNodeWrapper // Box() ]] ModifiedLayoutNode 本身就是一个 LayoutNodeWrapper 的子类，所以，你现在知道上面的 wrapped 是什么了吗？ 123456789ModifiedLayoutNode[ // wrapped LayoutModifier + ModifiedLayoutNode[ // wrapped LayoutModifier + innerLayoutNodeWrapper // wrapped ]] 再来看看 wrapped.draw() 干了什么： 123456789101112fun draw(canvas: Canvas) { val layer = layer if (layer != null) { layer.drawLayer(canvas) } else { val x = position.x.toFloat() val y = position.y.toFloat() canvas.translate(x, y) drawContainedDrawModifiers(canvas) canvas.translate(-x, -y) }} 又跳回 draw() 函数了，而你还记得 drawContainedDrawModifiers 是干嘛的吗？它的核心就是用来检查是否有 DrawModifier 的链表的表头，如果没有就一直往内部找： 123456789ModifiedLayoutNode[ LayoutModifier // padding(10.dp) --&gt; 没有设置 DrawModifier，就去找内部有没有设置 DrawModifier + ModifiedLayoutNode[ LayoutModifier // size(120.dp) --&gt; 没有设置 DrawModifier，就去找内部有没有设置 DrawModifier + innerLayoutNodeWrapper // Box() --&gt; 没有设置 DrawModifier，它没有内部了，就不找了 ]] 所以我们总结下：不管你设置了多少 Modifier.**，在绘制的时候，都会遍历一遍，只要没有 DrawModifier 就不会进行任何绘制动作。 表头不为空，有设置 DrawModifier 123else { head.draw(canvas)} 如果我们设置了 DrawModifier：比如 Modifier.background()，那么就会执行 head.draw()，我们再来看看它又做了什么： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// DrawEntity.ktfun draw(canvas: Canvas) { ... ... val drawScope = layoutNode.mDrawScope // 1. 核心代码，看看 drawScope.draw() 做了什么工作 drawScope.draw(canvas, size, layoutNodeWrapper, this) { with(drawScope) { with(modifier) { draw() } } }}// LayoutNodeDrawScope.ktinternal inline fun draw( canvas: Canvas, size: Size, layoutNodeWrapper: LayoutNodeWrapper, drawEntity: DrawEntity, block: DrawScope.() -&gt; Unit) { val previousDrawEntity = this.drawEntity this.drawEntity = drawEntity // 2. 核心代码 canvasDrawScope.draw( layoutNodeWrapper.measureScope, layoutNodeWrapper.measureScope.layoutDirection, canvas, size, block ) this.drawEntity = previousDrawEntity}// CanvasDrawScope.ktinline fun draw( density: Density, layoutDirection: LayoutDirection, canvas: Canvas, size: Size, block: DrawScope.() -&gt; Unit) { ... ... this.block() // 3. 核心代码 ... ...} 最终调用了 block()，这个 block 太熟了，它肯定是一个传进来的 Lambda 表达式，也就是： ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/6980d794c11d4de2db9540cf3ce46a45.png =700x) 所以我们的重点就转移到研究这段 lambda 表达式的工作内容了。 它里面也有一个 draw()，我们看看它做了啥： 123456// DrawModifier.kt@JvmDefaultWithCompatibilityinterface DrawModifier : Modifier.Element { fun ContentDrawScope.draw()} 咦？是 DrawModifier 接口的 draw() 方法，那肯定有某个这个接口的实现类实现了这个 draw() 方法，我们可以搜索下看看： 看到没，Background！ 所以我们现在可以来看下 Background 的内部的 draw() 逻辑： 123456789101112131415private class Background constructor( ... ...) : DrawModifier, InspectorValueInfo(inspectorInfo) { override fun ContentDrawScope.draw() { if (shape === RectangleShape) { // shortcut to avoid Outline calculation and allocation drawRect() } else { drawOutline() } drawContent() }} 细心的你是不是发现了 drawContent()？ 还记得我们文章开头第二个疑惑的问题吗？我们回顾一下代码： 12345678910111213class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.background(Color.Green).size(120.dp).drawWithContent { drawContent() }) { Text(&quot;Hi Compose&quot;) } } } }} 现在我们就可以来看看 drawWithContent 的内部代码： 1234567891011121314151617181920// DrawModifier.ktfun Modifier.drawWithContent( onDraw: ContentDrawScope.() -&gt; Unit): Modifier = this then DrawWithContentElement(onDraw)private data class DrawWithContentElement( val onDraw: ContentDrawScope.() -&gt; Unit) : ModifierNodeElement&lt;DrawWithContentModifier&gt;() { override fun create() = DrawWithContentModifier(onDraw) // 创建 DrawWithContentModifier ... ...}private class DrawWithContentModifier( var onDraw: ContentDrawScope.() -&gt; Unit) : Modifier.Node(), DrawModifierNode { override fun ContentDrawScope.draw() { onDraw() // 这不就类似于 block？ }} 所以实际上调用的是啥？ 也就是调用了 drawContent()。 所以不管是 Modifier.background() 还是你自己 drawWithContent()，都会/需要调用 drawContent() 函数。 所以，现在我们就可以重点研究下 drawContent() 到底是做了什么了！ 123456interface ContentDrawScope : DrawScope { /** * Causes child drawing operations to run during the `onPaint` lambda. */ fun drawContent()} 又是一个接口内部的方法，再搜一下哪个地方实现了 - - 全局只有一个地方实现了，如下： 12345678910111213141516171819internal class LayoutNodeDrawScope( private val canvasDrawScope: CanvasDrawScope = CanvasDrawScope()) : DrawScope by canvasDrawScope, ContentDrawScope { private var drawEntity: DrawEntity? = null override fun drawContent() { drawIntoCanvas { canvas -&gt; val drawEntity = drawEntity!! val nextDrawEntity = drawEntity.next if (nextDrawEntity != null) { nextDrawEntity.draw(canvas) } else { drawEntity.layoutNodeWrapper.performDraw(canvas) } } } ... ...} drawIntoCanvas 是什么？ 1inline fun DrawScope.drawIntoCanvas(block: (Canvas) -&gt; Unit) = block(drawContext.canvas) 又是一个 block，所以我们只关心 lambda 表达式内部的逻辑即可，分两步走： 如果 DrawModifier 链表的下一个节点为 null，说明只有一个 DrawModifier 链表头或没有更多 DrawModifier，这个时候就会让下一个 LayoutNodeWrapper 查找其内部有没有 DrawModifier。 比如： 1Box(Modifier.padding(10.dp).background(Color.Red).size(120.dp)) 对应的内部 Modifier 的结构大概是这个样子： 1234567891011ModifiedLayoutNode1( PaddingModifier, [null, null, null, null, null, null, null] ModifiedLayoutNode2( SizeModifier, [DrawModifier, null, null, null, null, null, null] // 现在 DrawModifier 是表头 innerLayoutNodeWrapper( [null, null, null, null, null, null, null] ) )) 现在针对这个场景，只有一个 DrawModifier，它是表头，并且它没有下一个节点了，那么就会执行： 1drawEntity.layoutNodeWrapper.performDraw(canvas) 具体处理流程如下： &nbsp;&nbsp;&nbsp;&nbsp;==&gt; ModifiedLayoutNode1 没有 DrawModifier，继续下一个节点 ModifiedLayoutNode2 查找有没有 DrawModifier； &nbsp;&nbsp;&nbsp;&nbsp;==&gt; ModifiedLayoutNode2 有 DrawModifier，DrawModifier.draw() 调用绘制，DrawModifier 链表没有下一个 DrawModifier，继续下一个节点 InnerNodeCoordinator 查找有没有 DrawModifier； &nbsp;&nbsp;&nbsp;&nbsp;==&gt; InnerNodeCoordinator 没有 DrawModifier，绘制结束 如果 DrawModifier 链表的下一个节点不为 null，说明还有 DrawModifier，从 DrawModifier 链表头开始遍历调用 DrawModifier 处理绘制。 比如： 1Box(Modifier.padding(10.dp).background(Color.Red).background(Color.Blue).size(120.dp)) 对应的内部 Modifier 的结构大概是这个样子： 1234567891011ModifiedLayoutNode1( PaddingModifier, [null, null, null, null, null, null, null] ModifiedLayoutNode2( SizeModifier, [DrawModifier2 -&gt; DrawModifier1, null, null, null, null, null, null] innerLayoutNodeWrapper( [null, null, null, null, null, null, null] ) )) 现在针对这个场景，表头有下一个节点了，那么就会执行： 1nextDrawEntity.draw(canvas) 跳转一下看看： 123456789101112fun draw(canvas: Canvas) { ... ... val drawScope = layoutNode.mDrawScope drawScope.draw(canvas, size, layoutNodeWrapper, this) { with(drawScope) { with(modifier) { draw() } } }} 这段代码熟悉吗？DrawModifier2 绘制完，调用 drawContent()，让 DrawModifier1 开始绘制。 drawContent() 是通知当前 DrawModifier 下一级的 LayoutNodeWrapper 的 DrawModifier 处理绘制。所以如果有一个 DrawModifier 没有调用 drawContent()，相当于链条断开不会通知内部的 DrawModifier 去绘制。","link":"/2024/09/18/Compose%20--%20Modifier%20--%2004.%20%E8%A7%A3%E6%9E%90%20DrawModifier/"},{"title":"解析 Modifier.layout()","text":"# 前言众所周知：原理性分析的文章，真的很难讲的通俗易懂，讲的简单了就没必要写了，讲的繁琐杂乱往往大家也不乐意看，所以只能尽量找个好的角度（比如从 Demo 代码示例出发）慢慢带着大家去钻源码，如果确实能帮助到大家理解清楚原理，那就点个赞呗～😄 在正式开始分析这篇文章的主角之前，建议你先看看 【Modifier、CombinedModifier】 一文，作为 Modifier 原理系列的第一篇开山之作，它是一个根，必须掌握！ 一、场景引入1.1 一个 Text()先来看一个最简单的代码示例： 123456789101112class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.background(Color.Green)) { Text(&quot;Hi Compose&quot;) } } } }} 这段代码很简单，效果图如下： ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/68d94f6c5227491eac32b0ef9d816cab.png#pic_start =600x) 接下来基于这个 Demo，我们会慢慢引入本篇文章的主角。 1.2 Modifier.layout()在 Compose 中 Modifier.layout() 是一种布局修饰符，它会包裹一个布局节点：Layout（什么是 LayoutNode，下面会讲），通常用作对目标组件「进行测量」和「位置摆放」的。 说白了就是你可以用 Modifier.layout() 来「自定义目标组件的测量过程」以及「决定目标组件怎么摆放」。 现在我们看看代码中怎么用，通常会像下面这样写： 1234567891011121314class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.background(Color.Green)) { Text(&quot;Hi Compose&quot;, Modifier.layout { measurable, constraints -&gt; } ) } } } }} 就这么简单，Text 就是目标组件，我们给它加了一个 Modifier.layout()，没有添加任何其他代码逻辑，{ measurable, constraints -&gt; } 是自动生成的，此时你会发现在 Android Studio IDLE 中，这样写是会标红的： ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/9455c71dd48447569e358a24f136931f.png =700x) 正常来说，我这里什么也不填不就相当于对 Text() 不做任何修饰。但很明显这样是不行的，接下来我们一起尝试解决这个报错。 首先我们发现当使用 layout() 修饰符时，传入的回调 lambda 包含了两个参数： measurable：用于子元素的测量和位置放置； constraints：用于约束子元素 width 和 height 的最大值和最小值。 我们定位到 Modifier.layout() 的源码： 12345📄 androidx.compose.ui.layout --&gt; LayoutModifier.ktfun Modifier.layout( measure: MeasureScope.(Measurable, Constraints) -&gt; MeasureResult) = this then LayoutElement(measure) 所以，measurable 对应的是 Measurable： 12345678910📄 androidx.compose.ui.layout --&gt; Measurable.ktinterface Measurable : IntrinsicMeasurable { /** * Measures the layout with [constraints], returning a [Placeable] layout that has its new * size. A [Measurable] can only be measured once inside a layout pass. */ // 返回一个 Placeable，它里面包含目标组件的宽、高等信息 fun measure(constraints: Constraints): Placeable} 我们发现 Measurable 是一个接口，内部仅有一个 measure() 方法。 所以现在可以开始修改刚才的报错了： 1234567891011121314151617class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.background(Color.Green)) { Text(&quot;Hi Compose&quot;, Modifier.layout { measurable, constraints -&gt; // 用一个变量保存返回的 Placeable 对象 val placeable = measurable.measure(constraints) } ) } } } }} 现在代码仍然是标红报错的，原因在于：我们只处理了 measurable，它返回的是 Placeable，而 Modifier.layout() 需要返回的类型是 MeasureResult： 123fun Modifier.layout( measure: MeasureScope.(Measurable, Constraints) -&gt; MeasureResult // 需要返回 MeasureResult) = this then LayoutModifierElement(measure) 所以 MeasureResult 又是什么？ 12345678📄 androidx.compose.ui.layout --&gt; MeasureResult.ktinterface MeasureResult { val width: Int val height: Int val alignmentLines: Map&lt;AlignmentLine, Int&gt; fun placeChildren()} MeasureResult 也是一个接口，它里面也有 width 和 height，继续修复刚才的报错： 1234567891011121314151617181920212223242526class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Text(&quot;ComposeTest&quot;, Modifier.layout { measurable, constraints -&gt; val placeable = measurable.measure(constraints) object : MeasureResult { override val alignmentLines: Map&lt;AlignmentLine, Int&gt; get() = TODO(&quot;Not yet implemented&quot;) override val height: Int get() = TODO(&quot;Not yet implemented&quot;) override val width: Int get() = TODO(&quot;Not yet implemented&quot;) override fun placeChildren() { TODO(&quot;Not yet implemented&quot;) } } } ) } } }} 既然 Modifier.layout() 需要一个 MeasureResult 返回对象，那我们就在内部给它创建一个 MeasureResult 对象，此时 IDLE 就不会再报错了。 当然我们还需要做一个工作，那就是把 placeable 的宽高传进 MeasureResult 内部，所以最终的代码修改如下： 1234567891011121314151617181920212223242526272829303132class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.background(Color.Green)) { Text(&quot;Hi Compose&quot;, Modifier.layout { measurable, constraints -&gt; val placeable = measurable.measure(constraints) object : MeasureResult { // 测量基准线，暂时不用关心 override val alignmentLines: Map&lt;AlignmentLine, Int&gt; get() = TODO(&quot;Not yet implemented&quot;) // 高：placeable.height override val height: Int get() = placeable.height // 宽：placeable.width override val width: Int get() = placeable.width // 摆放内部组件，暂时不用关心 override fun placeChildren() { TODO(&quot;Not yet implemented&quot;) } } } ) } } } }} 至此报错就修复了，上面的代码演示了对 Text() 添加 Modifier.layout() 进行修饰（当然上面的做法等同于啥也没做）。 但这段代码有个缺陷：如果每次通过 Modifier.layout() 对组件修饰，都得像上面这样写一堆代码，那还不得疯？ 1.3 layout() 函数其实在实际开发中我们并不会这么写，而是使用 Compose 提供给我们的 layout() 函数： 1234567891011121314151617181920212223242526272829303132class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.background(Color.Green)) { Text(&quot;Hi Compose&quot;, Modifier.layout { measurable, constraints -&gt; val placeable = measurable.measure(constraints) /*object : MeasureResult { override val alignmentLines: Map&lt;AlignmentLine, Int&gt; get() = TODO(&quot;Not yet implemented&quot;) override val height: Int get() = TODO(&quot;Not yet implemented&quot;) override val width: Int get() = TODO(&quot;Not yet implemented&quot;) override fun placeChildren() { TODO(&quot;Not yet implemented&quot;) } }*/ layout() { } } ) } } } }} 我们来看下 layout() 源码： 123456789101112131415161718192021222324📄 androidx.compose.ui.layout --&gt; MeasureScope.ktinterface MeasureScope : IntrinsicMeasureScope { fun layout( width: Int, height: Int, alignmentLines: Map&lt;AlignmentLine, Int&gt; = emptyMap(), placementBlock: Placeable.PlacementScope.() -&gt; Unit ) = object : MeasureResult { // 看这里，这是个啥？熟悉吗？ override val width = width override val height = height override val alignmentLines = alignmentLines override fun placeChildren() { Placeable.PlacementScope.executeWithRtlMirroringValues( width, layoutDirection, this@MeasureScope as? LookaheadCapablePlaceable, placementBlock ) } }} 很明显 layout() 函数帮我们创建好了 MeasureResult 对象，同时它还帮我们干了另外两件没做的事： 给 alignmentLines 设定了默认值； 实现了 placeChildren()。 所以，我们现在只需要补全 layout() 函数剩余的两个参数：width 和 height。 12345678910111213141516171819class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.background(Color.Green)) { Text(&quot;Hi Compose&quot;, Modifier.layout { measurable, constraints -&gt; val placeable = measurable.measure(constraints) layout(placeable.width, placeable.height) { } } ) } } } }} 这样写代码是不是瞬间感觉清爽了很多？但工作到这边还没有结束，layout() 函数还有第四个参数，是一个 Lambda 表达式，主要工作是处理被修饰组件的摆放规则，比如偏移量。 12345678fun layout( width: Int, height: Int, alignmentLines: Map&lt;AlignmentLine, Int&gt; = emptyMap(), placementBlock: Placeable.PlacementScope.() -&gt; Unit // Lambda 表达式) = object : MeasureResult { ... ...} 我们继续完善： 1234567891011121314151617181920class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.background(Color.Green)) { Text(&quot;Hi Compose&quot;, Modifier.layout { measurable, constraints -&gt; val placeable = measurable.measure(constraints) layout(placeable.width, placeable.height) { // 不做任何偏移 placeable.placeRelative(0, 0) } } ) } } } }} 现在所有工作（测量 + 摆放）都已完成，运行看下效果： ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a89d5d8827d64381b418f6ac72ec6f6b.png#pic_start =600x) 可以看出来，没有任何变化，因为我们虽然用 Modifier.layout() 对 Text 做修饰，但并没有对它做任何尺寸修改和位置偏移。 那如果我现在想修改 Text() 的尺寸，该怎么做？ 12345678910111213141516171819class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.background(Color.Green)) { Text(&quot;Hi Compose&quot;, Modifier.layout { measurable, constraints -&gt; val placeable = measurable.measure(constraints) val size = min(placeable.width, placeable.height) layout(size, size) { placeable.placeRelative(0, 0) } }) } } } }} 我们定义了一个 size 变量，通过 min() 函数获取宽高最小值，然后重新传入 layout() 里面，这样就会获得一个正方形的效果。 ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/044b065522a74d3fa8904fb497920133.png#pic_start =600x)) 尺寸修改确实生效了，接下来再增加一个偏移： 12345678910111213141516171819class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.background(Color.Green)) { Text(&quot;Hi Compose&quot;, Modifier.layout { measurable, constraints -&gt; val placeable = measurable.measure(constraints) val size = min(placeable.width, placeable.height) layout(size, size) { placeable.placeRelative(30, 0) } }) } } } }} 看下效果： ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/3146c6fbeaf24bd9803b11f749948732.png#pic_start =600x) 另外有个细节需要说明下，除了使用 placeRelative 对组件偏移外，也可以使用 place 进行偏移操作，两者的区别就是 placeRelative 会自适应 RTL 布局。 讲到这里，Modifier.layout() 修饰符和 layout() 函数的用法你应该都清楚了，但还没结束，前面我们一直忽略了一个参数：constraints，它是什么？ measurable：用于子元素的测量和位置放置的； constraints：用于约束子元素 width 和 height 的最大值和最小值。 前面的例子并没有对 constraints 做任何修改，在实际开发过程中，我们往往需要通过 constraints 对组件进行限制。 比如我想对 Text() 组件进行一个限制，类似 padding 的效果，给它加一个 10dp 的最大宽高的限制（最大宽高缩减 10dp）。 12345678910111213141516171819202122class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.background(Color.Green)) { Text(&quot;Hi Compose&quot;, Modifier.layout { measurable, constraints -&gt; val paddingPx = 10.dp.roundToPx() val placeable = measurable.measure(constraints.copy( maxWidth = constraints.maxWidth - paddingPx * 2, maxHeight = constraints.maxHeight - paddingPx * 2 )) layout(placeable.width + paddingPx * 2, placeable.height + paddingPx * 2) { placeable.placeRelative(paddingPx, paddingPx) } }) } } } }} 看下效果： ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/0ab95beca0c2423eb67f8a3ed7a234c5.png#pic_start =600x) 很明显，我们实现的效果跟 Modifier.padding(10.dp) 的效果是一样的，如果你去看看 Modifier.padding 的源码，就会发现它的内部原理跟我们例子是一样的。 123456789@Stablefun Modifier.padding( horizontal: Dp = 0.dp, vertical: Dp = 0.dp) = this.then( PaddingModifier( ... ... )) 1234567891011121314151617181920212223242526272829303132private class PaddingModifier( val start: Dp = 0.dp, val top: Dp = 0.dp, val end: Dp = 0.dp, val bottom: Dp = 0.dp, val rtlAware: Boolean, inspectorInfo: InspectorInfo.() -&gt; Unit) : LayoutModifier, InspectorValueInfo(inspectorInfo) { ... ... override fun MeasureScope.measure( measurable: Measurable, constraints: Constraints ): MeasureResult { val horizontal = start.roundToPx() + end.roundToPx() val vertical = top.roundToPx() + bottom.roundToPx() val placeable = measurable.measure(constraints.offset(-horizontal, -vertical)) val width = constraints.constrainWidth(placeable.width + horizontal) val height = constraints.constrainHeight(placeable.height + vertical) return layout(width, height) { if (rtlAware) { placeable.placeRelative(start.roundToPx(), top.roundToPx()) } else { placeable.place(start.roundToPx(), top.roundToPx()) } } } ... ...} 二、LayoutNode 浅析 通过前面的例子，我们可以看出： 不论是使用 Modifier.layout() 修饰符还是使用 Compose 提供给我们的现成的修饰符，比如：Modifier.padding() / Modifier.size()，它们都会对被修饰组件产生精细影响（组件大小、位置偏移）。 但到目前为止，我们仅仅是从 UI 效果上看到 Modifier.layout() 会影响被修饰组件，但源码底层是如何产生影响的呢？ 这才是我们这篇文章的核心价值！所以，最硬核的原理部分来了！ 我们就拿常用的 Modifier.padding() 分析，来看下它的源码 123456789101112131415161718192021222324252627282930313233📄 androidx.compose.foundation.layout --&gt; Padding.kt@Stablefun Modifier.padding( start: Dp = 0.dp, top: Dp = 0.dp, end: Dp = 0.dp, bottom: Dp = 0.dp) = this then PaddingElement( start = start, top = top, end = end, bottom = bottom, rtlAware = true, inspectorInfo = { name = &quot;padding&quot; properties[&quot;start&quot;] = start properties[&quot;top&quot;] = top properties[&quot;end&quot;] = end properties[&quot;bottom&quot;] = bottom })private class PaddingElement( var start: Dp = 0.dp, var top: Dp = 0.dp, var end: Dp = 0.dp, var bottom: Dp = 0.dp, var rtlAware: Boolean, val inspectorInfo: InspectorInfo.() -&gt; Unit) : ModifierNodeElement&lt;PaddingNode&gt;() {abstract class ModifierNodeElement&lt;N : Modifier.Node&gt; : Modifier.Element, InspectableValue { 这里有问题！！！！！！！！！！！！！层级关系非常清晰：Modifier.padding() 调用一个 PaddingElement 对象，而 PaddingElement 实现了 ModifierNodeElement 类（这是个范型类，其中包含了 PaddingNode），ModifierNodeElement 又继承了 Modifier.Element 接口。 这个 LayoutModifier 会被 Compose 用于修改测量和布局过程，从而最终影响到界面元素的位置和尺寸。 所以我们的重点就是要研究 LayoutModifier 是如何影响组件的！ 但是！在分析 LayoutModifier 原理之前，有一个核心知识点是必须要提前了解的。 这段代码我们再熟悉不过了吧： 123456789101112class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.background(Color.Green)) { Text(&quot;Hi Compose&quot;) } } } }} Box 、Text 这些函数在实际运行的时候，其实并不是这些函数直接存在于内存里面，而是 Compose 利用这些函数创造出的一些对象存在于内存里面，这个对象就是：LayoutNode，它才是最底层的那个节点，进行实际的「 测量、布局、绘制、触摸反馈 」等工作，你可以查看 【Compose 是如何将数据转换成 UI 的？】这篇文章，了解转换的思维模型！ 我们既然想知道 LayoutModifier 是如何精细影响 Text() 组件，那就得先研究明白 Text() 自己的测量、布局、绘制的原理，因为 LayoutModifier 是包着这个 Text() 的。 在 LayoutNode 中，测量和布局是由 remeasure() 函数和 replace() 两个函数处理。 123456📄 androidx.compose.ui.node --&gt; LayoutNode.ktinternal class LayoutNode(..) { internal fun replace() // 布局 internal fun remeasure() // 测量} 2.1 LayoutNode.remeasure()我们先来分析 remeasure() 函数： 12345678910111213141516171819📄 androidx.compose.ui.node --&gt; LayoutNode.ktinternal class LayoutNode(..) { internal fun remeasure( constraints: Constraints? = layoutDelegate.lastConstraints ): Boolean { return if (constraints != null) { if (intrinsicsUsageByParent == UsageByParent.NotUsed) { clearSubtreeIntrinsicsUsage() } // 测量工作交给 LayoutNodeLayoutDelegate 的内部类 MeasurePassDelegate 处理 measurePassDelegate.remeasure(constraints) } else { false } }} 2.2 MeasurePassDelegate.measurePassDelegate()LayoutNode 内部要处理的事情非常多，它把测量的工作交给了 MeasurePassDelegate 来处理。 123456789101112131415161718192021📄 androidx.compose.ui.node --&gt; LayoutNodeLayoutDelegate.ktinternal class LayoutNodeLayoutDelegate( private val layoutNode: LayoutNode) { inner class MeasurePassDelegate : Measurable, Placeable(), AlignmentLinesOwner { fun remeasure(constraints: Constraints): Boolean { ... if (layoutNode.measurePending || measurementConstraints != constraints) { ... performMeasure(constraints) // 关键代码 ... } return false } }} 这段代码很长，但我们只需要关注一行关键代码：performMeasure(constraints)。 2.3 LayoutNodeLayoutDelegate.performMeasure()1234567891011121314151617181920212223📄 androidx.compose.ui.node --&gt; LayoutNodeLayoutDelegate.ktinternal class LayoutNodeLayoutDelegate( private val layoutNode: LayoutNode) { private fun performMeasure(constraints: Constraints) { ... layoutNode.requireOwner().snapshotObserver.observeMeasureSnapshotReads( layoutNode, affectsLookahead = false, performMeasureBlock // 关键代码 ) ... } private var performMeasureConstraints = Constraints() private val performMeasureBlock: () -&gt; Unit = { outerCoordinator.measure(performMeasureConstraints) }} 我们仍然只需要关注：outerCoordinator.measure(performMeasureConstraints)，它是做实际测量工作的。 2.4 Measurable.measure()继续跟踪： 123456789📄 androidx.compose.ui.layout --&gt; Measurable.ktinterface Measurable : IntrinsicMeasurable { /** * Measures the layout with [constraints], returning a [Placeable] layout that has its new * size. A [Measurable] can only be measured once inside a layout pass. */ fun measure(constraints: Constraints): Placeable} What ？？？怎么是个接口啊，没有任何处理逻辑啊！！！ 转念一想，既然是个接口，那肯定有其他地方实现了这个方法，我们可以搜一下哪些地方实现了。 有三个地方实现了，但哪一个才是我们需要的呢？别慌，我带你找一下。 我们往回退，找找刚才哪里调用 measure() 方法的？ 1234567891011121314151617181920📄 androidx.compose.ui.node --&gt; LayoutNodeLayoutDelegate.ktinternal class LayoutNodeLayoutDelegate( private val layoutNode: LayoutNode) { /** * 2. outerCoordinator 由传进来的 layoutNode 参数决定，那么我们得找找 layoutNode 是哪里传进来的 * 这里记住： * a. 接下来我们先找到哪里传入了 layoutNode * b. 找到后我们再看 layoutNode.nodes.outerCoordinator 是什么？ */ val outerCoordinator: NodeCoordinator get() = layoutNode.nodes.outerCoordinator private val performMeasureBlock: () -&gt; Unit = { // 1. 这里调用了 measure()，那么 outerCoordinator 是什么？ outerCoordinator.measure(performMeasureConstraints) }} 继续回退到上一层： 1234567891011121314151617181920212223📄 androidx.compose.ui.node --&gt; LayoutNodeLayoutDelegate.ktinternal class LayoutNodeLayoutDelegate( private val layoutNode: LayoutNode) { inner class MeasurePassDelegate : Measurable, Placeable(), AlignmentLinesOwner { // 2. 我们继续回退 fun remeasure(constraints: Constraints): Boolean { ... if (layoutNode.measurePending || measurementConstraints != constraints) { ... // 1. 没有地方传入 layoutNode 啊 performMeasure(constraints) ... } return false } }} 继续回退到上一层： 12345678910111213141516171819202122232425262728293031323334353637📄 androidx.compose.ui.node --&gt; LayoutNode.ktinternal class LayoutNode(..) { // 2. 通过 layoutDelegate 获取 measurePassDelegate，那 layoutDelegate 是什么？ internal val measurePassDelegate get() = layoutDelegate.measurePassDelegate ... // 4. 来来来，nodes 在这里，NodeChain 又是什么？ internal val nodes = NodeChain(this) /** * 3. LayoutNodeLayoutDelegate(this) 看到这行代码你有没有想起来什么？ * 这个 this 不就是我们要找的那个 layoutNode 参数嘛！ * 现在我们再看下刚刚用到这个参数的地方： * * val outerCoordinator: NodeCoordinator * get() = layoutNode.nodes.outerCoordinator * * 还记得吧？现在 layoutNode 找到了，接下来看看 nodes 是什么？ */ internal val layoutDelegate = LayoutNodeLayoutDelegate(this) internal fun remeasure( constraints: Constraints? = layoutDelegate.lastConstraints ): Boolean { return if (constraints != null) { ... // 1. 还是没有地方传入 layoutNode 啊，别急，我们看看 measurePassDelegate 是什么？ measurePassDelegate.remeasure(constraints) } else { false } }} 2.5 NodeChain兄弟！顶住！我们再来看看 NodeChain 是什么？ 123456789101112131415161718192021📄 androidx.compose.ui.node --&gt; NodeChain.ktinternal class NodeChain(val layoutNode: LayoutNode) { /** * 2. 再看这里，而 innerCoordinator 又是 InnerNodeCoordinator！ */ internal val innerCoordinator = InnerNodeCoordinator(layoutNode) /** * 不忘初心，再次搬出代码： * * val outerCoordinator: NodeCoordinator * get() = layoutNode.nodes.outerCoordinator * * 1. 哦，原来如此： * layoutNode.nodes.outerCoordinator 是 innerCoordinator */ internal var outerCoordinator: NodeCoordinator = innerCoordinator private set ... ...} 代码跟踪到这里就真相显现了，到底是哪个实现类处理了 measure() 方法，你现在清楚了吧？再来看下刚刚的截图： 2.6 InnerNodeCoordinator.measure()所以接下来我们就看看 InnerNodeCoordinator 是如何负责具体测量的： 123456789101112131415161718192021📄 androidx.compose.ui.node --&gt; InnerNodeCoordinator.ktinternal class InnerNodeCoordinator( layoutNode: LayoutNode) : NodeCoordinator(layoutNode) { override fun measure(constraints: Constraints): Placeable = performingMeasure(constraints) { layoutNode.forEachChild { it.measuredByParent = LayoutNode.UsageByParent.NotUsed } // 2. 返回一个 MeasureResult 对象给 replace() 去布局 measureResult = with(layoutNode.measurePolicy) { // 1. 最核心处：这边就是最底层开始测量的工作了 measure(layoutNode.childMeasurables, constraints) } onMeasured() return this }} 分析到这里，关于组件自身的测量和布局流程就跑通了： 我们在代码中所写的 Box、Text 等组件内部会有自己设定的测量数据，他们在代码实际运行过程中会被 Comopse 转换成 LayoutNode 节点（包含所有组件自身的测量数据），然后一层层往下传，最终传到 InnerNodeCoordinator，由它进行最底层的测量工作，测量完成后会返回一个 MeasureResult 对象再交给 replace() 函数完成布局工作。 所以，Do you understand? 三、LayoutModifer 的工作原理 前面我们已经了解了组件自身的测量和布局原理，现在就可以开始分析 LayoutModifer 是如何影响组件的测量和布局了。 就像我们前面说的那样，所有组件最终都会被转换为一个 LayoutNode，这个 LayoutNode 包含了所有的测量数据，那同样它也会包含你对组件设定的 Modifier，所以最终经过一些列转换，也会传到 LayoutNode 里面，而 LayoutNode 里面也有一个 modifier 变量，存储的就是修饰 Composable 函数的 Modifier。 3.1 LayoutNode.Modifer现在我们来看看具体的代码逻辑： 123456789101112// 📄 androidx.compose.ui.node --&gt; LayoutNode.ktinternal class LayoutNode(..) { override var modifier: Modifier = Modifier // 如果有新值变化 set(value) { ... nodes.updateFrom(value) // 关键代码 ... }} 这里的 nodes 应该不陌生了吧？前一节我们已经知道了它是 NodeChain 对象。 1internal val nodes = NodeChain(this) 但是 NodeChain 是什么？其实它就是一个链表，而且是个双向链表。 1234567891011📄 androidx.compose.ui.node --&gt; NodeChain.ktinternal class NodeChain(val layoutNode: LayoutNode) { internal val innerCoordinator = InnerNodeCoordinator(layoutNode) internal var outerCoordinator: NodeCoordinator = innerCoordinator private set internal val tail: Modifier.Node = innerCoordinator.tail internal var head: Modifier.Node = tail private set ...} 头、尾节点都是 Modifier.Node 类型！其中的 NodeCoordinator 是用来辅助 Node 节点处理测量和布局的，其中包含 measure 和 placeAt 的函数逻辑。NodeChain 链表上的每一个 Node 都会对应的绑定一个 NodeCoordinator 对象来辅助处理。（不理解没关系，接着往下看！） 3.2 updateFrom()接下来看看 updateFrom 的具体工作，它主要负责 NodeChain 链表的更新，每当有 Modifier 对象被设置到 LayoutNode 上面，都会调用 updateFrom 函数进行更新对应的 NodeChain。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465📄 androidx.compose.ui.node --&gt; NodeChain.ktinternal class NodeChain(val layoutNode: LayoutNode) { // 负责最内层测量的 NodeCoordinator internal val innerCoordinator = InnerNodeCoordinator(layoutNode) // 负责外层测量的 NodeCoordinator，初始值是 InnerNodeCoordinator internal var outerCoordinator: NodeCoordinator = innerCoordinator private set // 双向链表的尾节点 internal val tail: Modifier.Node = innerCoordinator.tail // 双向链表的头节点 internal var head: Modifier.Node = tail private set ... internal fun updateFrom(m: Modifier) { var coordinatorSyncNeeded = false val paddedHead = padChain() var before = current val beforeSize = before?.size ?: 0 /** * 📝 核心代码 1: * fillVector 会将 Modifier 展开铺平到一个数组， * 后面的代码就可以用这个数组遍历 */ val after = m.fillVector(buffer ?: mutableVectorOf()) var i = 0 // 检查更新差异 if (after.size == beforeSize) { ... // 这段代码不用看，只要加了 Modifier.xx 默认不会走到这边 } else if (!layoutNode.isAttached &amp;&amp; beforeSize == 0) { // 第一次组装 Modifier.Node 双向链表 coordinatorSyncNeeded = true var node = paddedHead while (i &lt; after.size) { val next = after[i] val parent = node /** * 📝 核心代码 2: 组装双向链表的具体逻辑 */ node = createAndInsertNodeAsChild(next, parent) logger?.nodeInserted(0, i, next, parent, node) i++ } syncAggregateChildKindSet() } else if (after.size == 0) { // 删除所有 modifier ... } else { ... } current = after buffer = before?.also { it.clear() } /** * 📝 核心代码 3: 更新头节点 */ head = trimChain(paddedHead) if (coordinatorSyncNeeded) { /** * 📝 核心代码 4: 关联 Modifier.Node 和 NodeCoordinator */ syncCoordinators() } }} 接下来跟着我深入分析每一行核心代码！希望你能沉下心看下去，包教包会！ 📝 分解 Modifier先来看第一个核心代码： 1val after = m.fillVector(buffer ?: mutableVectorOf()) m 就是你的 Modifier 链，这里的 buffer 默认为 null，mutableVectorOf() 其实跟 buffer 一样都是一个可变列表，只是容量不同而已，你只要知道它就是一个列表，用来装分解后的单个 Modifier 用的就行了。 接着我们开始分析 fillVector 函数： 1234567891011121314151617181920212223242526272829303132333435📄 androidx.compose.ui.node --&gt; NodeChain.ktprivate fun Modifier.fillVector( result: MutableVector&lt;Modifier.Element&gt;): MutableVector&lt;Modifier.Element&gt; { val capacity = result.size.coerceAtLeast(16) /** * 1. 创建一个元素为 Modifier 的可变列表，并在初始化后添加传进来的 Modifier， * 从 stack 名字就可以看出来，这里相当于创建了一个栈，并且容量为 16 */ val stack = MutableVector&lt;Modifier&gt;(capacity).also { it.add(this) } // 2. 只要栈不为空，一直循环 while (stack.isNotEmpty()) { // 3. 从栈中移除并获取最后一个元素，存到 next 变量中 when (val next = stack.removeAt(stack.size - 1)) { // 4. 如果 next 是 CombinedModifier 类型 is CombinedModifier -&gt; { stack.add(next.inner) // 把 inner 部分加入到 stack 中 stack.add(next.outer) // 把 outer 部分加入到 stack 中 } // 5. 如果 next 是 Modifier.Element 类型，则直接加到 result 中 is Modifier.Element -&gt; result.add(next) /** * 6. 如果 next 是 Modifier 的其他实现，可能我们不知道具体实现细节， * 把 it（可能是 Modifier.Element 的实例）加入到 result 中 */ else -&gt; next.all { result.add(it) true } } } // 7. 在处理完所有的元素之后，返回 result，它包含了所有的 Modifier.Element return result} 这个函数其实就是创建了一个 Modifier 调用栈，以便可以迭代地处理一个可能嵌套的 Modifier 结构。栈的使用是为了在不使用递归的情况下扁平化修饰符的结构。 注意！从 1.3.0-beta01 版本开始，Compose 中不再使用 foldIn/foldOut 函数对 Modifier 进行遍历了，在 1.3.0-beta01 之前的版本 LayoutNode 源码中是通过 foldOut 遍历 + 头插法处理，而现在是通过 fillVector 函数处理达到类似的效果。 看的懂吗？是不是很懵？我们来个实际例子吧，比如传入的 Modifier 链如下： 1234567891011// 这是你写的代码Box(Modifier.padding(10.dp).size(20.dp))// 此时 Modifier 链为:modifierChain = Modifier.padding(10.dp).size(20.dp)// 实际的结构：CombinedModifier( PaddingElement // outer SizeElement // inner) 我们来看看 fillVector 是怎么处理它的： &nbsp;&nbsp;&nbsp;&nbsp;➡️ 1. 当调用 fillVector 函数时，初始状态是 modifierChain 放入了一个空的 stack 中。 &nbsp;&nbsp;&nbsp;&nbsp;➡️ 2. 此时 stack 不为空，开始循环： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;🔸 removeAt 从 stack 的末尾（最后加入的元素）移除 CombinedModifier（因为它是链中最后一个元素），并将其赋值给 next。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;🔸 next 是一个 CombinedModifier 实例，此时就把 inner 和 outer 分别加进 stack 中，这个时候 stack 里面就又有了两个元素：[SizeElement, PaddingElement]。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;🔸 再次循环，这个时候再次开始 removeAt 从末尾取，先取到 PaddingElement，条件判断发现它是一个 Modifier.Element，那就把它加进 result 里面（result 也是一个可变列表）。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;🔸 继续循环，又取到了 SizeElement，发现它也是一个 Modifier.Element，那就直接加进 result 里面。 &nbsp;&nbsp;&nbsp;&nbsp;➡️ 3. 继续循环，啪～ stack 没东西了，循环结束，直接返回 result 结果：[PaddingElement, SizeElement]。 这段流程我给你画了张图： 📝 构建双向链表现在我们来分析第二段核心代码： 123456789101112131415// NodeChain.kt} else if (!layoutNode.isAttached &amp;&amp; beforeSize == 0) { // 第一次组装 Modifier.Node 双向链表 coordinatorSyncNeeded = true var node = paddedHead 🟡 1. node 初始值是什么？ while (i &lt; after.size) { 🟡 2. after 是什么？ val next = after[i] val parent = node // 📝 核心代码 2: 组装双向链表的具体逻辑 node = createAndInsertNodeAsChild(next, parent) logger?.nodeInserted(0, i, next, parent, node) i++ } syncAggregateChildKindSet()} 我们先来看 node，它是 paddedHead： 1val paddedHead = padChain() 来看下 padChain() 做了什么： 123456789101112// NodeChain.ktinternal val tail: Modifier.Node = innerCoordinator.tailinternal var head: Modifier.Node = tail private set private fun padChain(): Modifier.Node { check(head !== SentinelHead) { &quot;padChain called on already padded chain&quot; } val currentHead = head currentHead.parent = SentinelHead SentinelHead.child = currentHead return SentinelHead} 这个时候 head 默认是 tail，其实就是组件本身：Box。 SentinelHead 是什么？它最主要的作用就是作为一个哨子节点，简化链表操作用的，我们就可以把它理解为在 Box 这个 Modifier.Node 节点前面插入一个哨子节点，它们彼此构成一个双向链表。 我们再来看 after ，它就是先前 result 返回的结果，即：[PaddingElement, SizeElement]，所以 next 会轮流取到这两个 Modifier 进行进一步的操作。 接下来我们来分析 createAndInsertNodeAsParent 函数： 123456789101112131415161718// NodeChain.ktprivate fun createAndInsertNodeAsChild( element: Modifier.Element, parent: Modifier.Node,): Modifier.Node { // 1. 创建一个新的节点 val node = when (element) { // 2. 如果 element 是 ModifierNodeElement 的实例，它会调用 element 上的 create 方法， // 这个方法会返回一个新的 Modifier.Node is ModifierNodeElement&lt;*&gt; -&gt; element.create().also { it.kindSet = calculateNodeKindSetFromIncludingDelegates(it) } else -&gt; BackwardsCompatNode(element) } ... // 3. 插入到树中 return insertChild(node, parent)} 我们重点来看一下 when() 内部的操作： 首先取到的是 PaddingElement，它是 ModifierNodeElement 的实现类，所以满足条件，接着调用 create() 方法，会把 PaddingElement 包装成一个 Modifier.Node。 现在已经得到了一个 Modifier.Node，接着把它插入树中，我们来看下操作： 1234567891011121314// NodeChain.ktprivate fun insertChild(node: Modifier.Node, parent: Modifier.Node): Modifier.Node { // 1. parent 就是哨子节点，所以 theChild 就是 Box 对应的 Modifier.Node val theChild = parent.child if (theChild != null) { // 2. node 是传进来的 PaddingNode，将两个 Modifier.Node 建立双向链表关系 theChild.parent = node node.child = theChild } // 3. 再把哨子节点跟传进来的 PaddingNode 构建双向链表关系 parent.child = node node.parent = parent return node} 能理解吗？我也给你画了张图： 现在已经处理完了 PaddingElement，循环取值，拿出第二个 SizeElement，继续处理，流程我就不写了直接看图： 至此，第二部构建双向链表的工作就结束了，你发现没有，虽然先处理了 PaddingElement，后处理了 SizeElement，但实际上是把 SizeElement 插入到了 PaddingElement 内部，这其实就跟老版本的 foldIn 从尾部便利然后头插的方式一样，实现了同样的功能。 📝 更新头节点第二段核心代码已经构建好了双向链表，但如果你看过老版本的代码会发现，以前是没有 SentineHead 这个哨子节点的，目前的双向链表的头节点是 SentineHead，它并没有实际的功能上的用处，所以这就是第三步核心代码要做的事，我们来看看： 1234567891011121314// NodeChain.ktprivate fun trimChain(paddedHead: Modifier.Node): Modifier.Node { check(paddedHead === SentinelHead) { &quot;trimChain called on already trimmed chain&quot; } // 1. 取 SentineHead 的子节点，有吗？有 -- 就是 PaddingNode val result = SentinelHead.child ?: tail // 2. 断开 SentineHead 与 PaddingNode 之间的链 result.parent = null SentinelHead.child = null SentinelHead.aggregateChildKindSet = 0.inv() SentinelHead.updateCoordinator(null) check(result !== SentinelHead) { &quot;trimChain did not update the head&quot; } // 3. 返回链，此时链就完全是一个由组件自身的 Node 和 Modifier 的 Node 组成的双向链表了 return result} 代码很简单，就是把 SentineHead 从双向链表中断开去除，这样就是一个新的以 PaddingModifier 为表头的双向链表了。 📝 同步协调器我们前面提到过：NodeCoordinator 是用来辅助 Node 节点处理测量和布局的，其中包含 measure 和 placeAt 的函数逻辑。NodeChain 链表上的每一个 Node 都会对应的绑定一个 NodeCoordinator 对象来辅助处理。 现在 NodeChain 链表已经全部搞定了，那么接下来就要开始对链表上每一个 Modifier.Node 绑定一个 NodeCoordinator，现在我们来看看 syncCoordinator 函数是怎么做的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// NodeChain.ktprivate fun syncCoordinators() { var coordinator: NodeCoordinator = innerCoordinator // tail 就是链表的尾部节点，也就是组件自身的 Modifier.Node // 开始遍历，获取它的父节点，也就是 tail -&gt; SizeNode -&gt; PaddingNode var node: Modifier.Node? = tail.parent while (node != null) { // 判断 Modifier.Node 就是不是 LayoutModifierNode val layoutmod = node.asLayoutModifierNode() // 如果是 LayoutModifierNode if (layoutmod != null) { // 如果节点已有关联的 coordinator，则使用现有的协调器，同时判断此协调器所关联的节点是否变化了， // 如果有变化，则调用 onLayoutModifierNodeChanged() 方法 val next = if (node.coordinator != null) { val c = node.coordinator as LayoutModifierNodeCoordinator val prevNode = c.layoutModifierNode c.layoutModifierNode = layoutmod if (prevNode !== node) c.onLayoutModifierNodeChanged() c } else { // 如果节点没有关联的 coordinator，则创建一个 LayoutModifierNodeCoordinator， // 并通过 updateCoordinator 方法将这个新协调器和节点相关联 val c = LayoutModifierNodeCoordinator(layoutNode, node) node.updateCoordinator(c) c } // 不论是使用旧的还是新建的 coordinator，通过设置 wrappedBy 和 wrapped 属性， // 建立当前 coordinator 与下一个 coordinator 的包装关系， // 然后将 coordinator 变量更新为下一个 coordinator // 例如我们这边的例子：tail -&gt; SizeNode coordinator.wrappedBy = next // InnerCoordinator 被谁包裹？-- LayoutModifierNodeCoordinator next.wrapped = coordinator // LayoutModifierNodeCoordinator 包裹了谁？-- InnerCoordinator coordinator = next // 更新 coordinator，比如后面再跟 PaddingNode 建立包裹关系 } else { // 如果 node 不是布局修饰符节点，直接调用 updateCoordinator 方法来更新协调器， // 将 node 和 NodeCoordinator 挂接关联 // 比如： // Modifier.background().size() // 这里 Modifier.background() 转换后的 Node 对应的 NodeCoordinator // 为 SizeNode 对应的 NodeCoordinator node.updateCoordinator(coordinator) } // 在每次迭代结束时，将 node 变量更新为当前节点的父节点 node.parent，为下一次循环准备 // 也就是获取 SizeNode 的父节点 -- PaddingNode，继续处理 node = node.parent } coordinator.wrappedBy = layoutNode.parent?.innerCoordinator outerCoordinator = coordinator // 调整外层 NodeCoordinator} 看懂了吗？我又画了一张图： 现在让我们简单总结下 updateFrom() 的处理步骤： 在 Composable 编写的 Modifier 是层层嵌套的，首先需要将 Modifier 集合铺平到一个数组中； 如果 NodeChain 还没有组装过双向链表，遍历步骤一铺平的 Modifier 数组组装成双向链表，否则就对双向链表增量更新； 更新双向链表头节点； 将 Modifier 和所属的 NodeCoordinator 挂接关联。 现在去除代码分析部分，再来看一个整体思维模型图： 看到这里，所有的 Modifier 处理完了，接下来就可以开始测量了，你还记得第二节我们讲的组件自身测量的代码逻辑吗？我估计你看到这，应该已经全忘了，所以再看一下流程图吧： 看到没？是谁测量的？– outerCoordinator！ outerCoordinator 对象就是做实际测量工作的，所以开始测量的时候，从哪开始测？不用我说了吧？ 3.3 LayoutModifierNodeCoordinator.measure()我们看下 LayoutModifierNodeCoordinator 是怎么做测量的： 123456789101112131415161718192021222324// LayoutModifierNodeCoordinator.ktinternal class LayoutModifierNodeCoordinator( layoutNode: LayoutNode, measureNode: LayoutModifierNode,) : NodeCoordinator(layoutNode) { override fun measure(constraints: Constraints): Placeable { performingMeasure(constraints) { // 1. 核心代码，with 包含了 LayoutModifierNode，提供了一个 LayoutModifierNode 的上下文 with(layoutModifierNode) { measureResult = if (this is IntermediateLayoutModifierNode) { ... } else { // 2. 这里的 wrappedNonNull 是什么？我们后面马上就说到 measure(wrappedNonNull, constraints) } this@LayoutModifierNodeCoordinator } } onMeasured() return this }} 3.4 LayoutModifierNode.measure()measure() 的工作会跳转到哪里，是由 with() 决定的，它提供了 LayoutModifierNode 上下文，所以 measure() 跳转到了 LayoutModifierNode 里面。 12345678910// LayoutModifierNode.ktinterface LayoutModifierNode : Remeasurement, DelegatableNode { fun MeasureScope.measure( measurable: Measurable, constraints: Constraints ): MeasureResult ... ...} LayoutModifierNode 只是一个接口，所以具体的测量实现在哪？ 这里我们要分两种场景来看： 1. 我们首先来看最简单的一种情况：Modifier.layout() 比如我们文章前面写过的一个例子： 1234567891011121314151617181920212223class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.background(Color.Green)) { Text(&quot;Hi Compose&quot;, // here，熟悉吗？ Modifier.layout { measurable, constraints -&gt; val paddingPx = 10.dp.roundToPx() val placeable = measurable.measure(constraints.copy( maxWidth = constraints.maxWidth - paddingPx * 2, maxHeight = constraints.maxHeight - paddingPx * 2 )) layout(placeable.width + paddingPx * 2, placeable.height + paddingPx * 2) { placeable.placeRelative(paddingPx, paddingPx) } }) } } } }} 点进 Modifier.layout {} 看源码： 1234567891011// LayoutModifier.ktfun Modifier.layout( measure: MeasureScope.(Measurable, Constraints) -&gt; MeasureResult) = this then LayoutElement(measure)private data class LayoutElement( val measure: MeasureScope.(Measurable, Constraints) -&gt; MeasureResult) : ModifierNodeElement&lt;LayoutModifierImpl&gt;() { override fun create() = LayoutModifierImpl(measure) ... ...} 再点击 LayoutModifierImpl 进去看看： 12345678910111213internal class LayoutModifierImpl( var measureBlock: MeasureScope.(Measurable, Constraints) -&gt; MeasureResult) : LayoutModifierNode, Modifier.Node() { // 看！！！是不是重写了 MeasureScope.measure 方法 ? 所以具体测量工作就在这里了。 override fun MeasureScope.measure( measurable: Measurable, constraints: Constraints ) = measureBlock(measurable, constraints) override fun toString(): String { return &quot;LayoutModifierImpl(measureBlock=$measureBlock)&quot; }} 这里 measure 直接调用了 measureBlock()，它是参数传进来的，往回退： 1234567891011// LayoutModifier.ktfun Modifier.layout( measure: MeasureScope.(Measurable, Constraints) -&gt; MeasureResult) = this then LayoutElement(measure)private data class LayoutElement( val measure: MeasureScope.(Measurable, Constraints) -&gt; MeasureResult) : ModifierNodeElement&lt;LayoutModifierImpl&gt;() { override fun create() = LayoutModifierImpl(measure) ... ...} measureBlock 又是 measure，而 measure 是啥？就是你主代码里面写在 Modifier.layout {} 里面的测量和布局逻辑，这就相当于实现了将内部的测量结果暴露给上层，让我们能修饰做二次测量处理。 2. 现在我们再来看第二种场景：Modifier.padding(10.dp).size(20.dp) 这个例子不用多说了吧，之前分析源码就是基于它，这个场景就要关联到我们刚刚提到的 wrappedNonNull 了。 1234567891011121314151617181920212223242526// LayoutModifierNodeCoordinator.ktinternal class LayoutModifierNodeCoordinator( layoutNode: LayoutNode, measureNode: LayoutModifierNode,) : NodeCoordinator(layoutNode) { // 2. wrapped 是 LayoutModifierNodeCoordinator 的内部 NodeCoordinator val wrappedNonNull: NodeCoordinator get() = wrapped!! override fun measure(constraints: Constraints): Placeable { performingMeasure(constraints) { with(layoutModifierNode) { measureResult = if (this is IntermediateLayoutModifierNode) { ... } else { // 1. 这里的 wrappedNonNull 是什么？ measure(wrappedNonNull, constraints) } this@LayoutModifierNodeCoordinator } } onMeasured() return this }} 注释写的很清楚：wrapped 是最外层 LayoutModifierNodeCoordinator 的内部 NodeCoordinator，是谁？ ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/960dbde487b0d351e1f6bf144eff8b9e.png#pic_center =700x) 所以你能看出什么门道吗？流程很清晰：测量过程中会从外往里执行每一个 NodeCoordinator 的 measure 方法，直到触底遇到组件自身的 InnerNodeCoordinator，它负责自身的测量。 流程如下： 我们要给 Box 增加 10dp 的 padding，但此时还不知道组件本身大小，所以就需要先测量内部，会先去找 10dp 套着的内部； 现在内部要设定 20dp 的 size，但仍然不知道组件本身大小，需要先测量内部，继续往下找它的内部； 找到了具体组件 Box，它是 InnerNodeCoordinator，InnerNodeCoordinator 已经没有内部了，所以 Box 按照自己的测量方式去测量拿到测量结果； InnerNodeCoordinator 测量出结果后，往上传给要设定 size 的 LayoutModifierNode，在测量结果上设定 20dp 的 size 后返回测量结果； 拿到设定 20dp size 的测量结果后，再往上传给要加 padding 的 LayoutModifierNode，在测量结果上再添加 10dp 的 padding，LayoutNode 拿到最终的测量结果。","link":"/2024/09/13/Compose%20--%20Modifier%20--%2003.%20%E8%A7%A3%E6%9E%90%20Modifier.layout()/"},{"title":"解析 ParentDataModifier","text":"“ Jetpack Compose - - Modifier 系列文章 “ &nbsp;&nbsp;&nbsp;&nbsp;📑 《 深入解析 Compose 的 Modifier 原理 - - Modifier、CombinedModifier 》 &nbsp;&nbsp;&nbsp;&nbsp;📑 《 深度解析 Compose 的 Modifier 原理 - - Modifier.composed()、ComposedModifier 》 &nbsp;&nbsp;&nbsp;&nbsp;📑 《 深入解析 Compose 的 Modifier 原理 - - Modifier.layout()、LayoutModifier 》 &nbsp;&nbsp;&nbsp;&nbsp;📑 《 深度解析 Compose 的 Modifier 原理 - - DrawModifier 》 &nbsp;&nbsp;&nbsp;&nbsp;📑 《 深度解析 Compose 的 Modifier 原理 - - PointerInputModifier 》 &nbsp;&nbsp;&nbsp;&nbsp;📑 《 深度解析 Compose 的 Modifier 原理 - - ParentDataModifier 》 其实原理性分析的文章，真的很难讲的通俗易懂，讲的简单了就没必要写了，讲的繁琐难懂往往大家也不乐意看，所以只能尽量想办法，找个好的角度（比如从 Demo 代码示例出发）慢慢带着大家去钻源码，如果确实能帮助到大家完全理解了文章所讲述到的源码理论，那就值了。 在正式开始分析 DrawModifier 之前，建议你先看看 【LayoutModifier 和 Modifier.layout 用法及原理】这篇文章，毕竟它是作为 Modifier 原理解析的第一篇文章，对你了解整个 Modifier 架构还是很有帮助的，或者说它是最基础的一篇文章，如果不熟悉，后面的系列 Modifier 你可能会看的比较费劲… … ParentDataModifier 的作用123456789101112131415class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Row() { Box(Modifier.size(40.dp).background(Color.Red)) Box(Modifier.size(40.dp).background(Color.Green)) Box(Modifier.size(40.dp).background(Color.Blue)) } } } }} 这段代码很简单，横向布局显示三个 Box，效果如下： 如果我希望这三个方块可以平分横向布局的空间，该怎么做？ 123456789101112131415class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Row() { Box(Modifier.size(40.dp).background(Color.Red).weight(1f)) Box(Modifier.size(40.dp).background(Color.Green).weight(1f)) Box(Modifier.size(40.dp).background(Color.Blue).weight(1f)) } } } }} 只要给每个 Box 添加 Modifier.weight(1f) 即可，相当于传统布局里面 LinearLayout 的 android:layout_weight。 从效果来看，Modifier.weight() 与测量布局有关，那说明它内部是一个 LayoutModifier？我们来看下： 1234567891011121314151617181920interface RowScope { @Stable fun Modifier.weight( /*@FloatRange(from = 0.0, fromInclusive = false)*/ weight: Float, fill: Boolean = true ): Modifier}internal object RowScopeInstance : RowScope { @Stable override fun Modifier.weight(weight: Float, fill: Boolean): Modifier { require(weight &gt; 0.0) { &quot;invalid weight $weight; must be greater than zero&quot; } return this.then( LayoutWeightImpl( ... ... ) ) }} then 套了一个 LayoutWeightImpl： 1234567internal class LayoutWeightImpl( val weight: Float, val fill: Boolean, inspectorInfo: InspectorInfo.() -&gt; Unit) : ParentDataModifier, InspectorValueInfo(inspectorInfo) { ... ...} 原来 Modifier.weight 是创建了一个 ParentDataModifier，而不是 LayoutModifier，难道 ParentDataModifier 是 LayoutModifier 的一个子接口？ 123interface ParentDataModifier : Modifier.Element { fun Density.modifyParentData(parentData: Any?): Any?} 很明显，ParentDataModifier 就只继承了 Modifier.Element 接口，与 LayoutModifier 无关。 ParentDataModifier 实际上是一个辅助的 Modifier，用于给外层包裹的 Composable 使用的，更具体讲是提供给被设置的子组件的父组件在测量子组件的时候使用，让父组件能更好的测量子组件。 123456Row() { // ParentDataModifier 是提供给 Row 使用的帮助测量 Box Box(Modifier.size(40.dp).background(Color.Red).weight(1f)) Box(Modifier.size(40.dp).background(Color.Green).weight(1f)) Box(Modifier.size(40.dp).background(Color.Blue).weight(1f))} 而 LayoutModifier 它只能作用于单一的组件，即对单一的组件处理测量布局，比如上面例子的 Box()，对 Box() 设置的 LayoutModifier 只会它自己生效。 1234567Row() { // 三个组件都设置了 Modifier.weight()，依靠单一组件无法测量出需要多少宽度 // 需要互相知道组件宽度才能确定自己宽度 Box(Modifier.size(40.dp).background(Color.Red).weight(1f)) Box(Modifier.size(40.dp).background(Color.Green).weight(1f)) Box(Modifier.size(40.dp).background(Color.Blue).weight(1f))} 为了能测量出子组件所需要的宽度/高度，Compose 提供了 ParentDataModifier 方案，让父组件协助计算测量。 所以：ParentDataModifier 虽然设置给子组件，但却是提供给父组件使用的数据，辅助子组件进行尺寸测量和绘制计算的。","link":"/2024/09/28/Compose%20--%20Modifier%20--%2006.%20%E8%A7%A3%E6%9E%90%20ParentDataModifier/"},{"title":"解析 PointerInputModifier","text":"“ Jetpack Compose - - Modifier 系列文章 “ &nbsp;&nbsp;&nbsp;&nbsp;📑 《 深入解析 Compose 的 Modifier 原理 - - Modifier、CombinedModifier 》 &nbsp;&nbsp;&nbsp;&nbsp;📑 《 深度解析 Compose 的 Modifier 原理 - - Modifier.composed()、ComposedModifier 》 &nbsp;&nbsp;&nbsp;&nbsp;📑 《 深入解析 Compose 的 Modifier 原理 - - Modifier.layout()、LayoutModifier 》 &nbsp;&nbsp;&nbsp;&nbsp;📑 《 深度解析 Compose 的 Modifier 原理 - - DrawModifier 》 &nbsp;&nbsp;&nbsp;&nbsp;📑 《 深度解析 Compose 的 Modifier 原理 - - PointerInputModifier 》 &nbsp;&nbsp;&nbsp;&nbsp;📑 《 深度解析 Compose 的 Modifier 原理 - - ParentDataModifier 》 其实原理性分析的文章，真的很难讲的通俗易懂，讲的简单了就没必要写了，讲的繁琐难懂往往大家也不乐意看，所以只能尽量想办法，找个好的角度（比如从 Demo 代码示例出发）慢慢带着大家去钻源码，如果确实能帮助到大家完全理解了文章所讲述到的源码理论，那就值了。 在正式开始分析 DrawModifier 之前，建议你先看看 【LayoutModifier 和 Modifier.layout 用法及原理】这篇文章，毕竟它是作为 Modifier 原理解析的第一篇文章，对你了解整个 Modifier 架构还是很有帮助的，或者说它是最基础的一篇文章，如果不熟悉，后面的系列 Modifier 你可能会看的比较费劲… … 在 Compose 中处理点击事件，最简单的方式就是：Modifier.clickable。 123456789101112131415class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.size(40.dp) .background(Color.Green) .clickable { // 单击处理，添加逻辑 }) { } } } }} 但 Modifier.clickable() 只能处理单击事件，如果你需要处理长按、双击等事件，则需要用到另外一个函数：Modifier.combinedClickable()。 12345678910111213141516class MainActivity : ComponentActivity() { @OptIn(ExperimentalFoundationApi::class) override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.size(40.dp) .background(Color.Green) .combinedClickable { }) { } } } }} combinedClickable() 是 Modifier 的一个扩展函数： 12345678910@ExperimentalFoundationApifun Modifier.combinedClickable( enabled: Boolean = true, onClickLabel: String? = null, role: Role? = null, onLongClickLabel: String? = null, onLongClick: (() -&gt; Unit)? = null, // 长按 onDoubleClick: (() -&gt; Unit)? = null, // 双击 onClick: () -&gt; Unit // 单击) 从函数的字面意思就可以知道它是一个组合类型的 clickable，可以通过参数指定单击类型，如果不填写任何参数，那它跟 clickable 没有任何区别。 123Modifier.clickable { }// 无参数情况下，等同Modifier.combinedClickable { } 现在我们来测试下 combinedClickable 的用法： 12345678910111213141516171819202122class MainActivity : ComponentActivity() { @OptIn(ExperimentalFoundationApi::class) override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.size(40.dp) .background(Color.Green) .combinedClickable( onLongClick = { println(&quot;@@@ 长按了 Box&quot;) }, onDoubleClick = { println(&quot;@@@ 双击了 Box&quot;) } ) { // onClick() println(&quot;@@@ 单击了 Box&quot;) }) { } } } }} 上面只是满足点击监听的需求，如果需要复杂的触摸反馈定制（类似于 View 的 onTouchEvent），我们可以使用另外一个扩展函数：Modifier.pointerInput()。 12345678910111213141516class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.size(40.dp) .background(Color.Green) .pointerInput(Unit) { detectTapGestures() } ) } } }} 我们来看看 detectTapGestures() 函数： 123456suspend fun PointerInputScope.detectTapGestures( onDoubleTap: ((Offset) -&gt; Unit)? = null, // 双击 onLongPress: ((Offset) -&gt; Unit)? = null, // 长按 onPress: suspend PressGestureScope.(Offset) -&gt; Unit = NoPressGesture, // 触摸到即触发 onTap: ((Offset) -&gt; Unit)? = null // 单击) 它一样可以监听双击、长按、单击事件，唯独多了一个 onPress，那跟 combinedClickable 有什么区别？ Modifier.combinedClickable() 和 detectTapGestures() 的区别在于它们的级别或者说定制深度上是不同的，detectTapGestures() 是更底层的一种实现，实际上 Modifier.combinedClickable() 底层也是使用 detectTapGestures() 实现的。 123456789101112131415161718192021@ExperimentalFoundationApifun Modifier.combinedClickable(...) = composed(...) { Modifier.combinedClickable(...)}@ExperimentalFoundationApifun Modifier.combinedClickable(...) = composed( factory = { ... ... val gesture = Modifier.pointerInput(interactionSource, hasLongClick, hasDoubleClick, enabled) { centreOffset.value = size.center.toOffset() detectTapGestures( onDoubleTap = ..., onLongPress = ..., onPress = ..., // onPress 并没有暴露出来 onTap = ... ) } ... ...) 如果还要做更复杂的触摸反馈且完全由我们自己控制，Compose 还提供了 awaitPointerEventScope()，让我们可以监听每个触摸事件： 123456789101112131415161718192021class MainActivity : ComponentActivity() { @OptIn(ExperimentalFoundationApi::class) override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.size(40.dp) .background(Color.Green) .combinedClickable { } .pointerInput(Unit) { awaitPointerEventScope { // 这里面就要完全自定义触摸事件处理逻辑了 val down = awaitFirstDown() // 获取一个按压事件 } } ) } } }} 这样就可以在 awaitPointerEventScope 内部进行触摸事件处理了，但往往我们还会给 awaitPointerEventScope 套一层 forEachGesture。 123456789101112131415161718192021222324class MainActivity : ComponentActivity() { @OptIn(ExperimentalFoundationApi::class) override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.size(40.dp) .background(Color.Green) .combinedClickable { } .pointerInput(Unit) { forEachGesture { awaitPointerEventScope { val down = awaitFirstDown() } } } ) { } } } }} forEachGesture() ：循环检测每个事件，否则 awaitPointerEventScope() 监听一次点击之后就会失效。 其实 detectTapGestures 内部也是用 awaitPointerEventScope() 实现的： 1234567891011suspend fun PointerInputScope.detectTapGestures(...) = coroutineScope { val pressScope = PressGestureScopeImpl(this@detectTapGestures) forEachGesture { awaitPointerEventScope { val down = awaitFirstDown() down.consume() ... ... } }} Modifier.pointerInput() 内部使用的 detectXxxGesture() 几乎无一例外都是使用的该方案监听触摸事件。 ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/149a2f06efeb34d151021e4efe132e58.png =700x) 至此，我们已经简单了解了 Modifier.pointerIput() 怎么使用，接下来开始分析定制的触摸反馈是怎么影响到界面展示的。 如果你已经看过 【 DrawModifier 原理解析】 的文章，那么对 PointerInputModifier 的处理位置应该会不陌生了。 我们直接看源码： 12345678910111213141516171819202122232425262728293031override var modifier: Modifier = Modifier set(value) { ... ... val outerWrapper = modifier.foldOut(innerLayoutNodeWrapper) { mod, toWrap -&gt; if (mod is RemeasurementModifier) { mod.onRemeasurementAvailable(this) } toWrap.entities.addBeforeLayoutModifier(toWrap, mod) // here if (mod is OnGloballyPositionedModifier) { getOrCreateOnPositionedCallbacks() += toWrap to mod } val wrapper = if (mod is LayoutModifier) { // Re-use the layoutNodeWrapper if possible. (reuseLayoutNodeWrapper(toWrap, mod) ?: ModifiedLayoutNode(toWrap, mod)).apply { onInitialize() updateLookaheadScope(mLookaheadScope) } } else { toWrap } wrapper.entities.addAfterLayoutModifier(wrapper, mod) wrapper } ... ... } 对 PointerInputModifier 的处理和 DrawModifier 一样： 1toWrap.entities.addBeforeLayoutModifier(toWrap, mod) // here 我们跟踪进去： 123456789fun addBeforeLayoutModifier(layoutNodeWrapper: LayoutNodeWrapper, modifier: Modifier) { if (modifier is DrawModifier) { add(DrawEntity(layoutNodeWrapper, modifier), DrawEntityType.index) } if (modifier is PointerInputModifier) { add(PointerInputEntity(layoutNodeWrapper, modifier), PointerInputEntityType.index) } ... ...} 现在看就很明显了，PointerInputModifier 跟 DrawModifier 的存储方式一摸一样。在存储时也会将 PointerInputModifier 包装到一个链表中，后续新加的 PointerInputModifier 会用头插法插入链表头部。 那么分析到这里就可以有两个猜测： 1、既然 DrawModifier 也是对最接近的右边的 LayoutModifier 生效，PointerInputModifier 是不是也是一样的？ 123// PointerInputModifier 对右边的 LayoutModifier 生效// 想要对哪个 LayoutModifier 生效，就把 PointerInputModifier 写在哪个的左边Modifier.pointerInput().padding() 2、连续的 PointerInputModifier，最左边的 PointerInputModifier 会包含右边的 PointerInputModifier？ 123// 两个 PointerInputModifier 影响着 LayoutModifier// 两个 PointerInputModifier 是父子关系，最左边的 PointerInputModifier 管理右边的 PointerInputModifier Modifier.pointerInput().pointerInput().size() 现在我们从源码角度来看看这两个猜测是否正确。 1234567891011121314151617// LayoutNode.ktinternal fun hitTest( pointerPosition: Offset, hitTestResult: HitTestResult&lt;PointerInputFilter&gt;, isTouchEvent: Boolean = false, isInLayer: Boolean = true) { val positionInWrapped = outerLayoutNodeWrapper.fromParentPosition(pointerPosition) outerLayoutNodeWrapper.hitTest( LayoutNodeWrapper.PointerInputSource, positionInWrapped, hitTestResult, isTouchEvent, isInLayer )} hitTest() 实际上是做的检测工作，主要的作用是检查触摸事件应该下发给哪个组件，检测后再把事件分发到对应组件。 12345678910111213141516171819202122232425// LayoutNodeWrapper.ktfun &lt;T : LayoutNodeEntity&lt;T, M&gt;, C, M : Modifier&gt; hitTest( hitTestSource: HitTestSource&lt;T, C, M&gt;, pointerPosition: Offset, hitTestResult: HitTestResult&lt;C&gt;, isTouchEvent: Boolean, isInLayer: Boolean) { val head = entities.head(hitTestSource.entityType()) // 获取 PointerInputModifier 链表的头部 if (!withinLayerBounds(pointerPosition)) { ... ... } else if (isPointerInBounds(pointerPosition)) { // A real hit head.hit( hitTestSource, pointerPosition, hitTestResult, isTouchEvent, isInLayer ) } else { ... ... }} 现在我们再来看 head.hit()： 123456789101112131415161718// LayoutNodeWrapper.ktprivate fun &lt;T : LayoutNodeEntity&lt;T, M&gt;, C, M : Modifier&gt; T?.hit( hitTestSource: HitTestSource&lt;T, C, M&gt;, pointerPosition: Offset, hitTestResult: HitTestResult&lt;C&gt;, isTouchEvent: Boolean, isInLayer: Boolean) { if (this == null) { hitTestChild(hitTestSource, pointerPosition, hitTestResult, isTouchEvent, isInLayer) } else { // 核心代码 hitTestResult.hit(hitTestSource.contentFrom(this), isInLayer) { next.hit(hitTestSource, pointerPosition, hitTestResult, isTouchEvent, isInLayer) } }} 首先需要了解一下：hitTestSource.contentFrom(this) 做了什么？– 返回了 PointerInputModifier 链表的头节点内部包含的 PointerInputModifier 自身。 现在我们再往下跟踪： 12345// HitTestResult.ktfun hit(node: T, isInLayer: Boolean, childHitTest: () -&gt; Unit) { hitInMinimumTouchTarget(node, -1f, isInLayer, childHitTest)} 又调用了 hitInMinimumTouchTarget()： 123456789101112131415161718// HitTestResult.ktfun hitInMinimumTouchTarget( node: T, // 1. 这里的 node 就是传进来的 PointInputModifier distanceFromEdge: Float, isInLayer: Boolean, childHitTest: () -&gt; Unit) { val startDepth = hitDepth hitDepth++ ensureContainerSize() values[hitDepth] = node // 2. 将 PointInputModifier 放进一个数组里，记录每个节点 distanceFromEdgeAndInLayer[hitDepth] = DistanceAndInLayer(distanceFromEdge, isInLayer).packedValue resizeToHitDepth() childHitTest() // 3. 又调用了 childHitTest() hitDepth = startDepth} childHitTest 是传进来的，往回找就会发现其实 childHitTest 就是： ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/4aade82133ca282c85f3885865ad19f6.png =700x) 看到了 next ？进行下一个节点的 hit 函数处理，典型的递归调用了。 所以看到这里，我们再看回刚才的两个猜想： 1、既然 DrawModifier 也是对最接近的右边的 LayoutModifier 生效，PointerInputModifier 是不是也是一样的？ 2、连续的 PointerInputModifier，最左边的 PointerInputModifier 会包含右边的 PointerInputModifier？ 这两条猜想都是正确的！","link":"/2024/09/23/Compose%20--%20Modifier%20--%2005.%20%E8%A7%A3%E6%9E%90%20PointerInputModifier/"},{"title":"一文彻底吃透 Compose 中的副作用（附带效应）","text":"Compose 官方：副作用（附带效应）是指发生在可组合函数作用域之外的应用状态的变化。 为什么不能有副作用？首先需要明白 Compose 中关于重组（Recompose）的一个关键特点：可组合函数可以按任何顺序执行。 这是一个官方的示例代码，用于在标签页布局中绘制三个页面： 12345678@Composablefun ButtonRow() { MyFancyNavigation { StartScreen() MiddleScreen() EndScreen() }} 按照传统的应用开发思维，这种代码结构意味着三个页面的绘制是按其出现的顺序依次运行的。但其实不是，如果某个可组合函数包含对其他可组合函数的调用，这些函数可以按任何顺序运行。Compose 可以选择识别出某些界面元素的优先级高于其他界面元素，因而首先绘制这些元素。 这就意味着对 StartScreen、MiddleScreen 和 EndScreen 的调用可以按任何顺序进行的。 那么看下面的操作场景： 123456789@Composablefun ButtonRow() { MyFancyNavigation { // 1. 这里定义了一个全局变量 StartScreen() // 3. 内部修改了这个全局变量 MiddleScreen() // 2. 内部要使用这个变量 EndScreen() }} 前面我们说了，三个可组合函数的调用顺序是不定的，如果按照 1 -&gt; 3 -&gt; 2 的顺序调用，那么功能就会出错，这种行为就是所谓的：发生在可组合函数作用域之外的应用状态的变化，也就是：副作用（附带效应）。 所以 Compose 官方建议：可组合项在理想情况下应该是无副作用的！ 不过你也注意到了：是理想情况下不应该有副作用，但有时副作用又是必要的，它很有用！ 为什么要使用副作用？Compose 中副作用的目的：允许执行与 UI 无关的操作，这些操作以可控且可预测的方式更改可组合函数之外的应用状态。 副作用（如更新数据库或进行网络调用）应与 UI 呈现逻辑分开，以提高代码的性能和可维护性。 Compose 提供了多个可组合函数，例如 SideEffect、LaunchedEffect 和 DisposableEffect，这些函数使开发人员能够有效地管理副作用，方法是将它们与界面渲染逻辑分离并在单独的协程范围内执行它们。 在 Compose 中使用副作用的主要好处是： 改进的性能： 通过在可组合函数之外执行与 UI 无关的操作，UI 呈现逻辑可以保持响应和性能。 更好的代码组织： 通过将非 UI 相关操作与 UI 呈现逻辑分离，代码库变得更易于理解和维护。 更好的调试： 副作用可用于日志记录和分析操作（比如埋点），这可以帮助我们更好地了解应用的行为并识别问题。 总之，Compose 中副作用的目的是通过将非 UI 相关操作与 UI 渲染逻辑分离来提高代码库的性能、可维护性和调试。 副作用📓 SideEffectSideEffect 主要用于在不影响 UI 性能的情况下执行副作用。 SideEffect 应该算是最简单的副作用函数了。我们需要在 Composable 函数中调用它，并传入一个包含我们想要执行的副作用的 lambda。 比如看下面这个代码： 123456789101112131415@Composablefun Counter() { val count = remember { mutableStateOf(0) } // 定义一个用于计数的状态变量 SideEffect { // 使用 SideEffect 记录 count 的当前值 println(&quot;Count is ${count.value}&quot;) // 每次重组时会调用 } Column { Button(onClick = { count.value++ }) { Text(&quot;Increase Count&quot;) } Text(&quot;Counter ${count.value}&quot;) // 每次状态更新时，文本都会更改并触发重组 }} 在此示例中，每当重构 Counter 函数时，SideEffect 函数都会记录 count 状态变量的当前值。 但有一点需要注意，仅当当前可组合函数被重构时，才会触发副作用，而对于任何嵌套的可组合函数，则不会触发。这意味着，如果有一个 Composable 函数调用另一个 Composable 函数，则在重构内部 Composable 函数时，不会触发外部 Composable 函数中的 SideEffect。 什么意思？比如，我把代码改成这样： 1234567891011121314@Composablefun Counter() { val count = remember { mutableStateOf(0) } // 定义一个用于计数的状态变量 SideEffect { // 使用 SideEffect 记录 count 的当前值 println(&quot;Count is ${count.value}&quot;) // 每次重组时会调用 } Column { Button(onClick = { count.value++ }) { Text(&quot;Increase Count ${count.value}&quot;) // 每次点击按钮时，这种重组不会触发外部副作用 } }} 在上面的代码中，单击 Button 时，Text 可组合项将使用新值 count 重新组合，但这不会再次触发 SideEffect。 现在，让我们添加内部副作用，看看它是如何工作的： 1234567891011121314151617@Composablefun Counter() { val count = remember { mutableStateOf(0) } // 定义一个用于计数的状态变量 SideEffect { // 使用 SideEffect 记录 count 的当前值 println(&quot;Count is ${count.value}&quot;) // 每次重组时会调用 } Column { Button(onClick = { count.value++ }) { SideEffect { println(&quot;@@@ Count is ${count.value}&quot;) // 每次重组时会调用 } Text(&quot;Increase Count ${count.value}&quot;) // 每次点击按钮时，这种重组不会触发外部副作用 } }} 再看下运行效果： 这个时候 count 变化就会引发重组，从而 SideEffect 会被调用。一般埋点的需求场景，就很适合用这种方式，可以统计页面或者组件的曝光。 📓 DisposableEffectDisposableEffect 可以理解为 SideEffect 的升级款，它不仅可以实现 SideEffect 的效果，而且内部还提供了一个 onDispose() 方法，用于当某可组合项从 UI 页面消失时做一些释放资源的操作。 比如：DisposableEffect 函数可用于管理不再使用可组合项时需要清理的资源，例如事件侦听器或动画。 下面是如何使用 DisposableEffect 的示例: 12345678910111213141516171819202122232425@Composablefun TimerScreen() { val elapsedTime = remember { mutableStateOf(0) } DisposableEffect(Unit) { val scope = CoroutineScope(Dispatchers.Default) val job = scope.launch { while (true) { delay(1000) elapsedTime.value += 1 println(&quot;@@@ Timer is still working ${elapsedTime.value}&quot;) } } onDispose { job.cancel() } } Text( text = &quot;Elapsed Time: ${elapsedTime.value}&quot;, modifier = Modifier.padding(16.dp), fontSize = 24.sp )} 在此代码中，我们使用 DisposableEffect 启动一个协程，该协程每秒递增 elapsedTime 状态值。我们还使用 DisposableEffect 来确保在不再使用可组合项时取消协程，并清理协程使用的资源。 在 DisposableEffect 的 onDispose 函数中，我们使用存储在 job 中的 Job 实例的 cancel() 方法取消协程。 当 Composable 从 UI 层次结构中删除时，将调用 onDispose 函数，它提供了一种清理 Composable 使用的任何资源的方法。在这种情况下，我们使用 onDispose 来取消协程，并确保清理协程使用的任何资源。 现在重新修改代码，添加 Text() 组件显示与否的逻辑，让我们运行以下代码来查看结果： 12345678910111213141516171819202122232425262728class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { RunTimerScreen() } }}@Composablefun RunTimerScreen() { val isVisible = remember { mutableStateOf(true) } Column( horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Bottom ) { Spacer(modifier = Modifier.height(10.dp)) if (isVisible.value) TimerScreen() Button(onClick = { isVisible.value = !isVisible.value }) { Text(&quot;Hide the timer&quot;) } }} 上面代码中，添加了一个新的 RunTimerScreen 可组合项，允许用户切换 TimerScreen 的可见性。当用户单击“Hide the timer”按钮时，TimerScreen 可组合项将从 UI 层次结构中删除，协程将被取消并清理。 但是要注意： 如果你在 onDispose 函数中没有添加 job.cancel()，即使 TimerScreen 可组合项消失，协程也会继续运行，这就可能会导致泄漏和其他性能问题。 📓 LaunchedEffectLaunchedEffect 是一个 Composable 函数，用于在单独的协程作用域中执行副作用。此函数可用于执行可能需要很长时间的操作（例如网络调用或动画），而不会阻塞 UI 线程。 它需要两个参数 key 和 coroutineScope 块。 123456789class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { LaunchedEffect(key1 = , block = ) } }} 1234fun LaunchedEffect( key1: Any?, block: suspend CoroutineScope.() -&gt; Unit) 在 key 参数中，你可以传递任何状态，因为它是 Any 类型。 在 coroutineScope 块中，您可以传递任何挂起或非挂起的函数。 LaunchEffect 将始终在可组合函数中只运行一次。如果要再次运行 LaunchEffect，则必须在 key 参数中传递随时间变化的任何状态（mutableStateOf ，StateFlow）。 下面是如何使用 LaunchedEffect 的示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { LaunchedEffectComposable() } }}@Composablefun LaunchedEffectComposable() { val isLoading = remember { mutableStateOf(false) } val data = remember { mutableStateOf(listOf&lt;String&gt;()) } // 定义一个 LaunchedEffect 来异步执行长时间运行的操作， // 如果 isLoading.value 发生变化，LaunchedEffect 将取消并重新启动 LaunchedEffect(isLoading.value) { if (isLoading.value) { val newData = fetchData() // 执行长时间运行的操作，例如从网络获取数据 data.value = newData // 使用新数据更新状态 isLoading.value = false } } Column { Button(onClick = { isLoading.value = true }) { Text(&quot;Fetch Data&quot;) } if (isLoading.value) { CircularProgressIndicator() // 显示加载指示器 } else { LazyColumn { items(data.value.size) { index -&gt; Text(text = data.value[index]) } } } }}// 通过暂停协程 3 秒来模拟网络调用private suspend fun fetchData(): List&lt;String&gt; { // Simulate a network delay delay(3000) return listOf(&quot;Item 1&quot;, &quot;Item 2&quot;, &quot;Item 3&quot;, &quot;Item 4&quot;, &quot;Item 5&quot;,)} 在此示例中，当 isLoading 状态变量设置为 true 时，LaunchedEffect 函数执行网络调用以从 API 获取数据。该函数在单独的协程作用域中执行，允许 UI 在执行操作时保持响应。 LaunchedEffect 函数采用两个参数：key（设置为 isLoading.value）和 block（定义要执行的副作用的 lambda）。在本例中，block lambda 调用 fetchData() 函数，该函数通过暂停协程 3 秒钟来模拟网络调用。获取数据后，它会更新 data 状态变量并将 isLoading 设置为 false，从而隐藏加载指示符并显示获取的数据。 LaunchedEffect 参数背后的逻辑： LaunchedEffect 中的 key 参数用于标识 LaunchedEffect 实例，并防止其被不必要地重构。 重构可组合项时，Jetpack Compose 会确定是否需要重绘该项。如果可组合项的状态或属性已更改，或者可组合项调用invalidate，则 Jetpack Compose 将重新绘制可组合项。重绘可组合项可能是一项成本高昂的操作，特别是如果可组合项包含长时间运行的操作或不需要在每次重构可组合项时重新执行的副作用。 通过向 LaunchedEffect 提供 key 参数，我们可以指定一个唯一标识 LaunchedEffect 实例的值。如果 key 参数的值发生变化，Jetpack Compose 会将 LaunchedEffect 实例视为新实例，并再次执行副作用。如果 key 参数的值保持不变，Jetpack Compose 将跳过副作用的执行，并重复使用之前的结果，从而防止不必要的重组。 📓 rememberCoroutineScoperememberCoroutineScope 是 Compose 中的一个可组合函数，它将创建一个与当前组合关联的协程范围，我们可以在其中调用任何挂起函数。 此协程作用域可用于启动新的协程，当组合（可组合函数）不再处于活动状态时，这些协程会自动取消。 rememberCoroutineScope() 创建的 CoroutineScope 对象是每个组合的单例。这意味着，如果在同一组合中多次调用该函数，它将返回相同的协程作用域对象。 看如下代码示例： 12345678910111213141516171819202122232425262728class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { MyComponent() } }}@Composablefun MyComponent() { val coroutineScope = rememberCoroutineScope() val data = remember { mutableStateOf(&quot;&quot;) } Column { Button(onClick = { coroutineScope.launch { // Simulate network call delay(2000) data.value = &quot;Data loaded&quot; } }) { Text(&quot;Load data&quot;) } Text(text = data.value) }} 此处，rememberCoroutineScope 用于创建与 Composable 函数的生命周期绑定的协程范围。这样一来，你就可以高效、安全地管理协程，确保可组合函数消失时取消协程。您可以在范围内使用 launch功能，轻松安全地管理异步操作。 副作用状态📓 rememberUpdateState如果要引用一个值，如果该值发生更改，则不应重新启动，请使用 rememberUpdatedState。当关键参数的值之一更新时，LaunchedEffect 会重新启动，但有时我们希望在不重新启动的情况下捕获效果中更改的值。如果我们有长时间运行的选项，重新启动成本很高，则此过程会很有帮助。 12345678910111213141516171819202122232425262728class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { var dynamicData by remember { mutableStateOf(&quot;&quot;) } LaunchedEffect(Unit) { delay(3000L) dynamicData = &quot;New Compose Text&quot; } MyComponent(title = dynamicData) } }}@Composablefun MyComponent(title: String) { var data by remember { mutableStateOf(&quot;Hi, Compose&quot;) } val updatedData by rememberUpdatedState(title) LaunchedEffect(Unit) { delay(5000L) data = updatedData } Text(text = data)} 最初，title 是一个 “Hi, Compose”。3 秒后，title 变为“New Compose Text”。5 秒后，data也会变为“New Compose Text”，从而触发 UI 的重构。这将更新 Text 可组合项。因此，总延迟为 5 秒，如果我们没有使用 rememberUpdatedState，那么我们必须重新启动第二个 LaunchedEffect，这将需要 8 秒。 📓 produceStateproduceState 会启动一个协程，该协程将作用域限定为可将值推送到返回的 State 的组合。使用此协程将非 Compose 状态转换为 Compose 状态，例如将外部订阅驱动的状态（如 Flow、LiveData 或 RxJava）引入组合。 以下是一个官方示例：展示了如何使用 produceState 从网络加载图像。 1234567891011121314151617181920212223@Composablefun loadNetworkImage( url: String, imageRepository: ImageRepository): State&lt;Result&lt;Image&gt;&gt; { // Creates a State&lt;T&gt; with Result.Loading as initial value // If either `url` or `imageRepository` changes, the running producer // will cancel and will be re-launched with the new inputs. return produceState&lt;Result&lt;Image&gt;&gt;(initialValue = Result.Loading, url, imageRepository) { // In a coroutine, can make suspend calls val image = imageRepository.load(url) // Update State with either an Error or Success result. // This will trigger a recomposition where this State is read value = if (image == null) { Result.Error } else { Result.Success(image) } }} loadNetworkImage 可组合函数会返回可以在其他可组合项中使用的 State。 📓 snapshotFlowsnapshotFlow 主要用于装 Compose 的 State 转换成协程 Flow。 使用 snapshotFlow 可以将 Compose 的 State 对象转换为冷 Flow（冷流）。snapshotFlow 会在收集到块时运行该块，并发出从块中读取的 State 对象的结果。当在 snapshotFlow 块中读取的 State 对象之一发生变化时，如果新值与之前发出的值不相等，Flow 会向其收集器发出新值。 这段解释来自官网，如果比较难以理解，我们拆分下核心思想： snapshotFlow 可以把 Compose 的 State 状态对象转成协程的 Flow Flow 可以同步 State 状态，获取到最新的值 当 State 变化，Flow 也会向收集器发送新值 snapshotFlow 不仅仅只能读取一个 Compose State 对象，可以是多个，只要一个变化即可。 如果还是很难懂，看完下面的代码，你就会明白。 1234567891011121314151617class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { var name by remember { mutableStateOf(&quot;Hi, Compose&quot;) } val flow = snapshotFlow { name } LaunchedEffect(Unit) { flow.collect { println(&quot;@@@: $it&quot;) } } } } }} 让我来解释一下这段代码： 首先创建了一个 Compose 的状态对象：name 用 snapshotFlow 函数把 name 包起来，此时就会得到一个 Flow 对象。（满足核心思想 1） 在协程里面你就可以通过 flow.collect 获取到 “Hi, Compose”。（满足核心思想 2） 现在我来改下这段代码： 12345678910111213141516171819202122class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { var name by remember { mutableStateOf(&quot;Hi, Compose&quot;) } Button(onClick = { name = &quot;Hi, Kotlin&quot; }) { Text(&quot;修改 name，测试流值是否变化&quot;) } val flow = snapshotFlow { name } LaunchedEffect(Unit) { flow.collect { println(&quot;@@@: $it&quot;) } } } } }} 代码中仅仅就添加一个 Button，修改 Compose 的 State 状态值，从 “Hi, Compose” 改成 “Hi, Kotlin”。 随着 Compose 的 State 对象 name 的值改变，Flow 也会同步收到最新的值。（符合核心思想 3） 现在，我们再改下代码： 1234567891011121314151617181920212223class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { var name by remember { mutableStateOf(&quot;Hi, Compose&quot;) } var age by remember { mutableStateOf(20) } Button(onClick = { age = 26 }) { Text(&quot;修改 name，测试流值是否变化&quot;) } val flow = snapshotFlow { &quot;$name, $age&quot; } LaunchedEffect(Unit) { flow.collect { println(&quot;@@@: $it&quot;) } } } } }} 我新增了一个 Compose 的 State 对象：age，这个时候，snapshotFlow 就包了两个 State 对象，再测试一下效果： 点击 Button 后修改了 age 状态的值，Flow 也会收到新值，触发 Log 输出。（符合核心思想 4） 另外，这里的代码示例太简单了，在实际开发中，如果你的需求是需要在协程中获取到 Compose 的状态，然后针对这些最新的状态值做一些后续操作，那么就可以考虑 snapshotFlow。","link":"/2024/10/09/Compose%20--%20%E5%89%AF%E4%BD%9C%E7%94%A8%20&%20%E5%8D%8F%E7%A8%8B%20--%20%E4%B8%80%E6%96%87%E5%BD%BB%E5%BA%95%E5%90%83%E9%80%8F%20Compose%20%E4%B8%AD%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8%EF%BC%88%E9%99%84%E5%B8%A6%E6%95%88%E5%BA%94%EF%BC%89/"},{"title":"状态转移型动画 API：animate*AsState()","text":"animate*AsState 函数应该算是 Jetpack Compose 中最简单的一组动画 API 了，主要用于将某个 UI 状态的变化平滑过渡成动画。它可以帮助开发者在状态切换时，通过动画使界面更自然地过渡。 说的直白一点，它主要用于为单个值添加动画效果。你只需提供结束值（或目标值），该 API 就会从当前值开始向指定值播放动画。 接下来我们先构建一个简单场景： 12345678910111213141516171819202122232425class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { Column{ Image( painter = painterResource(R.drawable.bicycle), contentDescription = null, modifier = Modifier .height(90.dp) .absoluteOffset(x = 0.dp) ) Button(onClick = {}, modifier = Modifier .fillMaxWidth() .wrapContentSize(align = Alignment.Center) ) { Text(text = &quot;Ride&quot;) } } } }} 这是一个极其简单的场景：一个图片，一个 Button，初始效果如下： 现在我们让小刺猬动起来（从左到右），代码可以这样写： 12345678910111213141516171819202122232425262728class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { var offset by remember { mutableStateOf(0.dp) } // 定义偏移变量 Column{ Image( painter = painterResource(R.drawable.bicycle), contentDescription = null, modifier = Modifier .height(90.dp) .absoluteOffset(x = offset) // 获取偏移值 ) Button( onClick = { offset = 335.dp }, // 修改偏移值 modifier = Modifier .fillMaxWidth() .wrapContentSize(align = Alignment.Center) ) { Text(text = &quot;Ride&quot;) } } } }} 如注释说明，我只修改了三个地方，现在来看下效果： 小刺猬确实动起来了，但是这种效果给人的感觉就很生硬，完全称不上是动画，更像是 “瞬间移动”。 现在我们可以开始尝试用 animate*AsState 改善动画效果，写法很简单： 1234567891011121314151617181920212223242526272829class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { // var offset by remember { mutableStateOf(0.dp) } // 定义偏移变量 var offset by remember { animateDpAsState(0.dp) } // 替换为 animateDpAsState Column{ Image( painter = painterResource(R.drawable.bicycle), contentDescription = null, modifier = Modifier .height(90.dp) .absoluteOffset(x = offset) // 获取偏移值 ) Button( onClick = { offset = 335.dp }, // 修改偏移值 modifier = Modifier .fillMaxWidth() .wrapContentSize(align = Alignment.Center) ) { Text(text = &quot;Ride&quot;) } } } }} 如你所见，我仅仅用 animateDpAsState 替换 mutableStateOf 后，就可以对数值的大小实现渐变的调整，但很遗憾，这样直接替换是有红线报错的。 接下来我们一起修复这个报错，最终推导出 animateDpAsState 的正确写法。 首先我们回顾下 remember 的作用：它是防止变量被多次重复初始化的，而 animateDpAsState 天生自带这个能力（它的源码内部是包了 remember 的），所以这里我们可以去掉 remember。 再来回顾下 by 的作用：把左边 offset 变量委托给右边的 mutableStateOf，mutableStateOf 提供了读和写的功能，但是有一个细节需要注意了，我们对比下 mutableStateOf 和 animateDpAsState 函数的定义： 1234fun &lt;T&gt; mutableStateOf( value: T, policy: SnapshotMutationPolicy&lt;T&gt; = structuralEqualityPolicy()): MutableState&lt;T&gt; = createSnapshotMutableState(value, policy) 1234567@Composablefun animateDpAsState( targetValue: Dp, animationSpec: AnimationSpec&lt;Dp&gt; = dpDefaultSpring, label: String = &quot;DpAnimation&quot;, finishedListener: ((Dp) -&gt; Unit)? = null): State&lt;Dp&gt; { } mutableStateOf 返回的是一个 MutableState 对象animateDpAsState 返回的是一个 State 对象 在 Compose 中，State 对象只提供读的功能，你是没办法写的！但例子中 var 就代表 offset 是可写的，这就冲突了。 其实 Android Studio 的报错也提示我们了。 所以现在我们把 var 改成 val： 这里特别说明一下： 波浪线提示是因为随着官方 API 的更新，不带 label 参数的 animateDpAsState 函数被弃用了。 12345678910@Deprecated( &quot;animate*AsState APIs now have a new label parameter added.&quot;, level = DeprecationLevel.HIDDEN)@Composablefun animateDpAsState( targetValue: Dp, animationSpec: AnimationSpec&lt;Dp&gt; = dpDefaultSpring, finishedListener: ((Dp) -&gt; Unit)? = null) 官方建议我们使用带 label 参数的 animateDpAsState，所以如果你就是不想加，也不会影响程序运行（至于为什么官方这么强烈建议加上这个 label 标签，会在别的动画文章里面说明）。 1val offset by animateDpAsState(0.dp, label = &quot;&quot;) 红色地方报错的原因是显而易见的，因为 offset 不可以手动写，那我们该如何修改 offset 值？ 以下是正确的写法： 123456789101112131415161718192021222324252627282930class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var bicycleStart by mutableStateOf(false) setContent { val offset by animateDpAsState(if (bicycleStart) 335.dp else 0.dp, label = &quot;&quot;) Column{ Image( painter = painterResource(R.drawable.bicycle), contentDescription = null, modifier = Modifier .height(90.dp) .absoluteOffset(x = offset) ) Button( onClick = { bicycleStart = !bicycleStart }, modifier = Modifier .fillMaxWidth() .wrapContentSize(align = Alignment.Center) ) { Text(text = &quot;Ride&quot;) } } } }} 既然没法手动修改值，让就通过改变另外一个 bicycleStart 状态，引发重组，从而改变 animateDpAsState 内部的值。 到这里程序就没有任何错误了，这也是 animateDpAsState 的正确写法！ 现在，运行下看看效果：（对比 mutableStateOf 和 animateDpAsState） 效果是很明显的，起码我们能够看出来车是开起来了，而不是瞬间移动。 除了 Dp，Compose 为 Float、Color、Size、Offset、Rect、Int、IntOffset 和 IntSize 都提供了开箱即用的 animate*AsState 函数，用法差不多，不再过多举例了。 至此，animate*AsState() 的基本用法了解完了，就这么简单，但是我们还得细看下这个函数的定义： 1234567@Composablefun animateDpAsState( targetValue: Dp, animationSpec: AnimationSpec&lt;Dp&gt; = dpDefaultSpring, label: String = &quot;DpAnimation&quot;, finishedListener: ((Dp) -&gt; Unit)? = null) 它还有一个核心参数：animationSpec，它是 AnimationSpec 类型，你可以通过可选的 AnimationSpec 参数来自定义「动画规范」（也就是可以实现不同类型的动画效果）。 AnimationSpec 的内容着实不少，作为单独的知识点放在【 AnimationSpec 动画规范 】一文细说。","link":"/2024/07/26/Compose%20--%20%E5%8A%A8%E7%94%BB%20--%2001.%20%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E5%9E%8B%E5%8A%A8%E7%94%BB%20API%EF%BC%9Aanimate*AsState()/"},{"title":"揭开 LoaderTask 的数据加载奥秘 -- AllApps","text":"Step 2: AllApps Workspace 的工作主要分为：「加载全部应用」和「绑定全部应用」，我们一个个来分析。 加载 AllApps 流程解析核心方法：loadAllApps() 负责加载全部应用： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990📄 源码路径：package/app/Launcher3/src/com/android/launcher3/model/LoaderTask.javapublic class LoaderTask implements Runnable { /** * 加载所有用户的应用程序信息，包括图标和其他元数据，主要用于 Launcher 加载显示 * * 返回值：List&lt;LauncherActivityInfo&gt;，包含所有用户的应用列表 */ private List&lt;LauncherActivityInfo&gt; loadAllApps() { testLogD(WORK_TAB_MISSING, &quot;loadingAllApps&quot;); // 从 mUserCache 获取所有用户配置文件，每个用户可能有不同的应用集合 final List&lt;UserHandle&gt; profiles = mUserCache.getUserProfiles(); // 初始化一个空的应用列表，用于存储最终的结果 List&lt;LauncherActivityInfo&gt; allActivityList = new ArrayList&lt;&gt;(); // 清空当前所有的应用列表 mBgAllAppsList.clear(); List&lt;IconRequestInfo&lt;AppInfo&gt;&gt; iconRequestInfos = new ArrayList&lt;&gt;(); // 遍历每个用户 for (UserHandle user : profiles) { // 查询应用列表 final List&lt;LauncherActivityInfo&gt; apps = mLauncherApps.getActivityList(null, user); // 如果某个用户没有应用则返回空列表 if (apps == null || apps.isEmpty()) { return allActivityList; } // 处理静默模式 boolean quietMode = mUserManagerState.isUserQuiet(user); // 创建应用信息 for (int i = 0; i &lt; apps.size(); i++) { // 对每个应用创建 AppInfo 实例 LauncherActivityInfo app = apps.get(i); AppInfo appInfo = new AppInfo(app, user, quietMode); // 创建 IconRequestInfo 用于图标请求 iconRequestInfos.add(new IconRequestInfo&lt;&gt;( appInfo, app, /* useLowResIcon= */ false)); mBgAllAppsList.add( appInfo, app, false); } allActivityList.addAll(apps); } if (FeatureFlags.PROMISE_APPS_IN_ALL_APPS.get()) { // get all active sessions and add them to the all apps list for (PackageInstaller.SessionInfo info : mSessionHelper.getAllVerifiedSessions()) { AppInfo promiseAppInfo = mBgAllAppsList.addPromiseApp( mApp.getContext(), PackageInstallInfo.fromInstallingState(info), false); if (promiseAppInfo != null) { iconRequestInfos.add(new IconRequestInfo&lt;&gt;( promiseAppInfo, /* launcherActivityInfo= */ null, promiseAppInfo.usingLowResIcon())); } } } Trace.beginSection(&quot;LoadAllAppsIconsInBulk&quot;); try { mIconCache.getTitlesAndIconsInBulk(iconRequestInfos); iconRequestInfos.forEach(iconRequestInfo -&gt; mBgAllAppsList.updateSectionName(iconRequestInfo.itemInfo)); } finally { Trace.endSection(); } mBgAllAppsList.setFlags(FLAG_QUIET_MODE_ENABLED, mUserManagerState.isAnyProfileQuietModeEnabled()); mBgAllAppsList.setFlags(FLAG_HAS_SHORTCUT_PERMISSION, hasShortcutsPermission(mApp.getContext())); mBgAllAppsList.setFlags(FLAG_QUIET_MODE_CHANGE_PERMISSION, mApp.getContext().checkSelfPermission(&quot;android.permission.MODIFY_QUIET_MODE&quot;) == PackageManager.PERMISSION_GRANTED); mBgAllAppsList.getAndResetChangeFlag(); // 返回 allActivityList，包含所有加载的 LauncherActivityInfo 对象 return allActivityList; }} 绑定 AllApps 流程解析绑定 AllApps 是通过 LauncherBinder 的 bindAllApps() 函数，在其父类 BaseLauncherBinder 中定义。 123456789101112131415161718192021222324252627282930📄 源码路径：package/app/Launcher3/src/com/android/launcher3/model/BaseLauncherBinder.javapublic abstract class BaseLauncherBinder { /** * Binds the all apps results from LoaderTask to the callbacks UX. * * 负责将应用列表数据绑定到 UI 中 * * 它从后台的应用列表中获取数据，构建一个映射关系，然后通过回调将应用信息传递给前台的 UI 线程来更新显示 */ public void bindAllApps() { // 从后台应用列表：mBgAllAppsList 中浅拷贝出所有 AppInfo 实例，apps 是一个数组，包含了所有的应用信息 AppInfo[] apps = mBgAllAppsList.copyData(); // 获取应用列表的标志位 int flags = mBgAllAppsList.getFlags(); // 使用 Java Stream API，遍历 apps 数组，创建一个 Map 映射 Map&lt;PackageUserKey, Integer&gt; packageUserKeytoUidMap = Arrays.stream(apps).collect( Collectors.toMap( appInfo -&gt; new PackageUserKey(appInfo.componentName.getPackageName(), appInfo.user), appInfo -&gt; appInfo.uid, (a, b) -&gt; a)); // 执行回调任务 executeCallbacksTask(c -&gt; c.bindAllApplications(apps, flags, packageUserKeytoUidMap), mUiExecutor); } } Launcher 加载全部应用1234567891011121314151617181920212223📄 源码路径：package/app/Launcher3/src/com/android/launcher3/Launcher.javapublic class Launcher extends StatefulActivity&lt;LauncherState&gt; implements LauncherExterns, Callbacks, InvariantDeviceProfile.OnIDPChangeListener, PluginListener&lt;LauncherOverlayPlugin&gt; { public void bindAllApplications(AppInfo[] apps, int flags, Map&lt;PackageUserKey, Integer&gt; packageUserKeytoUidMap) { // 检查当前方法是否在 UI 线程中执行 Preconditions.assertUIThread(); // 从 mAppsView：通常代表应用抽屉视图中获取 AllAppsStore 对象 AllAppsStore appsStore = mAppsView.getAppsStore(); // 将应用数据更新到存储库中 appsStore.setApps(apps, flags, packageUserKeytoUidMap); // 关闭可能已失效的弹出窗口 PopupContainerWithArrow.dismissInvalidPopup(this); if (Utilities.ATLEAST_S) { Trace.endAsyncSection(DISPLAY_ALL_APPS_TRACE_METHOD_NAME, DISPLAY_ALL_APPS_TRACE_COOKIE); } } appsStore.setApps()12345678910111213141516📄 源码路径：package/app/Launcher3/src/com/android/launcher3/allapps/AllAppsStore.javapublic class AllAppsStore { /** * Sets the current set of apps and sets mapping for {@link PackageUserKey} to Uid for * the current set of apps. */ public void setApps(AppInfo[] apps, int flags, Map&lt;PackageUserKey, Integer&gt; map) { mApps = apps; mModelFlags = flags; notifyUpdate(); mPackageUserKeytoUidMap = map; }} notifyUpdate()123456789101112131415161718📄 源码路径：package/app/Launcher3/src/com/android/launcher3/allapps/AllAppsStore.javapublic class AllAppsStore { private void notifyUpdate() { if (mDeferUpdatesFlags != 0) { mUpdatePending = true; return; } for (OnUpdateListener listener : mUpdateListeners) { if (TestProtocol.sDebugTracing) { Log.d(WORK_TAB_MISSING, &quot;AllAppsStore#notifyUpdate listener: &quot; + listener); } listener.onAppsUpdated(); } }} onAppsUpdated()1234567891011121314151617181920212223242526272829📄 源码路径：package/app/Launcher3/src/com/android/launcher3/allapps/ActivityAllAppsContainerView.javapublic class ActivityAllAppsContainerView&lt;T extends Context &amp; ActivityContext&gt; extends SpringRelativeLayout implements DragSource, Insettable, OnDeviceProfileChangeListener, PersonalWorkSlidingTabStrip.OnActivePageChangedListener, ScrimView.ScrimDrawingController { private void onAppsUpdated() { // 检查是否有 Work 类型的应用 mHasWorkApps = Stream.of(mAllAppsStore.getApps()).anyMatch(mWorkManager.getMatcher()); if (TestProtocol.sDebugTracing) { Log.d(WORK_TAB_MISSING, &quot;ActivityAllAppsContainerView#onAppsUpdated hasWorkApps: &quot; + mHasWorkApps + &quot; allApps: &quot; + mAllAppsStore.getApps().length); } // 检查当前是否处于 Search 模式 if (!isSearching()) { rebindAdapters(); // 重新绑定适配器，用于刷新 UI，使应用列表更新 if (mHasWorkApps) { mWorkManager.reset(); } } // 记录应用数量的统计数据 mActivityContext.getStatsLogManager().logger() .withCardinality(mAllAppsStore.getApps().length) .log(LAUNCHER_ALLAPPS_COUNT); }} rebindAdapters()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101📄 源码路径：package/app/Launcher3/src/com/android/launcher3/allapps/ActivityAllAppsContainerView.javapublic class ActivityAllAppsContainerView&lt;T extends Context &amp; ActivityContext&gt; extends SpringRelativeLayout implements DragSource, Insettable, OnDeviceProfileChangeListener, PersonalWorkSlidingTabStrip.OnActivePageChangedListener, ScrimView.ScrimDrawingController { protected void rebindAdapters() { rebindAdapters(false /* force */); } protected void rebindAdapters(boolean force) { // 如果搜索动画正在进行中，则设置 mRebindAdaptersAfterSearchAnimation 为 true， // 在动画结束后重新绑定适配器 if (mSearchTransitionController.isRunning()) { mRebindAdaptersAfterSearchAnimation = true; return; } // 更新搜索结果的可见性，确保搜索结果的显示状态与当前布局一致 updateSearchResultsVisibility(); // 决定是否显示标签：Tabs，用于区分个人和工作应用 boolean showTabs = shouldShowTabs(); if (showTabs == mUsingTabs &amp;&amp; !force) { return; } // 如果没有启用搜索结果背景装饰，则从 RecyclerView 中移除并重新添加 ItemDecoration，以确保视觉效果的一致性 if (!FeatureFlags.ENABLE_SEARCH_RESULT_BACKGROUND_DRAWABLES.get()) { RecyclerView.ItemDecoration decoration = getMainAdapterProvider().getDecorator(); getSearchRecyclerView().removeItemDecoration(decoration); getSearchRecyclerView().addItemDecoration(decoration); } // replaceAppsRVcontainer() needs to use both mUsingTabs value to remove the old view AND // showTabs value to create new view. Hence the mUsingTabs new value assignment MUST happen // after this call. // 根据 showTabs 的值替换应用列表的 RecyclerView 容器，以便切换到新的布局 replaceAppsRVContainer(showTabs); mUsingTabs = showTabs; // 在更新视图之前，先注销所有旧的图标容器，以确保新布局中的图标能够正确绑定 mAllAppsStore.unregisterIconContainer(mAH.get(AdapterHolder.MAIN).mRecyclerView); mAllAppsStore.unregisterIconContainer(mAH.get(AdapterHolder.WORK).mRecyclerView); mAllAppsStore.unregisterIconContainer(mAH.get(AdapterHolder.SEARCH).mRecyclerView); // 如果启用了标签模式 if (mUsingTabs) { mAH.get(AdapterHolder.MAIN).setup(mViewPager.getChildAt(0), mPersonalMatcher); mAH.get(AdapterHolder.WORK).setup(mViewPager.getChildAt(1), mWorkManager.getMatcher()); mAH.get(AdapterHolder.WORK).mRecyclerView.setId(R.id.apps_list_view_work); if (FeatureFlags.ENABLE_EXPANDING_PAUSE_WORK_BUTTON.get()) { mAH.get(AdapterHolder.WORK).mRecyclerView.addOnScrollListener( mWorkManager.newScrollListener()); } mViewPager.getPageIndicator().setActiveMarker(AdapterHolder.MAIN); findViewById(R.id.tab_personal) .setOnClickListener((View view) -&gt; { if (mViewPager.snapToPage(AdapterHolder.MAIN)) { mActivityContext.getStatsLogManager().logger() .log(LAUNCHER_ALLAPPS_TAP_ON_PERSONAL_TAB); } mActivityContext.hideKeyboard(); }); findViewById(R.id.tab_work) .setOnClickListener((View view) -&gt; { if (mViewPager.snapToPage(AdapterHolder.WORK)) { mActivityContext.getStatsLogManager().logger() .log(LAUNCHER_ALLAPPS_TAP_ON_WORK_TAB); } mActivityContext.hideKeyboard(); }); setDeviceManagementResources(); onActivePageChanged(mViewPager.getNextPage()); } else { // 如果未启用标签模式，则只设置主页面 (MAIN)，并将 WORK 的 RecyclerView 设为 null mAH.get(AdapterHolder.MAIN).setup(findViewById(R.id.apps_list_view), null); mAH.get(AdapterHolder.WORK).mRecyclerView = null; } // 配置应用抽屉顶部的标题栏内容，例如添加搜索栏或其他工具栏元素 setupHeader(); // 配置滚动条位置 if (isSearchBarOnBottom()) { // Keep the scroller above the search bar. RelativeLayout.LayoutParams scrollerLayoutParams = (LayoutParams) mFastScroller.getLayoutParams(); scrollerLayoutParams.addRule(RelativeLayout.ABOVE, R.id.search_container_all_apps); scrollerLayoutParams.removeRule(RelativeLayout.ALIGN_PARENT_BOTTOM); scrollerLayoutParams.bottomMargin = getResources().getDimensionPixelSize( R.dimen.fastscroll_bottom_margin_floating_search); } // 重新注册新的图标容器 mAllAppsStore.registerIconContainer(mAH.get(AdapterHolder.MAIN).mRecyclerView); mAllAppsStore.registerIconContainer(mAH.get(AdapterHolder.WORK).mRecyclerView); mAllAppsStore.registerIconContainer(mAH.get(AdapterHolder.SEARCH).mRecyclerView); }}","link":"/2024/11/01/Android%20--%20Launcher3%20--%2003.%20%E6%8F%AD%E5%BC%80%20LoaderTask%20%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E5%A5%A5%E7%A7%98%20--%20allapps/"},{"title":"流程定制型动画 API：Animatable()","text":"AnimatableAnimatable 是一个值容器，会在内部储存一个值，它可以在通过 animateTo 更改值时为值添加动画效果。该 API 支持 animate*AsState 的实现。它可确保一致的连续性和互斥性，这意味着值变化始终是连续的，并且会取消任何正在播放的动画。 Animatable 的许多功能（包括 animateTo）以 “挂起函数” 的形式提供。这意味着，它们需要封装在适当的 “协程作用域” 内。例如，你可以使用 LaunchedEffect 可组合项针对指定键值的时长创建一个作用域。 下面我们从代码角度一步步教你 Animatable 的用法，如下： 123456789class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { val anim = Animatable() } }} 注意：Animatable 导包的时候不要选错！！！ 此时，光秃秃的写个 Animatable 是会报错的： 提示我们想要用 Animatable，那就得用 remember 包起来： 又提示我们需要填写 “初始值”，那么这个初始值填什么？我们来看下 Animatable 的定义： 12345678fun Animatable( initialValue: Float, visibilityThreshold: Float = Spring.DefaultDisplacementThreshold) = Animatable( initialValue, Float.VectorConverter, visibilityThreshold) 它需要一个 Float 类型的初始值： 123456789class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { val anim = remember { Animatable(0f) } } }} 当然除了 Float 类型，我们也可以填写 Dp 类型，但需要转换类型，如下这样写也能满足 Animatable 的要求： 123456789class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { val anim = remember { Animatable(0.dp, Dp.VectorConverter) } } }} animateTo()现在 Animatable 创建好了，它内部存储了一个 Dp 类型的值。接下来就可以配置动画了，调用 animateTo() 函数即可。 提示我们：animateTo() 是个 suspend 函数，必须要在「协程」或者「别的挂起函数」里面使用，如下： 123456789101112class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { val anim = remember { Animatable(0.dp, Dp.VectorConverter) } LaunchedEffect(Unit) { anim.animateTo() } } }} 现在只需要在 animateTo() 里面添加目标值即可。 123456789101112class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { val anim = remember { Animatable(0.dp, Dp.VectorConverter) } LaunchedEffect(Unit) { anim.animateTo(335.dp) } } }} 到这里 Animatable 所需要做的工作全部完成了！ 现在我们还是使用【 状态转移型动画 API：animate*AsState() 】一文中的小刺猬作为对象，代码修改如下： 123456789101112131415161718192021222324252627282930313233class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var bicycleStart by mutableStateOf(false) setContent { val offset = remember(bicycleStart) { if (bicycleStart) 335.dp else 0.dp } val anim = remember { Animatable(offset, Dp.VectorConverter) } LaunchedEffect(bicycleStart) { anim.animateTo(offset) } Column{ Image( painter = painterResource(R.drawable.bicycle), contentDescription = null, modifier = Modifier .absoluteOffset(x = anim.value) ) Button( onClick = { bicycleStart = !bicycleStart }, modifier = Modifier .fillMaxWidth() .wrapContentSize(align = Alignment.Center) ) { Text(text = &quot;Ride&quot;) } } } }} 让我来解读下这段代码： 小刺猬骑车的偏移距离取决于 anim 的值，它的值会随着动画逐渐变化。 点击 Button 会改变 bicycleStart 值，bicycleStart 值变化会重新执行 LaunchedEffect 协程，animateTo 会执行，动画再次启动。 bicycleStart 从 false -&gt; true，小刺猬往前骑，true -&gt; false，小刺猬往后骑。 运行： 我们把 mutableStateOf、animate*AsState 和 Animatable() 三者放在一起，做个对比： Animatable 的 animateTo() 可以实现和 animateDpAsState 一样的效果，其实 animateDpAsState 内部实际上也是通过 Animatable 实现动画的。 现在，我们来看下 animateTo() 函数的参数： 123456suspend fun animateTo( targetValue: T, animationSpec: AnimationSpec&lt;T&gt; = defaultSpringSpec, initialVelocity: T = velocity, block: (Animatable&lt;T, V&gt;.() -&gt; Unit)? = null) 它和 animateDpAsState 一样也有一个核心参数：animationSpec，之前我们就说过，它是一个 AnimationSpec 类型，你可以通过可选的 AnimationSpec 参数来自定义动画规范（也就是可以实现不同类型的动画效果）。 这篇文章仍然不会对动画规范做讲解，而是会把它作为单独的知识点放在【 AnimationSpec 动画规范 】一文细说。 snapTo() 除了 animateTo 以外，Animatable 还可以通过 snapTo() 在动画开始前设定「初始值」。 例如下面的代码： 12345678910111213141516171819202122232425262728293031323334class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var bicycleStart by mutableStateOf(false) setContent { val offset = remember(bicycleStart) { if (bicycleStart) 360.dp else 0.dp } val anim = remember { Animatable(offset, Dp.VectorConverter) } LaunchedEffect(bicycleStart) { anim.snapTo(if (bicycleStart) 300.dp else 100.dp) // 指定动画初始值 anim.animateTo(offset) } Column{ Image( painter = painterResource(R.drawable.bicycle), contentDescription = null, modifier = Modifier .absoluteOffset(x = anim.value) ) Button( onClick = { bicycleStart = !bicycleStart }, modifier = Modifier .fillMaxWidth() .wrapContentSize(align = Alignment.Center) ) { Text(text = &quot;Ride&quot;) } } } }} 这个函数的作用不难理解：在动画开始前指定初始值，也就是让动画可以从一个指定的值开始运动，看下面的对比图： 虽然动画很快（默认只有 300ms），但我们还是能看出来 snapTo() 后，小刺猬会跳到指定的值开始运动。","link":"/2024/08/01/Compose%20--%20%E5%8A%A8%E7%94%BB%20--%2002.%20%E6%B5%81%E7%A8%8B%E5%AE%9A%E5%88%B6%E5%9E%8B%E5%8A%A8%E7%94%BB%20API%EF%BC%9AAnimatable()/"},{"title":"过渡动画 API：Transition","text":"Jetpack Compose 提供了一系列功能强大且可扩展的 API，可用于在应用界面中轻松实现各种动画效果。这一系列文章会逐个介绍所有的动画 API，通过最直观的 Demo 示例，手把手教你怎么写动画以及带你了解动画背后的原理。 📑 手把手教你写 Compose 动画 - - 状态转移型动画 API：animate*AsState() 📑 手把手教你写 Compose 动画 - - 流程定制型动画 API：Animatable() 📑 手把手教你写 Compose 动画 - - 讲的不能再细的 AnimationSpec 动画规范 📑 手把手教你写 Compose 动画 - - 过渡动画 API：Transition 📑 手把手教你写 Compose 动画 - - 显示与消失 API：AnimatedVisibility 📑 手把手教你写 Compose 动画 - - 简单页面切换动画 API：Crossfade 📑 手把手教你写 Compose 动画 - - 更强大的多组件切换动画 API：AnimatedContent 📑 手把手教你写 Compose 动画 - - 组件大小变化 API：animateContentSize 📓 动画图表 在每一篇文章开头，我都会放一张 Compose 动画 API 的图表，以便你有最直观的感受。 📓 Transition Transition 是 Compose 中实现过渡动画的关键 API 。所谓过渡动画，即当依赖的某个状态发生改变时连锁发生的一系列动画效果。 前面我们所提到的 animate*AsState 与 Animatable 都是针对一个属性（比如 offset 偏移）进行变换的，而 Transition 允许开发者将多个属性数值绑定到一个状态，当这个状态发生改变时，多个属性同时进行变换。 还是那句话：探索新技术的最佳方式是尝试它们，我们先构建一个简单场景： 12345678910111213141516171819202122232425262728class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { Column ( modifier = Modifier.fillMaxWidth(), verticalArrangement = Arrangement.Center, horizontalAlignment = Alignment.CenterHorizontally ) { Image( painter = painterResource(R.drawable.cr7), contentDescription = null, modifier = Modifier .size(90.dp) .clip(shape = CircleShape) .border(color = Color.Red, shape = CircleShape, width = 3.dp) ) Button( onClick = {} ) { Text(text = &quot;切换&quot;) } } } }} 这段代码极其简单：一个 Image，一个 Button，效果如下： ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/5712010e162d69503d04c38958c7485a.png#pic_center =700x) 现在我们假设一个需求场景： 图片大小 size 需要变化：小图片（90dp）、大图片（130dp） 图片边框颜色 color 需要变化：绿色、红色 对应关系：小图片绿色边框，大图片红色边框 如果要实现这个需求，你会怎么做？目前我们掌握的动画仅有 animate*AsState() 和 Animatable.animateTo()，不如我们先用这两个动画 API 试试效果？ 📚 animate*AsState() 如果我们用 animate*AsState() 来实现这个需求，代码可以这么写： 12345678910111213141516171819202122232425262728293031class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { var bigPic by remember { mutableStateOf(false) } val size by animateDpAsState(if (bigPic) 130.dp else 90.dp, label = &quot;&quot;) val borderColor by animateColorAsState(if (bigPic) Color.Red else Color.Green, label = &quot;&quot;) Column ( modifier = Modifier.fillMaxWidth(), verticalArrangement = Arrangement.Center, horizontalAlignment = Alignment.CenterHorizontally ) { Image( painter = painterResource(R.drawable.cr7), contentDescription = null, modifier = Modifier .size(size) .clip(shape = CircleShape) .border(color = borderColor, shape = CircleShape, width = 3.dp) ) Button( onClick = { bigPic = !bigPic} ) { Text(text = &quot;切换&quot;) } } } }} 你只要认真看过【 animate*AsState 用法 】这篇文章，看这段代码肯定 so easy。 我们需要定义两个 animateDpAsState，分别控制图片大小和文字颜色，效果如下： 📚 Animatable.animateTo 现在我们再来用 Animatable.animateTo 实现这个需求： 12345678910111213141516171819202122232425262728293031323334353637383940414243class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { var bigPic by remember { mutableStateOf(false) } // Size Animatable val size = remember(bigPic) { if (bigPic) 130.dp else 90.dp } val sizeAnim = remember { Animatable(size, Dp.VectorConverter) } LaunchedEffect(bigPic) { sizeAnim.animateTo(size) } // Color Animatable val borderColor = remember(bigPic) { if (bigPic) Color.Red else Color.Green} val borderColorAnim = remember { Animatable(borderColor) } LaunchedEffect(bigPic) { borderColorAnim.animateTo(borderColor) } Column ( modifier = Modifier.fillMaxWidth(), verticalArrangement = Arrangement.Center, horizontalAlignment = Alignment.CenterHorizontally ) { Spacer(modifier = Modifier.height(100.dp)) Image( painter = painterResource(R.drawable.cr7), contentDescription = null, modifier = Modifier .size(sizeAnim.value) .clip(shape = CircleShape) .border(color = borderColorAnim.value, shape = CircleShape, width = 3.dp) ) Button( onClick = { bigPic = !bigPic} ) { Text(text = &quot;切换&quot;) } } } }} 你只要认真看过【 Animatable 用法 】这篇文章，看这段代码肯定也是 so easy。 我们需要定义两个 Animatable，并且需要启动两个协程，分别控制图片大小和文字颜色，效果如下： 📚 updateTransition 重点来了，现在我们开始讲解如何用 Transition 实现这个动画效果。 首先我们需要一个状态，状态可以是任何数据类型。我们通常会自定义一个枚举类型： 123private enum class ImageState { Small, Large} 现在我们再创建一个处理状态的变量： 1var imageState by remember { mutableStateOf(ImageState.Small) } 创建 Transition 对象 Compose 中是通过 updateTransition() 函数来创建 Transition 对象，我们来看下 updateTransition() 函数： 12345@Composablefun &lt;T&gt; updateTransition( targetState: T, label: String? = null): Transition&lt;T&gt; 它有两个参数： targetState：状态变量，当它被更改时，动画会进行。 label：动画的标签。 这里的状态就是我们之前定义的：imageState，所以我们可以像下面这样写： 1val transition = updateTransition(targetState = imageState, label = &quot;ImageState Transition&quot;) updateTransition() 会返回一个 Transition 对象。 现在我们可以使用某个 animate* 扩展函数 来定义此过渡效果中的子动画。为每个状态指定目标值。这些 animate* 函数会返回一个动画值，在动画播放过程中，当使用 updateTransition 更新过渡状态时，该值将逐帧更新。 定制边框颜色过渡 123456val borderColor by transition.animateColor(label = &quot;ImageState Color Transition&quot;) { when (it) { ImageState.Small -&gt; Color.Green ImageState.Large -&gt; Color.Magenta }} 定制图片尺寸过渡 123456val size by transition.animateDp(label = &quot;ImageState Size Transition&quot;) { when (it) { ImageState.Small -&gt; 90.dp ImageState.Large -&gt; 130.dp }} 我们为每个属性状态（borderColor、size）声明了其在不同状态（ImageState.Small、ImageState.Large）时所对应的值，当过度动画所依赖状态（imageState）发生改变时，其中每个属性状态都会得到相应的更新。 应用到组件上（完整代码） 接下来，我们只需将创建的属性状态应用到我们的组件中即可： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354private enum class ImageState { Small, Large}class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { var imageState by remember { mutableStateOf(ImageState.Small) } val transition = updateTransition(targetState = imageState, label = &quot;ImageState Transition&quot;) val borderColor by transition.animateColor(label = &quot;ImageState Color Transition&quot;) { when (it) { ImageState.Small -&gt; Color.Green ImageState.Large -&gt; Color.Magenta } } val size by transition.animateDp(label = &quot;ImageState Size Transition&quot;) { when (it) { ImageState.Small -&gt; 90.dp ImageState.Large -&gt; 130.dp } } Column ( modifier = Modifier.fillMaxWidth(), verticalArrangement = Arrangement.Center, horizontalAlignment = Alignment.CenterHorizontally ) { Image( painter = painterResource(R.drawable.cr7), contentDescription = null, modifier = Modifier .size(size) .clip(shape = CircleShape) .border(color = borderColor, shape = CircleShape, width = 3.dp) ) Button( onClick = { imageState = if (imageState == ImageState.Small) { ImageState.Large } else { ImageState.Small } } ) { Text(text = &quot;切换&quot;) } } } }} 效果如下： 📓 灵魂思考 对于这么一个简单的需求，我们同时用 animate*AsState()、Animatable 和 Transition 都可以实现。 那么我们就该思考一个问题了： 我们可以把 animate*AsState() 可以理解为 Animatable 的一种更简便直接的用法，Compose 创造出这个 API 的目的可以理解； 但是 Animatable 不是已经可以完美的实现了我们的需求了吗？为什么还要造一个 Transition 出来？ 现在我们来解答这个疑惑： 首先我们回顾一下 Animatable 和 Transition 两种动画原理的核心思想。 Animatable Animatable 是面向值的，在多个动画、多个状态的情况下存在不便于管理的问题。 123456789101112131415var bigPic by remember { mutableStateOf(false) }// Size Animatableval size = remember(bigPic) { if (bigPic) 130.dp else 90.dp }val sizeAnim = remember { Animatable(size, Dp.VectorConverter) }LaunchedEffect(bigPic) { sizeAnim.animateTo(size)}// Color Animatableval borderColor = remember(bigPic) { if (bigPic) Color.Red else Color.Green}val borderColorAnim = remember { Animatable(borderColor) }LaunchedEffect(bigPic) { borderColorAnim.animateTo(borderColor)} 针对 size 和 borderColor，我们要创建两个 Animatable，而且还要启动两个协程，如果我们还有多个其他动画，就要像下面这么写： 12345678910111213141516171819202122232425262728293031var bigPic by remember { mutableStateOf(false) }// Size Animatableval size = remember(bigPic) { if (bigPic) 130.dp else 90.dp }val sizeAnim = remember { Animatable(size, Dp.VectorConverter) }LaunchedEffect(bigPic) { sizeAnim.animateTo(size)}// Color Animatableval borderColor = remember(bigPic) { if (bigPic) Color.Red else Color.Green}val borderColorAnim = remember { Animatable(borderColor) }LaunchedEffect(bigPic) { borderColorAnim.animateTo(borderColor)}// Background Animatableval background = remember(bigPic) { ... }val backgroundAnim = remember { Animatable(background) }LaunchedEffect(bigPic) { backgroundAnim.animateTo(background)}// Alpha Animatableval alpha = remember(bigPic) { ... }val alphaAnim = remember { Animatable(alpha) }LaunchedEffect(bigPic) { alphaAnim.animateTo(alpha)}// ..... 你就要不停的启动协程，然后写一堆结构差不多的代码，这还没有算上 bigPic 状态，如果你新增了其他类似 bigPic 的状态，还需要添加更多的状态片段逻辑… Transition Transition 是面向状态的，多个动画可以共用一个状态，能够做到统一的管理。 12345678910111213141516var imageState by remember { mutableStateOf(ImageState.Small) }val transition = updateTransition(targetState = imageState, label = &quot;ImageState Transition&quot;)val borderColor by transition.animateColor(label = &quot;ImageState Color Transition&quot;) { when (it) { ImageState.Small -&gt; Color.Green ImageState.Large -&gt; Color.Magenta }}val size by transition.animateDp(label = &quot;ImageState Size Transition&quot;) { when (it) { ImageState.Small -&gt; 90.dp ImageState.Large -&gt; 130.dp }} updateTransition 只会创建一次协程，而且只需要根据一种状态的变化，就可以控制不同的动画效果。 如果我们还有多个其他动画，就可以这么写： 123456789101112131415161718192021222324252627282930var imageState by remember { mutableStateOf(ImageState.Small) }val transition = updateTransition(targetState = imageState, label = &quot;ImageState Transition&quot;)val borderColor by transition.animateColor(label = &quot;ImageState Color Transition&quot;) { when (it) { ImageState.Small -&gt; Color.Green ImageState.Large -&gt; Color.Magenta }}val size by transition.animateDp(label = &quot;ImageState Size Transition&quot;) { when (it) { ImageState.Small -&gt; 90.dp ImageState.Large -&gt; 130.dp }}val background by transition.animateColor(label = &quot;ImageState Color Transition&quot;) { when (it) { ImageState.Small -&gt; Color.Yellow ImageState.Large -&gt; Color.Magenta }}val alpha by transition.animateFloat(label = &quot;ImageState Alpha Transition&quot;) { when (it) { ImageState.Small -&gt; 0.3f ImageState.Large -&gt; 0.5f }} 结构清晰明了，非常方便。 Transition 除了代码结构和逻辑清晰的优势以外，它还有个更牛逼的功能：支持 Compose 动画预览！ 什么是动画预览呢？我们代码写到现在了，不知道你有没有注意到所有的动画 API 都加上了一个 label 标签参数： 12345678val transition = updateTransition(targetState = imageState, label = &quot;ImageState Transition&quot;)val borderColor by transition.animateColor(label = &quot;ImageState Color Transition&quot;) { when (it) { ImageState.Small -&gt; Color.Green ImageState.Large -&gt; Color.Magenta }} 这个 label 有什么用呢？一会你就知道了。 现在我们看看怎么打开这个 Compose 动画预览功能： 首先我们把代码调整拆到一个自定义 Composable 函数中，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061private enum class ImageState { Small, Large}class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { TransitionPreview() } }}@Composablefun TransitionPreview() { var imageState by remember { mutableStateOf(ImageState.Small) } val transition = updateTransition(targetState = imageState, label = &quot;ImageState Transition&quot;) val borderColor by transition.animateColor(label = &quot;ImageState Color Transition&quot;) { when (it) { ImageState.Small -&gt; Color.Green ImageState.Large -&gt; Color.Magenta } } val size by transition.animateDp(label = &quot;ImageState Size Transition&quot;) { when (it) { ImageState.Small -&gt; 90.dp ImageState.Large -&gt; 130.dp } } Column( modifier = Modifier.fillMaxWidth(), verticalArrangement = Arrangement.Center, horizontalAlignment = Alignment.CenterHorizontally ) { Spacer(modifier = Modifier.height(100.dp)) Image( painter = painterResource(R.drawable.cr7), contentDescription = null, modifier = Modifier .size(size) .clip(shape = CircleShape) .border(color = borderColor, shape = CircleShape, width = 3.dp) ) Button( onClick = { imageState = if (imageState == ImageState.Small) { ImageState.Large } else { ImageState.Small } } ) { Text(text = &quot;切换&quot;) } }} 现在我们给 TransitionPreview() 函数添加 @Preview 注解： 1234@Preview@Composablefun TransitionPreview() {} 加上这个注解，我们就可以直接在 Android Studio 界面右侧预览这个 @Composable 可组合项的效果，而不需要运行到模拟机或者真机。 现在还只是组件的预览界面，我们可以点击 Start Animation Preview 按钮进入动画预览界面： 进入之后会是下面这个样子： 我们现在来分析一下这个动画预览界面，注意看图： 红色框框显示的是什么？不就是对应着我们创建 Transition 时候填的 label 么？ 1val transition = updateTransition(targetState = imageState, label = &quot;ImageState Transition&quot;) 我们现在点击箭头展开它： 现在你知道为什么要加 label 了吧？动画预览界面可操作性很强，你可以拖动进度条到动画的任意位置，还能互换动画的初始状态和目标状态，设置动画的倍速等，这个自行探索吧。 我估计这个时候，你可能就会想一个问题了，难道 animate*AsState 不支持，它不是也加了 label 了吗？我们试一下： animate*AsState 虽然支持添加 label，但实际上没有任何动画可以调节。","link":"/2024/08/10/Compose%20--%20%E5%8A%A8%E7%94%BB%20--%2004.%20%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB%20API%EF%BC%9ATransition/"},{"title":"显示与消失 API：AnimatedVisibility","text":"Jetpack Compose 提供了一系列功能强大且可扩展的 API，可用于在应用界面中轻松实现各种动画效果。这一系列文章会逐个介绍所有的动画 API，通过最直观的 Demo 示例，手把手教你怎么写动画以及带你了解动画背后的原理。 📑 手把手教你写 Compose 动画 - - 状态转移型动画 API：animate*AsState() 📑 手把手教你写 Compose 动画 - - 流程定制型动画 API：Animatable() 📑 手把手教你写 Compose 动画 - - 讲的不能再细的 AnimationSpec 动画规范 📑 手把手教你写 Compose 动画 - - 过渡动画 API：Transition 📑 手把手教你写 Compose 动画 - - 显示与消失 API：AnimatedVisibility 📑 手把手教你写 Compose 动画 - - 简单页面切换动画 API：Crossfade 📑 手把手教你写 Compose 动画 - - 更强大的多组件切换动画 API：AnimatedContent 📑 手把手教你写 Compose 动画 - - 组件大小变化 API：animateContentSize 📓 动画图表 在每一篇文章开头，我都会放一张 Compose 动画 API 的图表，以便你有最直观的感受。 📓 AnimatedVisibility AnimatedVisibility 可组合项可为内容的出现和消失添加动画效果。 还是那句话：探索新技术的最佳方式是尝试它们，我们先构建一个简单场景，然后再慢慢引入 AnimatedVisibility 的用法。 123456789101112131415161718192021222324252627282930class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { var shown by remember { mutableStateOf(true) } Column ( modifier = Modifier.fillMaxWidth(), verticalArrangement = Arrangement.Center, horizontalAlignment = Alignment.CenterHorizontally ) { Spacer(modifier = Modifier.height(20.dp)) if (shown) { Image( painter = painterResource(R.drawable.cr7), contentDescription = null, modifier = Modifier.size(90.dp).clip(shape = CircleShape) ) } Button( onClick = { shown = !shown} ) { Text(text = &quot;控制图片显示/消失&quot;) } } } }} 这段代码极其简单，一个图片，一个按钮，一个 shown 状态变量控制图片显示与否，效果如下： 从动画效果看确实不行，显示与消失都很粗糙。现在我们来用 AnimatedVisibility 改善效果，写法很简单： 123456789101112131415161718192021222324252627282930class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { var shown by remember { mutableStateOf(true) } Column ( modifier = Modifier.fillMaxWidth(), verticalArrangement = Arrangement.Center, horizontalAlignment = Alignment.CenterHorizontally ) { Spacer(modifier = Modifier.height(20.dp)) AnimatedVisibility (shown) { Image( painter = painterResource(R.drawable.cr7), contentDescription = null, modifier = Modifier.size(90.dp).clip(shape = CircleShape) ) } Button( onClick = { shown = !shown} ) { Text(text = &quot;控制图片显示/消失&quot;) } } } }} 你会发现，我其实对代码只做了一点小修改： 123if (shown) {// 只是把 if 改成了 AnimatedVisibilityAnimatedVisibility (shown) 看下效果： 是不是已经看出来动画效果了？使用方法就这么简单。 另外，这里还有个很有意思的事情，如果我把布局从 Column 改成 Row（代码我就不贴了），再看下效果： 不同布局方式，动画效果还不一样了？ Column 布局，动画的显示和消失方式是：上 -&gt; 下 Row 布局，动画的显示和消失方式是：左 -&gt; 右 为什么？我们看下 AnimatedVisibility 函数： Column -&gt; AnimatedVisibility 123456789@Composablefun ColumnScope.AnimatedVisibility( visible: Boolean, modifier: Modifier = Modifier, enter: EnterTransition = fadeIn() + expandVertically(), exit: ExitTransition = fadeOut() + shrinkVertically(), label: String = &quot;AnimatedVisibility&quot;, content: @Composable AnimatedVisibilityScope.() -&gt; Unit) Row -&gt; AnimatedVisibility 123456789@Composablefun RowScope.AnimatedVisibility( visible: Boolean, modifier: Modifier = Modifier, enter: EnterTransition = fadeIn() + expandHorizontally(), exit: ExitTransition = fadeOut() + shrinkHorizontally(), label: String = &quot;AnimatedVisibility&quot;, content: @Composable() AnimatedVisibilityScope.() -&gt; Unit) 原来如此 - - 扩展函数，内部各自指定了默认的 enter 和 exit 动画效果。 除了不同容器搞了各自的 AnimatedVisibility() 扩展函数外，对于任何一个组件，我们都可以单独用 AnimatedVisibility()。 123456789101112@Composablefun AnimatedVisibility( visible: Boolean, modifier: Modifier = Modifier, enter: EnterTransition = fadeIn() + expandIn(), exit: ExitTransition = shrinkOut() + fadeOut(), label: String = &quot;AnimatedVisibility&quot;, content: @Composable() AnimatedVisibilityScope.() -&gt; Unit) { val transition = updateTransition(visible, label) // 它也是基于 updateTransition 做的 AnimatedEnterExitImpl(transition, { it }, modifier, enter, exit, content)} AnimatedVisibility() 函数有两个最核心的参数： enter： 指定入场动画，也就是显示动画，类型是 EnterTransition exit： 指定出场动画，也就是消失动画，类型是 ExitTransition 接下来我们就要开始探讨 EnterTransition 和 ExitTransition 这两个核心了。 📓 EnterTransition EnterTransition 是一个密封类： 12@Immutablesealed class EnterTransition 它的子实现类是 EnterTransitionImpl： 12@Immutableprivate class EnterTransitionImpl(override val data: TransitionData) : EnterTransition() 然而 EnterTransitionImpl 是私有的，Compose 提供了几个现成的函数来创建 EnterTransitionImpl。 fadeIn() fadeIn() 函数主要用于内容进场的“淡入效果”，用法极其简单： 1234567AnimatedVisibility (shown, enter = fadeIn()) { Image( painter = painterResource(R.drawable.pingtouge), contentDescription = null, modifier = Modifier.size(90.dp).clip(shape = CircleShape) )} 我们自己定义了 AnimatedVisibility 的 enter 参数，就一个 fadeIn()，看下效果： 现在来看下 fadeIn() 函数的定义： 1234567@Stablefun fadeIn( animationSpec: FiniteAnimationSpec&lt;Float&gt; = spring(stiffness = Spring.StiffnessMediumLow), initialAlpha: Float = 0f): EnterTransition { return EnterTransitionImpl(TransitionData(fade = Fade(initialAlpha, animationSpec)))} 它有两个参数： animationSpec：我们可以给它设定 FiniteAnimationSpec 类型动画，比如：Tween()、SpringSpec() 等，默认是弹簧效果 initialAlpha：我们可以给它定制初始透明度 下面来测试一下： 1234567AnimatedVisibility (shown, enter = fadeIn(tween(3000), initialAlpha = 0.3f)) { Image( painter = painterResource(R.drawable.pingtouge), contentDescription = null, modifier = Modifier.size(90.dp).clip(shape = CircleShape) )} 我们分别加了一个 tween 动画（动画时长 3s），然后又加了一个初始 0.3f 的透明度，看下效果： slideIn() slideIn() 函数主要用于内容进场的“滑入效果”，用法也是极其简单： 1234567AnimatedVisibility (shown, enter = slideIn { }) { Image( painter = painterResource(R.drawable.cr7), contentDescription = null, modifier = Modifier.size(90.dp).clip(shape = CircleShape) )} 可以发现，slideIn 后面接了一个 lambda 表达式，我们看下它的函数定义： 1234567891011@Stablefun slideIn( animationSpec: FiniteAnimationSpec&lt;IntOffset&gt; = spring( stiffness = Spring.StiffnessMediumLow, visibilityThreshold = IntOffset.VisibilityThreshold ), initialOffset: (fullSize: IntSize) -&gt; IntOffset,): EnterTransition { return EnterTransitionImpl(TransitionData(slide = Slide(initialOffset, animationSpec)))} 它有两个参数： animationSpec：我们可以给它设定 FiniteAnimationSpec 类型动画，比如：Tween()、SpringSpec() 等，默认是弹簧效果 initialOffset：需要给它指定一个初始偏移，是一个 IntOffset 类型 现在我们修改代码： 1234567AnimatedVisibility (shown, enter = slideIn { IntOffset(-200, -200) }) { Image( painter = painterResource(R.drawable.cr7), contentDescription = null, modifier = Modifier.size(90.dp).clip(shape = CircleShape) )} 我们随便设定了一个 IntOffset(-200, -200) ，相当于让图片从左上角滑入（x 轴左偏移 200 像素，y轴上偏移 200 像素）。 看下效果： 如果你够细心的话，会发现 initialOffset 的参数类型里面有一个 fullSize： 1initialOffset: (fullSize: IntSize) -&gt; IntOffset 默认已经提供了一个 fullSize 值，这个 fullSize 值包含了图片的宽、高尺寸，所以我们可以按照图片的宽、高进行滑入： 1234567AnimatedVisibility (shown, enter = slideIn { IntOffset(-it.width, -it.height) }) { Image( painter = painterResource(R.drawable.cr7), contentDescription = null, modifier = Modifier.size(90.dp).clip(shape = CircleShape) )} 另外，Compose 还提供了 slideInHorizontally 和 slideInVertically 两个横行和纵向滑入的函数，使用也很简单。 slideInHorizontally：横行滑入 1234567AnimatedVisibility (shown, enter = slideInHorizontally { -it }) { Image( painter = painterResource(R.drawable.cr7), contentDescription = null, modifier = Modifier.size(90.dp).clip(shape = CircleShape) )} slideInVertically：纵向滑入 1234567AnimatedVisibility (shown, enter = slideInVertically { -it }) { Image( painter = painterResource(R.drawable.cr7), contentDescription = null, modifier = Modifier.size(90.dp).clip(shape = CircleShape) )} expandIn() expandIn() 函数主要用于内容进场的“裁切效果”。 我们先来看下它的函数定义： 1234567891011121314151617@Stablefun expandIn( animationSpec: FiniteAnimationSpec&lt;IntSize&gt; = spring( stiffness = Spring.StiffnessMediumLow, visibilityThreshold = IntSize.VisibilityThreshold ), expandFrom: Alignment = Alignment.BottomEnd, clip: Boolean = true, initialSize: (fullSize: IntSize) -&gt; IntSize = { IntSize(0, 0) },): EnterTransition { return EnterTransitionImpl( TransitionData( changeSize = ChangeSize(expandFrom, initialSize, animationSpec, clip) ) )} 跟 slidIn 差不多，它有一个 initialSize 参数，不过有个默认实现，所以我们可以不必非要传这个 lambda 表达式： 1234567AnimatedVisibility (shown, enter = expandIn()) { Image( painter = painterResource(R.drawable.cr7), contentDescription = null, modifier = Modifier.size(90.dp).clip(shape = CircleShape) )} 直接写 expandIn() 即可，为了看到更细的效果，我们添加一个 tween 的动画曲线（5s），看下效果： expandIn() 函数内部还有一个 expandFrom 参数，它用来控制裁切动画是从哪个方位开始，比如默认是 Alignment.BottomEnd （右下角）。 我们试试左上角（Alignment.TopStart）的效果： 12345678AnimatedVisibility (shown, enter = expandIn(tween(5000), expandFrom = Alignment.TopStart)) { Image( painter = painterResource(R.drawable.cr7), contentDescription = null, modifier = Modifier.size(90.dp).clip(shape = CircleShape) )} 另外，我们再说回 initialSize，前面说了它有默认实现，但我们也可以进行定制： 123456789101112AnimatedVisibility (shown, enter = expandIn( tween(5000), expandFrom = Alignment.TopStart) { IntSize (it.width / 2, it.height / 2) }) { Image( painter = painterResource(R.drawable.cr7), contentDescription = null, modifier = Modifier.size(90.dp).clip(shape = CircleShape) )} 我们设定了一个裁剪初始大小值：图片的一半。 现在就剩下一个 clip 参数：它负责是否裁切，默认为 true，如果设置为 false，则动画只位移，不裁切。 12345678910111213AnimatedVisibility (shown, enter = expandIn( tween(5000), expandFrom = Alignment.TopStart, clip = false) { IntSize (it.width / 2, it.height / 2) }) { Image( painter = painterResource(R.drawable.cr7), contentDescription = null, modifier = Modifier.size(90.dp).clip(shape = CircleShape) )} 另外，跟 slideIn 一样，Compose 也提供了 expandHorizontally 和 expandVertically 两个横行和纵向裁切的函数。 expandHorizontally：横向裁切 1234567AnimatedVisibility (shown, enter = expandHorizontally()) { Image( painter = painterResource(R.drawable.cr7), contentDescription = null, modifier = Modifier.size(90.dp).clip(shape = CircleShape) )} expandVertically：纵向裁切 1234567AnimatedVisibility (shown, enter = expandVertically()) { Image( painter = painterResource(R.drawable.cr7), contentDescription = null, modifier = Modifier.size(90.dp).clip(shape = CircleShape) )} scaleIn() scaleIn() 函数主要用于内容进场的“缩放效果”，代码写起来也很简单： 1234567AnimatedVisibility (shown, enter = scaleIn(tween(3000))) { Image( painter = painterResource(R.drawable.cr7), contentDescription = null, modifier = Modifier.size(90.dp).clip(shape = CircleShape) )} 我们来看下它的函数定义： 1234567891011@Stable@ExperimentalAnimationApifun scaleIn( animationSpec: FiniteAnimationSpec&lt;Float&gt; = spring(stiffness = Spring.StiffnessMediumLow), initialScale: Float = 0f, transformOrigin: TransformOrigin = TransformOrigin.Center,): EnterTransition { return EnterTransitionImpl( TransitionData(scale = Scale(initialScale, transformOrigin, animationSpec)) )} animationSpec 和 initialScale 就不看了，你也应该知道是干嘛的了，不做演示了，我们只看下 transformOrigin 参数。 transformOrigin 主要是控制缩放的效果的，默认是从中心点开始缩放，我们可以自行定制，比如： 左上角 12345678910AnimatedVisibility (shown, enter = scaleIn( tween(3000), transformOrigin = TransformOrigin(0f, 0f))) { Image( painter = painterResource(R.drawable.cr7), contentDescription = null, modifier = Modifier.size(90.dp).clip(shape = CircleShape) )} 右下角 12345678910AnimatedVisibility (shown, enter = scaleIn( tween(3000), transformOrigin = TransformOrigin(1.0f, 1.0f))) { Image( painter = painterResource(R.drawable.cr7), contentDescription = null, modifier = Modifier.size(90.dp).clip(shape = CircleShape) )} 📓 + 号原理 EnterTransition 所有的内容全部讲完了，接下来我们看看 “+” 的原理，是如何把两个动画结合在一起的。 这是我们文章最开始的代码示例： 123456789101112@Composablefun AnimatedVisibility( visible: Boolean, modifier: Modifier = Modifier, enter: EnterTransition = fadeIn() + expandIn(), exit: ExitTransition = shrinkOut() + fadeOut(), label: String = &quot;AnimatedVisibility&quot;, content: @Composable() AnimatedVisibilityScope.() -&gt; Unit) { val transition = updateTransition(visible, label) // 它也是基于 updateTransition 做的 AnimatedEnterExitImpl(transition, { it }, modifier, enter, exit, content)} 我们来看看 “+” 号做了什么： 12345678910111213141516sealed class EnterTransition { internal abstract val data: TransitionData @Stable operator fun plus(enter: EnterTransition): EnterTransition { return EnterTransitionImpl( TransitionData( fade = data.fade ?: enter.data.fade, slide = data.slide ?: enter.data.slide, changeSize = data.changeSize ?: enter.data.changeSize, scale = data.scale ?: enter.data.scale ) ) }} 熟悉 Kotlin 的话，对 plus 操作符肯定不默认，这里内部对左右两个 TransitionDate 会做合并，不过合并的规则比较特殊。 比如 fade 淡入的效果： 12345enter: EnterTransition = fadeIn() + expandIn(),// 合并工作fade = data.fade ?: enter.data.fade, 会判断左边的 TransitionData 是否有 fade？– 如果有了就只用左边的 fade，而右边的 TransitionData 即使有 fade，也不会合并，直接去除。 如果你的代码这么写： 123456789AnimatedVisibility (shown, enter = fadeIn(initialAlpha = 0.3f) + fadeIn(initialAlpha = 0.5f)) { Image( painter = painterResource(R.drawable.cr7), contentDescription = null, modifier = Modifier.size(90.dp).clip(shape = CircleShape) )} 那么只会应用左边的 0.3 透明度，右边的 0.5 透明度直接抛弃。 📓 ExitTransition 讲完 EnterTransition，对于 ExitTransition 的原理就不用细说了，和 EnterTransition 一样，只需要把对应的 fadeIn()、slideIn()、expandIn()、scaleIn() 的函数名中的 In 改成 out 即可。 不过有个另类，对于 fadeIn()、slideIn()、scaleIn()，他们对应的 ExitTransition 是：fadeOut()、slideOut、scaleInOut，而 expandIn() 对应的是：shrinkOut，只是改了个名字而已，展开 -&gt; 收缩。","link":"/2024/08/15/Compose%20--%20%E5%8A%A8%E7%94%BB%20--%2005.%20%E6%98%BE%E7%A4%BA%E4%B8%8E%E6%B6%88%E5%A4%B1%20API%EF%BC%9AAnimatedVisibility/"},{"title":"简单页面切换动画 API：Crossfade","text":"Jetpack Compose 提供了一系列功能强大且可扩展的 API，可用于在应用界面中轻松实现各种动画效果。这一系列文章会逐个介绍所有的动画 API，通过最直观的 Demo 示例，手把手教你怎么写动画以及带你了解动画背后的原理。 📑 手把手教你写 Compose 动画 - - 状态转移型动画 API：animate*AsState() 📑 手把手教你写 Compose 动画 - - 流程定制型动画 API：Animatable() 📑 手把手教你写 Compose 动画 - - 讲的不能再细的 AnimationSpec 动画规范 📑 手把手教你写 Compose 动画 - - 过渡动画 API：Transition 📑 手把手教你写 Compose 动画 - - 显示与消失 API：AnimatedVisibility 📑 手把手教你写 Compose 动画 - - 简单页面切换动画 API：Crossfade 📑 手把手教你写 Compose 动画 - - 更强大的多组件切换动画 API：AnimatedContent 📑 手把手教你写 Compose 动画 - - 组件大小变化 API：animateContentSize 📓 动画图表 在每一篇文章开头，我都会放一张 Compose 动画 API 的图表，以便你有最直观的感受。 Crossfade 用于在两个布局之间用交叉淡入淡出的动画。通过切换传递给当前参数的值，内容以交叉渐变动画的方式切换。 还是那句话：探索新技术的最佳方式是尝试它们，我们先构建一个简单场景： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { cf() } }}@Composablefun cf() { var shown by remember { mutableStateOf(true) } Column ( modifier = Modifier.fillMaxWidth(), verticalArrangement = Arrangement.Center, horizontalAlignment = Alignment.CenterHorizontally ) { if (shown) { showCR7_1() } else { showCR7_2() } Button( onClick = { shown = !shown} ) { Text(text = &quot;切换&quot;) } }}@Composablefun showCR7_1() { Image( painter = painterResource(R.drawable.cr7), contentDescription = null, modifier = Modifier .size(90.dp) .clip(shape = CircleShape) )}@Composablefun showCR7_2() { Image( painter = painterResource(R.drawable.cr7_2), contentDescription = null, modifier = Modifier .size(60.dp) .clip(shape = CircleShape) )} 这段代码非常简单，button 控制 shown 变量值，从而显示不同的 Image。 注意，两个图片可组合项除了图片不一样，图片大小也不一样。 对于两个 Image 可组合项我们可以看成是两个非常简单的布局界面，现在切换是没有任何动画效果的。 📓 Crossfade 如果用 Crossfade，就可以实现两个 Image 组件之间的切换动画，写法如下： 12345678910111213141516171819202122232425@Composablefun cf() { var shown by remember { mutableStateOf(true) } Column ( modifier = Modifier.fillMaxWidth(), verticalArrangement = Arrangement.Center, horizontalAlignment = Alignment.CenterHorizontally ) { Spacer(modifier = Modifier.height(100.dp)) Crossfade(targetState = shown, label = &quot;Crossfade&quot;) { if (it) { showCR7_1() } else { showCR7_2() } } Button( onClick = { shown = !shown} ) { Text(text = &quot;切换&quot;) } }} 不对啊，怎么效果这么差，图片尺寸变化的时候还闪了一下？ 先别急，我们看下它的函数定义： 123456789101112@OptIn(ExperimentalAnimationApi::class)@Composablefun &lt;T&gt; Crossfade( targetState: T, modifier: Modifier = Modifier, animationSpec: FiniteAnimationSpec&lt;Float&gt; = tween(), label: String = &quot;Crossfade&quot;, content: @Composable (T) -&gt; Unit) { val transition = updateTransition(targetState, label) transition.Crossfade(modifier, animationSpec, content = content)} 它同样可以设置动画曲线： 1Crossfade(targetState = shown, animationSpec = tween(3000), label = &quot;Crossfade&quot;) 我们把动画时间设的长一点，来看下动画细节： 你发现什么没？ 图片替换淡入淡出没有任何问题； 图片尺寸的动画处理就很突兀：直接从大变成小，而没有渐变的效果。 由于 Crossfade 也可以加 label 参数，我们再从动画预览角度看下效果： 所以，不管从哪个角度来看，Crossfade 仅支持对界面显示的淡入淡出效果的支持，而不支持界面尺寸的渐变变化。其实你从这个 API 的名称也能看出来：Crossfade，也就是 Cross + fade。 Cross：交叉，可以理解为两个可组合项直接的交叉变换过程 fade：淡入淡出，我就是一个实现淡入淡出的 API，其他事你别找我。 那不禁会有疑问了，这个 API 太鸡肋了吧？其实并不是，Compose 往往会设计一些简单的动画 API，提供给开发者最快速、便捷的使用，往往我们并不需要用更为复杂、功能更为强大的 API。说到这里，你是不是想起来 animateAsState 和 Animatable 的关系了？animateAsState 就是 Animatable 的简化版本，使用更为简单。 那么 Crossfade 难道也是某个 API 的简化版本？对的，它就是 AnimatedContent 的简化版本，后者更为强大，既能处理不同可组合项直接的切换渐变，也能实现对尺寸等其他属性的切换渐变效果。","link":"/2024/08/20/Compose%20--%20%E5%8A%A8%E7%94%BB%20--%2006.%20%E7%AE%80%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%88%87%E6%8D%A2%E5%8A%A8%E7%94%BB%20API%EF%BC%9ACrossfade/"},{"title":"更强大的多组件切换动画 API：AnimatedContent","text":"Jetpack Compose 提供了一系列功能强大且可扩展的 API，可用于在应用界面中轻松实现各种动画效果。这一系列文章会逐个介绍所有的动画 API，通过最直观的 Demo 示例，手把手教你怎么写动画以及带你了解动画背后的原理。 📑 手把手教你写 Compose 动画 - - 状态转移型动画 API：animate*AsState() 📑 手把手教你写 Compose 动画 - - 流程定制型动画 API：Animatable() 📑 手把手教你写 Compose 动画 - - 讲的不能再细的 AnimationSpec 动画规范 📑 手把手教你写 Compose 动画 - - 过渡动画 API：Transition 📑 手把手教你写 Compose 动画 - - 显示与消失 API：AnimatedVisibility 📑 手把手教你写 Compose 动画 - - 简单页面切换动画 API：Crossfade 📑 手把手教你写 Compose 动画 - - 更强大的多组件切换动画 API：AnimatedContent 📑 手把手教你写 Compose 动画 - - 组件大小变化 API：animateContentSize 📓 动画图表 在每一篇文章开头，我都会放一张 Compose 动画 API 的图表，以便你有最直观的感受。 📓 AnimatedContent() AnimatedContent 用来控制多个组件的入场和出场，同时还能对入场和出场效果做定制，相当于是 AnimatedVisibility 和Crossfade 的结合，AnimatedContent 出入场动画效果的尺寸是渐变的，这个是区别于 Crossfade 的一个点。 还是那句话：探索新技术的最佳方式是尝试它们，我们把 Crossfade 那个代码示例搬过来： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { cf() } }}@Composablefun cf() { var shown by remember { mutableStateOf(true) } Column ( modifier = Modifier.fillMaxWidth(), verticalArrangement = Arrangement.Center, horizontalAlignment = Alignment.CenterHorizontally ) { Crossfade(targetState = shown, animationSpec = tween(3000), label = &quot;Crossfade&quot;) { if (it) { showCR7_1() } else { showCR7_2() } } Button( onClick = { shown = !shown} ) { Text(text = &quot;切换&quot;) } }}@Composablefun showCR7_1() { Image( painter = painterResource(R.drawable.cr7), contentDescription = null, modifier = Modifier .size(90.dp) .clip(shape = CircleShape) )}@Composablefun showCR7_2() { Image( painter = painterResource(R.drawable.cr7_2), contentDescription = null, modifier = Modifier .size(60.dp) .clip(shape = CircleShape) )} 看下效果： Crossfade 是没法对尺寸变换进行渐变的，那么我们现在来看看 AnimatedContent 的效果。 123456789101112131415161718192021222324252627@Preview@OptIn(ExperimentalAnimationApi::class)@Composablefun cf() { var shown by remember { mutableStateOf(true) } Column ( modifier = Modifier.fillMaxWidth(), verticalArrangement = Arrangement.Center, horizontalAlignment = Alignment.CenterHorizontally ) { Spacer(modifier = Modifier.height(100.dp)) AnimatedContent(targetState = shown, label = &quot;AnimatedContent&quot;) { if (it) { showCR7_1() } else { showCR7_2() } } Button( onClick = { shown = !shown} ) { Text(text = &quot;切换&quot;) } }} 看下效果： Perfect！效果要比 Crossfade 好多了，不仅图片淡入淡出，而且尺寸变化也是渐变的。 现在我们再通过动画预览看下效果： 可以很清晰的发现，这里有好几种入场和出场的动画效果，我们之前研究过 AnimatedVisibility，它是对单个内容的出现和消失添加动画效果的，但我们这里的场景是对多个内容（多个组件）的出现和消失添加动画效果，而且它的动画效果很明显用到了 AnimatedVisibility，是怎么做的呢？ 这就涉及到 AnimatedContent 函数定义里面的一个核心参数了，我们来看一下： 1234567891011121314@ExperimentalAnimationApi@Composablefun &lt;S&gt; AnimatedContent( targetState: S, modifier: Modifier = Modifier, transitionSpec: AnimatedContentScope&lt;S&gt;.() -&gt; ContentTransform = { fadeIn(animationSpec = tween(220, delayMillis = 90)) + scaleIn(initialScale = 0.92f, animationSpec = tween(220, delayMillis = 90)) with fadeOut(animationSpec = tween(90)) }, contentAlignment: Alignment = Alignment.TopStart, label: String = &quot;AnimatedContent&quot;, content: @Composable() AnimatedVisibilityScope.(targetState: S) -&gt; Unit) 我们发现它有一个核心参数：transitionSpec，而且需要一个 ContentTransform 对象。 📓 ContentTransform 我们看下 ContentTransform 的构造函数： 1234567891011@ExperimentalAnimationApiclass ContentTransform( val targetContentEnter: EnterTransition, val initialContentExit: ExitTransition, targetContentZIndex: Float = 0f, sizeTransform: SizeTransform? = SizeTransform()) { var targetContentZIndex by mutableStateOf(targetContentZIndex) var sizeTransform: SizeTransform? = sizeTransform internal set} 它有四个核心参数，我们一个个分析下。 targetContentEnter：目标组件入场动画 什么是目标组件的入场动画？对于我们这个例子来说，就是 showCR7_2() 这个可组合项。 ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/01cc2c120cc2ba1b1563ef233bdccc0a.png =200x) 这个入场动画在哪里设定的？我们之前看到过： 12345transitionSpec: AnimatedContentScope&lt;S&gt;.() -&gt; ContentTransform = { fadeIn(animationSpec = tween(220, delayMillis = 90)) + scaleIn(initialScale = 0.92f, animationSpec = tween(220, delayMillis = 90)) with fadeOut(animationSpec = tween(90))}, 我们来分析下这段代码： ⇒ fadeIn() + scaleIn() 不难理解，我们在 AnimatedVisibility 一文中讲过，这是淡入和缩放两个入场动画的合并。⇒ fadeOut() 也不难理解，它是出场淡出的动画。 但是 with 是什么？ 12@ExperimentalAnimationApiinfix fun EnterTransition.with(exit: ExitTransition) = ContentTransform(this, exit) 原来这么简单：直接创建了 ContentTransform，并且你看到它的参数么？ 1234this -- fadeIn(animationSpec = tween(220, delayMillis = 90)) + scaleIn(initialScale = 0.92f, animationSpec = tween(220, delayMillis = 90))exit -- fadeOut(animationSpec = tween(90)) 所以更进一步： 123456789class ContentTransform( val targetContentEnter: EnterTransition, val initialContentExit: ExitTransition,---targetContentEnter -- this -- fadeIn(animationSpec = tween(220, delayMillis = 90)) + scaleIn(initialScale = 0.92f, animationSpec = tween(220, delayMillis = 90))initialContentExit -- exit -- fadeOut(animationSpec = tween(90)) initialContentExit：初始组件的出场动画 什么是目标组件的出场动画？对于我们这个例子来说，就是 showCR7_1() 这个可组合项。 ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/11223bc66ab469d620266b35ab2ebf71.png =200x) targetContentZIndex：控制 Z 轴高度，控制绘制顺序，靠上就遮盖别的组件 一般不用配置这个参数，因为默认入场的组件都会后绘制，出场的先绘制。 sizeTransform：对尺寸渐变动画的配置 我不知道你看之前的动画的时候有没有发现一个疑问点，我们再来看下动画： 尺寸渐变的过程中，明显有裁切的效果，这个就是 sizeTransform 参数的原因。 1234567@ExperimentalAnimationApiclass ContentTransform( val targetContentEnter: EnterTransition, val initialContentExit: ExitTransition, targetContentZIndex: Float = 0f, sizeTransform: SizeTransform? = SizeTransform() // 对尺寸渐变动画的配置) 我们来看下 SizeTransform 的构造函数： 123456@ExperimentalAnimationApifun SizeTransform( clip: Boolean = true, sizeAnimationSpec: (initialSize: IntSize, targetSize: IntSize) -&gt; FiniteAnimationSpec&lt;IntSize&gt; = { _, _ -&gt; spring(visibilityThreshold = IntSize.VisibilityThreshold) }): SizeTransform = SizeTransformImpl(clip, sizeAnimationSpec) 发现了没？SizeTransform 有两个参数： clip：是否裁切 sizeAnimationSpec：动画曲线设置 动画曲线设置太熟了，我们不聊了，现在来看下不裁切会是什么样。 比如我们自己写一个 transitionSpec： 12345678910111213141516171819202122232425262728@Composablefun cf() { var shown by remember { mutableStateOf(true) } Column ( modifier = Modifier.fillMaxWidth(), verticalArrangement = Arrangement.Center, horizontalAlignment = Alignment.CenterHorizontally ) { Spacer(modifier = Modifier.height(100.dp)) AnimatedContent(targetState = shown, transitionSpec = { fadeIn(tween(1500)) with fadeOut(tween(1500, delayMillis = 1500)) }, label = &quot;AnimatedContent&quot;) { if (it) { showCR7_1() } else { showCR7_2() } } Button( onClick = { shown = !shown} ) { Text(text = &quot;切换&quot;) } }} 看下动画效果： 现在我们把裁切关掉，像下面这么写： 12transitionSpec = { fadeIn(tween(1500, delayMillis = 1500)) with fadeOut(tween(1500)) using SizeTransform(clip = false) }, using 是什么？ 1234@ExperimentalAnimationApiinfix fun ContentTransform.using(sizeTransform: SizeTransform?) = this.apply { this.sizeTransform = sizeTransform} 懂了吧，直接看效果：","link":"/2024/08/25/Compose%20--%20%E5%8A%A8%E7%94%BB%20--%2007.%20%E6%9B%B4%E5%BC%BA%E5%A4%A7%E7%9A%84%E5%A4%9A%E7%BB%84%E4%BB%B6%E5%88%87%E6%8D%A2%E5%8A%A8%E7%94%BB%20API%EF%BC%9AAnimatedContent/"},{"title":"组件大小变化 API：animateContentSize","text":"Jetpack Compose 提供了一系列功能强大且可扩展的 API，可用于在应用界面中轻松实现各种动画效果。这一系列文章会逐个介绍所有的动画 API，通过最直观的 Demo 示例，手把手教你怎么写动画以及带你了解动画背后的原理。 📑 手把手教你写 Compose 动画 - - 状态转移型动画 API：animate*AsState() 📑 手把手教你写 Compose 动画 - - 流程定制型动画 API：Animatable() 📑 手把手教你写 Compose 动画 - - 讲的不能再细的 AnimationSpec 动画规范 📑 手把手教你写 Compose 动画 - - 过渡动画 API：Transition 📑 手把手教你写 Compose 动画 - - 显示与消失 API：AnimatedVisibility 📑 手把手教你写 Compose 动画 - - 简单页面切换动画 API：Crossfade 📑 手把手教你写 Compose 动画 - - 更强大的多组件切换动画 API：AnimatedContent 📑 手把手教你写 Compose 动画 - - 组件大小变化 API：animateContentSize 📓 动画图表 在每一篇文章开头，我都会放一张 Compose 动画 API 的图表，以便你有最直观的感受。 📓 animateContentSize() animateContentSize 修饰符可为 Compose 组件大小变化时添加动画效果。 还是那句话：探索新技术的最佳方式是尝试它们，我们先构建一个简单场景： 1234567891011121314151617181920212223242526272829303132333435363738394041class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { animateContentSizeTest() } }}@Composablefun animateContentSizeTest() { var longString by remember { mutableStateOf(false) } val text by remember(longString) { mutableStateOf( if (longString) &quot;Hi, Compose, this is long description!&quot; else &quot;Hi, Compose!&quot; ) } Column ( modifier = Modifier.fillMaxWidth(), verticalArrangement = Arrangement.Center, horizontalAlignment = Alignment.CenterHorizontally ) { Spacer(modifier = Modifier.height(100.dp)) Button( onClick = { longString = !longString } ) { Text(text = &quot;改变 Text 长度&quot;) } Box( Modifier .background(Color.Green)) { Text(text = text) } }} 现在你看这段代码应该毫无压力了，我们看下效果： 可以看出来，Box 的长度会随着 Text 组件的文字长度而变化，但是这种长度变化很明显没有动画效果。 如果我们想让 Box 组件长度变化也有动画效果的话，就可以使用 animateContentSize 修饰符。 既然是修饰符，那肯定就是用在 Modifier 中的，所以代码写起来也很简单： 123456Box( Modifier .background(Color.Green) .animateContentSize()) { // 只需要对 Box 添加 Modifier.animateContentSize() Text(text = text)} 就这么简单，我们看下效果： animateContentSize() 的用法就这么简单，我们再来看下它的定义： 1234fun Modifier.animateContentSize( animationSpec: FiniteAnimationSpec&lt;IntSize&gt; = spring(), finishedListener: ((initialValue: IntSize, targetValue: IntSize) -&gt; Unit)? = null) 它同样可以自行设定动画曲线（默认是弹簧效果 - - 不弹），现在我们试下它能够弹的效果： 123456Box( Modifier .background(Color.Green) .animateContentSize(animationSpec = spring(Spring.DampingRatioHighBouncy))) { Text(text = text)}","link":"/2024/08/31/Compose%20--%20%E5%8A%A8%E7%94%BB%20--%2008.%20%E7%BB%84%E4%BB%B6%E5%A4%A7%E5%B0%8F%E5%8F%98%E5%8C%96%20API%EF%BC%9AanimateContentSize/"},{"title":"Compose 是如何将数据转换成 UI 的？","text":"Compose 是一个声明式的 UI 框架，提供了很多开箱即用的组件，比如 Text()、Button、Image() 等等，Compose 会经过几个不同的阶段，最终渲染出 UI 界面。 此转换过程分为【三个阶段】： 组合： 显示什么 布局： 放在哪里 绘制： 如何渲染 这三个阶段是逐一执行的，流程如下： # 组合阶段在组合阶段，Compose 运行时会执行代码中定义的可组合函数，最终会生成一棵视图树。这个视图树由一个个布局节点：LayoutNode 组成。比如 Text()、Button() 都对应一个 LayoutNode，这些 LayoutNode 持有组件的所有信息。 更形象一点的结构如下： 这是一个非常简单的示例，但有时候我们定义的可组合项包含逻辑和控制流，而 Compose 会在不同状态的情况下生成不同的树。 # 布局阶段布局阶段，对于视图树中的每个 LayoutNode 节点进行宽高尺寸测量并完成位置摆放，布局元素都会根据 2D 坐标来测量并放置自己及其所有子元素。 其实 Compose 的布局阶段和传统的 View 系统很像（测量、布局、绘制），唯独多了一个「 组合阶段 」，而 Compose 把 测量和布局 统一放入了「 布局阶段 」。 在布局阶段，使用以下 3 步算法遍历 LayoutNode 树： 测量子节点： 每一个节点会测量它的子节点，如果有的话。 决定自己的大小： 基于这些测量，节点决定自己的大小。 放置子节点： 每个子节点都相对于节点自身的位置进行放置。 布局阶段结束后，每个 LayoutNode 都将分配一个 宽度 和 高度，以及一个应该绘制的 x、y 坐标。 比如：我们现在分析下面这个简单示例的布局流程。 布局流程： 看到这，是不是发现个很牛逼的事？ **我们只访问了每个节点一次。通过视图树的一次遍历，我们就可以测量和放置所有节点**。 这对性能来说就很重要了！当树中节点的数量增加时，遍历它所花费的时间只会以线性方式增加。相比之下，如果我们多次访问每个节点，遍历时间则会以呈指数级增加。 # 绘制阶段绘制阶段，树中的每个节点都在屏幕上绘制其像素。 上面我们说过，在布局阶段结束后，所有布局节点会得到它们的 宽度 和 高度，以及 x、y 坐标。所以现在就可以进入绘制阶段了。 绘制阶段会从上到下再次遍历树，每个节点依次在屏幕上绘制自己。 首先 Row 将绘制它可能具有的任何内容，例如背景色。然后 Image 将绘制自己，然后是 Column，然后是第一个和第二个 Text。 # Modifier 修饰符上面我们给的简单代码示例都只是用了一些 Compose 提供给我们的现场的组件，实际开发过程中，会有一个大神级别一样的修饰符随处可见，它就是：Modifier 修饰符。 比如：Modifier.padding 是用来给组件设置边距的，它本质上是一个 LayoutModifier，而 LayoutModifier 会影响组件的测量和布局效果，会影响到组合项的整体 UI 效果。具体如何影响，这篇文章我们不讲它的深层次原理，而只是探讨思维模型。 所以，如果你想了解 LayoutModifier 的原理，可以阅读 【 聊聊 Jetpack Compose 原理 – LayoutModifier 和 Modifier.layout 】 这篇文章。 回到正题，如果我们加了 Modifier 修饰符，那么在最终生成的视图树中，可以将 Modifier 修饰符可视化为布局节点的包装节点： 当我们链接多个修饰符时，每个修饰符节点包裹链的其余部分和其中的布局节点。 例如，当我们链接一个 clip 和一个 size 修饰符时，clip 修饰符节点包裹 size 修饰符节点，然后包裹 Image 布局节点。 这里你可能有疑问，为什么不是先 clip 然后 size，而是先 size 然后在 clip？看完 【 聊聊 Jetpack Compose 原理 – LayoutModifier 和 Modifier.layout 】 这篇文章你就懂了。 接着说，在布局阶段，我们用来遍历树的算法保持不变，但 每个修饰符节点也会被访问。这样，修饰符可以更改其包裹的 修饰符 或 布局节点 的 大小要求 和 位置。 如果我们看一下 Image 可组合项的实现（底层更细的实现），实际上可以看到它本身由包裹单个布局节点的修饰符链组成。类似地，Text 可组合项也是通过包含布局节点的修饰符链实现的。最后，Row 和 Column 的实现只是描述如何布置其子节点的布局节点： 看不懂这张图？没事，这些细节原理都会有文章输出，比如我刚刚提到了两次的原理文章。","link":"/2024/07/01/Compose%20--%20%E5%8E%9F%E7%90%86%20--%20Compose%20%E6%98%AF%E5%A6%82%E4%BD%95%E5%B0%86%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E6%88%90%20UI%20%E7%9A%84%EF%BC%9F/"},{"title":"Android 14.0 Launcher -- Folder 定制","text":"先主观感受下原生 AOSP 默认的 Folder 效果： 要想对 Folder 定制，网上能找出一堆现成的代码，修修补补基本上能满足你 80% 需求，但正所谓：知其然而不知其所以然，就会导致出现 Bug 后，你就会无从下手，然后逐渐陷入，无法自拔，代码越写越乱，而这篇文章就是帮你深刻了解原理，透彻源码逻辑，任何需求在你面前都可以很快实现（你就说我这个逼装的好不好吧）！ Folder 的主要代码全部在：/packages/apps/Launcher3/src/com/android/launcher3/folder 目录下，主要 14 个类。 类 作用 ClippedFolderIconLayoutRule 文件夹图标内部显示小图标缩略图的计算类 Folder FolderAnimationManager FolderGridOrganizer 展开文件夹显示的计算逻辑类，文件夹图标呈现网格状，此类主要给文件夹各应用图标制定显示规则，比如：33, 44 FolderIcon 桌面绘制文件夹图标 FolderNameEditText FolderNameInfos FolderNameProvider FolderPagedView FolderPreviewItemAnim LauncherDelegate PreviewBackground PreviewItemDrawingParams PreviewItemManager 接下来，我们开始深入解析这些核心类，了解清楚 Folder 到底是如何显示、动画是如何切换、以及如何对 AOSP 原生的 Folder 做定制！ FolderIconFolderIcon.java 是 Launcher3 桌面绘制文件夹图标的一个关键的类。 init()1234567891011121314151617181920212223242526272829📄 源码路径：packages/app/Launcher3/src/com/android/launcher3/folder/FolderIcon.javapublic class FolderIcon extends FrameLayout implements FolderListener, IconLabelDotView, DraggableView, Reorderable { ClippedFolderIconLayoutRule mPreviewLayoutRule; private PreviewItemManager mPreviewItemManager; public FolderIcon(Context context, AttributeSet attrs) { super(context, attrs); // 调用 init() 方法初始化 init(); } public FolderIcon(Context context) { super(context); init(); } private void init() { mLongPressHelper = new CheckLongPressHelper(this); // 创建 ClippedFolderIconLayoutRule 对象，记住这个 mPreviewLayoutRule ！ mPreviewLayoutRule = new ClippedFolderIconLayoutRule(); // 创建 PreviewItemManager 对象 mPreviewItemManager = new PreviewItemManager(this); mDotParams = new DotRenderer.DrawParams(); }} dispatchDraw()123456789101112131415161718192021222324252627282930313233📄 源码路径：packages/app/Launcher3/src/com/android/launcher3/folder/FolderIcon.javapublic class FolderIcon extends FrameLayout implements FolderListener, IconLabelDotView, DraggableView, Reorderable { private PreviewItemManager mPreviewItemManager; @Override protected void dispatchDraw(Canvas canvas) { super.dispatchDraw(canvas); if (!mBackgroundIsVisible) return; // 核心 1: 重新计算图标的各项参数 mPreviewItemManager.recomputePreviewDrawingParams(); if (!mBackground.drawingDelegated()) { mBackground.drawBackground(canvas); } if (mCurrentPreviewItems.isEmpty() &amp;&amp; !mAnimating) return; // 核心 2: 绘制文件夹预览图 mPreviewItemManager.draw(canvas); if (!mBackground.drawingDelegated()) { mBackground.drawBackgroundStroke(canvas); } drawDot(canvas); }} PreviewItemManagerPreviewItemManager.java 类是用来管理 FolderIcon「文件夹预览图」中 PreviewItemDrawingParams「文件夹中应用预览项」– 「绘图」和「动画参数」的。 重新计算图标参数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100📄 源码路径：packages/app/Launcher3/src/com/android/launcher3/folder/PreviewItemManager.javapublic class PreviewItemManager { public void recomputePreviewDrawingParams() { if (mReferenceDrawable != null) { // 调用 computePreviewDrawingParams() 方法 computePreviewDrawingParams(mReferenceDrawable.getIntrinsicWidth(), mIcon.getMeasuredWidth()); } } private void computePreviewDrawingParams(int drawableSize, int totalSize) { if (mIntrinsicIconSize != drawableSize || mTotalWidth != totalSize || mPrevTopPadding != mIcon.getPaddingTop()) { mIntrinsicIconSize = drawableSize; mTotalWidth = totalSize; mPrevTopPadding = mIcon.getPaddingTop(); mIcon.mBackground.setup(mIcon.getContext(), mIcon.mActivity, mIcon, mTotalWidth, mIcon.getPaddingTop()); // 调用了 FolderIcon.mPreviewLayoutRule.init() 方法做一些初始化工作 mIcon.mPreviewLayoutRule.init(mIcon.mBackground.previewSize, mIntrinsicIconSize, Utilities.isRtl(mIcon.getResources())); // 调用 updatePreviewItems() 方法，注意参数传的是 false updatePreviewItems(false); } } void updatePreviewItems(boolean animate) { int numOfPrevItemsAux = mFirstPageParams.size(); // 调用 buildParamsForPage() 方法，注意：第 3 个参数是 false buildParamsForPage(0, mFirstPageParams, animate); mNumOfPrevItems = numOfPrevItemsAux; } void buildParamsForPage(int page, ArrayList&lt;PreviewItemDrawingParams&gt; params, boolean animate) { // 这个 items 是用来存储当前应用图标预览项列表的 List&lt;WorkspaceItemInfo&gt; items = mIcon.getPreviewItemsOnPage(page); // We adjust the size of the list to match the number of items in the preview. while (items.size() &lt; params.size()) { // 先移除 params 中的 items params.remove(params.size() - 1); } while (items.size() &gt; params.size()) { // 再一个个添加进去 params.add(new PreviewItemDrawingParams(0, 0, 0)); } int numItemsInFirstPagePreview = page == 0 ? items.size() : MAX_NUM_ITEMS_IN_PREVIEW; for (int i = 0; i &lt; params.size(); i++) { // 拿到单个 PreviewItemDrawingParams 对象，这里的 PreviewItemDrawingParams 就是单个应用图标预览项 PreviewItemDrawingParams p = params.get(i); setDrawable(p, items.get(i)); // 上面传递第三个参数 animate 为 false，所以会进入这个 if 判断 if (!animate) { if (p.anim != null) { p.anim.cancel(); } // 调用 computePreviewItemDrawingParams() 方法 computePreviewItemDrawingParams(i, numItemsInFirstPagePreview, p); if (mReferenceDrawable == null) { mReferenceDrawable = p.drawable; } } else { FolderPreviewItemAnim anim = new FolderPreviewItemAnim(this, p, i, mNumOfPrevItems, i, numItemsInFirstPagePreview, DROP_IN_ANIMATION_DURATION, null); if (p.anim != null) { if (p.anim.hasEqualFinalState(anim)) { // do nothing, let the current animation finish continue; } p.anim.cancel(); } p.anim = anim; p.anim.start(); } } } PreviewItemDrawingParams computePreviewItemDrawingParams(int index, int curNumItems, PreviewItemDrawingParams params) { // We use an index of -1 to represent an icon on the workspace for the destroy and // create animations // index 为文件夹中应用预览项的下标，一般来说 &gt;=0 if (index == -1) { return getFinalIconParams(params); } // 调用了 FolderIcon.mPreviewLayoutRule.computePreviewItemDrawingParams() 方法 return mIcon.mPreviewLayoutRule.computePreviewItemDrawingParams(index, curNumItems, params); } private final FolderIcon mIcon;} 还记得 FolderIcon.mPreviewLayoutRule 是什么吗？– ClippedFolderIconLayoutRule 对象！ 绘制文件夹预览图12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364```java📄 源码路径：packages/app/Launcher3/src/com/android/launcher3/folder/PreviewItemManager.javapublic class PreviewItemManager { public void draw(Canvas canvas) { int saveCount = canvas.getSaveCount(); // The items are drawn in coordinates relative to the preview offset PreviewBackground bg = mIcon.getFolderBackground(); Path clipPath = bg.getClipPath(); float firstPageItemsTransX = 0; if (mShouldSlideInFirstPage) { PointF firstPageOffset = new PointF(bg.basePreviewOffsetX + mCurrentPageItemsTransX, bg.basePreviewOffsetY); boolean shouldClip = mCurrentPageItemsTransX &gt; mClipThreshold; drawParams(canvas, mCurrentPageParams, firstPageOffset, shouldClip, clipPath); firstPageItemsTransX = -ITEM_SLIDE_IN_OUT_DISTANCE_PX + mCurrentPageItemsTransX; } PointF firstPageOffset = new PointF(bg.basePreviewOffsetX + firstPageItemsTransX, bg.basePreviewOffsetY); boolean shouldClipFirstPage = firstPageItemsTransX &lt; -mClipThreshold; // 调用 drawParams() 方法 drawParams(canvas, mFirstPageParams, firstPageOffset, shouldClipFirstPage, clipPath); canvas.restoreToCount(saveCount); } public void drawParams(Canvas canvas, ArrayList&lt;PreviewItemDrawingParams&gt; params, PointF offset, boolean shouldClipPath, Path clipPath) { // 这里传进来的 ArrayList&lt;PreviewItemDrawingParams&gt; params 就是每个文件夹中应用图标的 List // The first item should be drawn last (ie. on top of later items) for (int i = params.size() - 1; i &gt;= 0; i--) { PreviewItemDrawingParams p = params.get(i); if (!p.hidden) { // Exiting param should always be clipped. boolean isExiting = p.index == EXIT_INDEX; // 遍历文件夹中每个图标，进行绘制 drawPreviewItem(canvas, p, offset, isExiting | shouldClipPath, clipPath); } } } private void drawPreviewItem(Canvas canvas, PreviewItemDrawingParams params, PointF offset, boolean shouldClipPath, Path clipPath) { canvas.save(); if (shouldClipPath) { canvas.clipPath(clipPath); } canvas.translate(offset.x + params.transX, offset.y + params.transY); canvas.scale(params.scale, params.scale); Drawable d = params.drawable; if (d != null) { Rect bounds = d.getBounds(); canvas.save(); canvas.translate(-bounds.left, -bounds.top); canvas.scale(mIntrinsicIconSize / bounds.width(), mIntrinsicIconSize / bounds.height()); d.draw(canvas); canvas.restore(); } canvas.restore(); } } ClippedFolderIconLayoutRule 文件夹图标内部显示小图标缩略图的计算类，如果你要定制 Folder，让其缩略图显示为 9 宫格的样式，那么此类是关键！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166📄 源码路径：packages/app/Launcher3/src/com/android/launcher3/folder/ClippedFolderIconLayoutRule.javapublic class ClippedFolderIconLayoutRule { // 文件夹预览中的最大/最小显示图标数 public static final int MAX_NUM_ITEMS_IN_PREVIEW = 4; private static final int MIN_NUM_ITEMS_IN_PREVIEW = 2; // 缩放因子：当预览中的图标数量较多时使用 MIN_SCALE，较少时使用 MAX_SCALE private static final float MIN_SCALE = 0.44f; private static final float MAX_SCALE = 0.51f; // 最大半径膨胀比例 private static final float MAX_RADIUS_DILATION = 0.25f; // 重叠系数：允许图标部分重叠以优化视觉效果 public static final float ICON_OVERLAP_FACTOR = 1 + (MAX_RADIUS_DILATION / 2f); private static final float ITEM_RADIUS_SCALE_FACTOR = 1.15f; // 表示进入或退出文件夹时的图标索引，用于动画逻辑 public static final int EXIT_INDEX = -2; public static final int ENTER_INDEX = -3; // 临时数组，用于存储计算后的 x 和 y 坐标 private float[] mTmpPoint = new float[2]; private float mAvailableSpace; // 预览区域的可用空间 private float mRadius; // 布局中用于排列图标的圆形半径 private float mIconSize; // 图标大小 private boolean mIsRtl; // 标识布局是否为 RTL private float mBaselineIconScale; // 基准缩放因子 /** * 初始化文件夹图标布局的关键参数：空间大小、图标大小和布局方向（RTL） */ public void init(int availableSpace, float intrinsicIconSize, boolean rtl) { mAvailableSpace = availableSpace; mRadius = ITEM_RADIUS_SCALE_FACTOR * availableSpace / 2f; mIconSize = intrinsicIconSize; mIsRtl = rtl; mBaselineIconScale = availableSpace / (intrinsicIconSize * 1f); } /** * 计算预览中的图标绘制参数 */ public PreviewItemDrawingParams computePreviewItemDrawingParams(int index, int curNumItems, PreviewItemDrawingParams params) { float totalScale = scaleForItem(curNumItems); float transX; float transY; if (index == EXIT_INDEX) { // 0 1 * &lt;-- Exit position (row 0, col 2) // 2 3 getGridPosition(0, 2, mTmpPoint); } else if (index == ENTER_INDEX) { // 0 1 // 2 3 * &lt;-- Enter position (row 1, col 2) getGridPosition(1, 2, mTmpPoint); } else if (index &gt;= MAX_NUM_ITEMS_IN_PREVIEW) { // Items beyond those displayed in the preview are animated to the center mTmpPoint[0] = mTmpPoint[1] = mAvailableSpace / 2 - (mIconSize * totalScale) / 2; } else { getPosition(index, curNumItems, mTmpPoint); } transX = mTmpPoint[0]; transY = mTmpPoint[1]; if (params == null) { params = new PreviewItemDrawingParams(transX, transY, totalScale); } else { params.update(transX, transY, totalScale); } return params; } /** * Builds a grid based on the positioning of the items when there are * {@link #MAX_NUM_ITEMS_IN_PREVIEW} in the preview. * * Positions in the grid: 0 1 // 0 is row 0, col 1 * 2 3 // 3 is row 1, col 1 */ /** * 网格位置计算逻辑 */ private void getGridPosition(int row, int col, float[] result) { // 获取网格中左上角（0号位置）的坐标 getPosition(0, 4, result); float left = result[0]; float top = result[1]; // 获取网格中右下角（3号位置）的坐标 getPosition(3, 4, result); float dx = result[0] - left; float dy = result[1] - top; result[0] = left + (col * dx); result[1] = top + (row * dy); } /** * 计算具体位置 */ private void getPosition(int index, int curNumItems, float[] result) { // 确保当前显示的图标数量至少为 2 curNumItems = Math.max(curNumItems, 2); // We model the preview as a circle of items starting in the appropriate piece of the // upper left quadrant (to achieve horizontal and vertical symmetry). double theta0 = mIsRtl ? 0 : Math.PI; // In RTL we go counterclockwise int direction = mIsRtl ? 1 : -1; // 根据图标数量调整初始角度 double thetaShift = 0; if (curNumItems == 3) { thetaShift = Math.PI / 2; } else if (curNumItems == 4) { thetaShift = Math.PI / 4; } theta0 += direction * thetaShift; // We want the items to appear in reading order. For the case of 1, 2 and 3 items, this // is natural for the circular model. With 4 items, however, we need to swap the 3rd and // 4th indices to achieve reading order. if (curNumItems == 4 &amp;&amp; index == 3) { index = 2; } else if (curNumItems == 4 &amp;&amp; index == 2) { index = 3; } // We bump the radius up between 0 and MAX_RADIUS_DILATION % as the number of items increase float radius = mRadius * (1 + MAX_RADIUS_DILATION * (curNumItems - MIN_NUM_ITEMS_IN_PREVIEW) / (MAX_NUM_ITEMS_IN_PREVIEW - MIN_NUM_ITEMS_IN_PREVIEW)); double theta = theta0 + index * (2 * Math.PI / curNumItems) * direction; float halfIconSize = (mIconSize * scaleForItem(curNumItems)) / 2; // Map the location along the circle, and offset the coordinates to represent the center // of the icon, and to be based from the top / left of the preview area. The y component // is inverted to match the coordinate system. result[0] = mAvailableSpace / 2 + (float) (radius * Math.cos(theta) / 2) - halfIconSize; result[1] = mAvailableSpace / 2 + (float) (- radius * Math.sin(theta) / 2) - halfIconSize; } /** * 缩放因子计算 */ public float scaleForItem(int numItems) { // Scale is determined by the number of items in the preview. final float scale; if (numItems &lt;= 3) { scale = MAX_SCALE; } else { scale = MIN_SCALE; } return scale * mBaselineIconScale; } public float getIconSize() { return mIconSize; }} 计算图标位置：getPosition()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667private void getPosition(int index, int curNumItems, float[] result) { // 确保当前显示的图标数量至少为 2 curNumItems = Math.max(curNumItems, 2); /** * 确定初始角度，RTL 布局从 0 度开始，非 RTL 从 π（180 度）开始 * * 这里我们不考虑 RTL 的情况，所以后续分析默认以 0 度为初始角度 */ double theta0 = mIsRtl ? 0 : Math.PI; /** * 确定方向：RTL 顺时针，非 RTL 逆时针 * * 这里我们不考虑 RTL 的情况，所以后续默认为：逆时针方向 */ int direction = mIsRtl ? 1 : -1; /** * 根据子项数量调整角度偏移 * * 我们先以 curNumItems = 4 个图标为例 */ double thetaShift = 0; if (curNumItems == 3) { thetaShift = Math.PI / 2; // 90 度偏移 } else if (curNumItems == 4) { thetaShift = Math.PI / 4; // 45 度偏移 } /** * 初始角度：direction -&gt; -1 * index: 0 -&gt; theta0 = 135 度（2.356194490192345） * index: 1 -&gt; theta0 = 135 度（2.356194490192345） * index: 2 -&gt; theta0 = 135 度（2.356194490192345） * index: 3 -&gt; theta0 = 135 度（2.356194490192345） */ theta0 += direction * thetaShift; // 确保 4 个子项时，第 3 和第 4 项互换，保证阅读顺序 if (curNumItems == 4 &amp;&amp; index == 3) { index = 2; } else if (curNumItems == 4 &amp;&amp; index == 2) { index = 3; } // 根据子项数量增加半径，越多图标，半径越大，确保图标合理地分散开 // MAX_RADIUS_DILATION 控制了图标最大能膨胀的比例 float radius = mRadius * (1 + MAX_RADIUS_DILATION * (curNumItems - MIN_NUM_ITEMS_IN_PREVIEW) / (MAX_NUM_ITEMS_IN_PREVIEW - MIN_NUM_ITEMS_IN_PREVIEW)); /** * 计算当前子项的角度： * index: 0 -&gt; theta = PI*3/4 - 0 = PI*3/4 (2.356194490192345) * index: 1 -&gt; theta = PI*3/4 - PI*1/2 = PI/4 (0.7853981633974483) * index: 2 -&gt; theta = PI*3/4 - PI = -PI/4 (-0.7853981633974483) * index: 3 -&gt; theta = PI*3/4 - PI*3/2 = -PI*3/4 (-2.356194490192345) */ double theta = theta0 + index * (2 * Math.PI / curNumItems) * direction; // 计算图标大小的一半，用于调整位置到图标中心 float halfIconSize = (mIconSize * scaleForItem(curNumItems)) / 2; // 使用极坐标计算 x 和 y 坐标，并调整为从预览区域的中心开始 result[0] = mAvailableSpace / 2 + (float) (radius * Math.cos(theta) / 2) - halfIconSize; result[1] = mAvailableSpace / 2 + (float) (- radius * Math.sin(theta) / 2) - halfIconSize;} 总结下 getPosition() 方法的计算思路： 1. 在文件夹预览图标布局中，图标不是随机分布的，而是「围绕文件夹图标中心」均匀排列的。 实现方法就是：以中心点为圆心绘制一个圆，各个应用的图标中心都在圆上，且各个图标之间的距离(角度)相等即可； 2. 计算应用图标中心距离文件夹图标中心的半径 图标数量不同时，绘制的大小和区域也不一样，这里使用一个线性插值公式，根据当前预览图标数量(curNumItems)相对于预览图标的最小和最大数量(2 和 4)的比例，来调整半径 radius 的大小： 1234567891011121314private static final float ITEM_RADIUS_SCALE_FACTOR = 1.15f;mRadius = ITEM_RADIUS_SCALE_FACTOR * availableSpace / 2f;// 初始 mRadius:mRadius = 1.15 * availableSpace / 2f;// 根据预览图数量重新设定半径 radius:private static final float MAX_RADIUS_DILATION = 0.25f;float radius = mRadius * (1 + MAX_RADIUS_DILATION * (curNumItems - MIN_NUM_ITEMS_IN_PREVIEW) / (MAX_NUM_ITEMS_IN_PREVIEW - MIN_NUM_ITEMS_IN_PREVIEW));curNumItems = 2，radius = mRadiuscurNumItems = 3，radius = 1.125 * mRadiuscurNumItems = 4，radius = 1.25 * mRadius 3. 根据当前预览图标数量(curNumItems)将这个圆平均，并根据「极坐标系」计算每个应用图标中心点的「极坐标」 123456789101112131415161718192021222324252627// 计算每个应用的初始化角度double theta = theta0 + index * (2 * Math.PI / curNumItems) * direction;curNumItems = 2：两个应用在中心点的两侧，两个图标在同一水平线上 | | index: 0 -&gt; theta = PI -(0)-+-(1)- index: 1 -&gt; theta = 0 | |curNumItems = 3：三个图标按品字排列，第一个在顶部，顺时针排列 | (0) index: 0 -&gt; theta = PI/2 -----+----- index: 1 -&gt; theta = -PI/6 (2) | (1) index: 2 -&gt; theta = -PI*5/6； |curNumItems = 4：四个图标按 2x2 排列 | (0) | (1) index: 0 -&gt; theta = PI*3/4 -----+----- index: 1 -&gt; theta = PI/4 (2) | (3) index: 2 -&gt; index = 3 -&gt; theta = -PI/4 | index: 3 -&gt; index = 2 -&gt; theta = -PI*3/4 4. 计算应用图标左上角的 x、y 坐标 12result[0] = mAvailableSpace / 2 + (float) (radius * Math.cos(theta) / 2) - halfIconSize;result[1] = mAvailableSpace / 2 + (float) (-radius * Math.sin(theta) / 2) - halfIconSize; 我们来看下 4 个图标的位置确定过程： 第 1 个图标：index = 0 theta = PI*3/4 第 2 个图标：index = 1 theta = PI/4 这两张图已经完美诠释了位置获取的算法逻辑，index = 2 / index = 3 我就不再画图了，留给大家自己研究吧。 由上面的分析我们发现，影响位置计算结果的主要参数为： mAvailableSpace: 文件夹图标大小，我们一般不会对他做改动 mIconSize: 缩放系数 radius: 半径，影响应用图标离中心点的距离 theta: 角坐标 九宫格定制硬核改法如果你理解透彻了 getPosition() 方法的图标计算逻辑，那接下来我们看看如何自己分析处理 9 宫格的布局算法： 通用改法 既然需要支持 9 宫格布局，那首先最大支持图标数得修改为 9: 1public static final int MAX_NUM_ITEMS_IN_PREVIEW = 9; 意料之中的情况，我们必须重新定义 getPositon() 的算法： 123456789101112131415161718192021222324252627282930public PreviewItemDrawingParams computePreviewItemDrawingParams(int index, int curNumItems, PreviewItemDrawingParams params) { float totalScale = scaleForItem(curNumItems); float transX; float transY; if (index == EXIT_INDEX) { ... } else { // getPosition(index, curNumItems, mTmpPoint); // 固定九宫格的样式，我们无需 curNumItems 参数 get9Position(index, mTmpPoint); } ...}// 重新定义 getPosition() 算法private void get9Position(int index, float[] result) { int x = index % 3; // 第几列 int y = index / 3; // 第几行 float iconSize = mAvailableSpace / 3; if (mIsRtl) { result[0] = iconSize * (2 - x); } else { result[0] = iconSize * x; } result[1] = iconSize * y;} 图标太大了，我们调整下缩放因子： 12// private static final float MIN_SCALE = 0.44f;private static final float MIN_SCALE = 0.28f; 现在的图标位置是有问题的，因为我们之前的代码是强制图标占据空间为：mAvailableSpace/3，是需要进行调整的： 1234567891011121314private void get9Position(int index, float[] result) { int x = index % 3; int y = index / 3; // float iconSize = mAvailableSpace / 3; float iconSize = mAvailableSpace * MIN_SCALE; if (mIsRtl) { result[0] = iconSize * (2 - x); } else { result[0] = iconSize * x; } result[1] = iconSize * y;} 现在我们剩下最后一步，就是调整 9 宫格图，让图标彼此之间的间距平均： 1234567891011121314151617181920212223// 新定义预览图间距 private float mPreviewGap; public void init(int availableSpace, float intrinsicIconSize, boolean rtl) { ... // 总可用空间 - 3 个图标占用空间 = 剩余空间 // 将剩余空间平均分配成 4 段，因为有 3 个图标就有 4 个间隔 mPreviewGap = (mAvailableSpace - mAvailableSpace * MIN_SCALE * 3) / 4f; } private void get9Position(int index, float[] result) { int x = index % 3; int y = index / 3; float iconSize = mAvailableSpace * MIN_SCALE; if (mIsRtl) { result[0] = mPreviewGap + (iconSize + mPreviewGap) * (2 - x); } else { result[0] = mPreviewGap + (iconSize + mPreviewGap) * x; } result[1] = mPreviewGap + (iconSize + mPreviewGap) * y; } 参考https://blog.csdn.net/baidu_41666295/article/details/134936794","link":"/2024/12/05/Android%20--%20Launcher3%20--%2011.%20Folder%20%E4%B9%9D%E5%AE%AB%E6%A0%BC%E5%AE%9A%E5%88%B6/"},{"title":"聊聊 mutableStateListOf","text":"Source Code based on: androidx.compose.**:**:1.5.0 讲任何一个新的主题或者知识点，习惯性的从 Demo 开始，比如： 1234567891011class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var name by mutableStateOf(&quot;Hi, Compose&quot;) setContent { Text(name) } }} 这段代码已经熟的不能再熟了吧？如果我们用 by mutableStateOf 初始化一个变量，那 name 就会变成一个被 Compose「自动订阅」的变量。 我们之前文章的例子，都是用 by mutableStateOf 包了一个 String，如果换成别的类型，行不行？ 1234fun &lt;T&gt; mutableStateOf( value: T, // 泛型参数 policy: SnapshotMutationPolicy&lt;T&gt; = structuralEqualityPolicy()): MutableState&lt;T&gt; = createSnapshotMutableState(value, policy) 例如：Int 类型 12345678910111213141516class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var num by mutableStateOf(1) setContent { Text( text = &quot;当前数值：$num&quot;, Modifier.clickable { num++ } ) } }} 代码不做解释了，直接看效果： 例如：List 类型 123// num 类型：MutableList&lt;Int&gt;// mutableStateOf 类型：MutableState&lt;MutableList&lt;Int&gt;&gt;var nums by mutableStateOf(mutableListOf(1, 2, 3)) 我们在代码里面用起来： 123456789101112131415class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var nums by mutableStateOf(mutableListOf(1, 2, 3)) setContent { Column { for (num in nums) { Text(&quot;第 $num 块文字&quot;) } } } }} 运行： 现在我们稍微改下代码： 1234567891011121314151617181920class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var nums by mutableStateOf(mutableListOf(1, 2, 3)) setContent { Column { Button(onClick = { nums.add(nums.last() + 1) }) { Text(&quot;List 加 1&quot;) } for (num in nums) { Text(&quot;第 $num 块文字&quot;) } } } }} 代码很简单：我们添加了一个 Button，每次点击后，nums 会添加一个值，比最有一个值大 1。 运行： Button 疯狂点击，但是没生效！为什么？ 我们先来思考一个问题，mutableStateOf 原理是什么？我们回忆一下： mutableStateOf 之所以可以对变量进行订阅和刷新，主要是因为内部的 get() 和 set() 方法加了钩子，或者说它的 set() 方法是赋值！是改变了变量的指向，它是直接把对象给替换了，但在我们这个代码里面 nums 仅仅是改变了它内部的状态！ 所以，它不会出发 setValue() 的调用，从而不会触发自动刷新的操作。 为了验证是不是因为没有重组，我们可以改下代码： 12345678910111213141516171819202122class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var nums by mutableStateOf(mutableListOf(1, 2, 3)) var refresh by mutableStateOf(&quot;强制刷新&quot;) setContent { Column { Text(refresh, Modifier.clickable { refresh = &quot;刷新完成&quot;}) Button(onClick = { nums.add(nums.last() + 1) }) { Text(&quot;List 加 1&quot;) } for (num in nums) { Text(&quot;第 $num 块文字&quot;) } } } }} 我们添加了一个 Text() 组件，改变 refresh 的值，那么理论上它就会带着「整个重组作用域内」的组件全部「刷新」，包括 List。 运行： 成功刷新了 List ！ 现在我们就很清楚了，mutableStateOf 没法对 List 类型的对象实现类似 String、Int 的自动订阅及刷新，那有没有解决办法？ 上面我们说过了，问题的根本原因是 List 只是内部的变化，而不是它自己本身对象的变化，那我们在内部操作完后直接把 List 重新给换了不就行了？试试： 1234567891011121314151617181920212223class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var nums by mutableStateOf(mutableListOf(1, 2, 3)) setContent { Column { Button(onClick = { // nums 重新赋值 nums = nums.toMutableList().apply { add(nums.last() + 1) } }) { Text(&quot;List 加 1&quot;) } for (num in nums) { Text(&quot;第 $num 块文字&quot;) } } } }} 运行： 成功刷新了 List ！ 但这样写就会显得很奇怪：既然对于 String、Int 这些类型，Compose 提供了 mutableStateOf，难道对于 List 这种这么常用的类型，就没有一个 mutable*** 的函数给我们用？ 那必须有！它就是 mutableStateListOf！它可以观测到内部 List 的数据变化！ 我们可以像下面这样申明： 12345678910var nums by mutableStateListOf(mutableListOf(1, 2, 3)) // 有红线标注，写法错误// mutableStateListOf 是内部元素被观测，而不是它本身被观测，所以我们要把 `by` 换成 `=`var nums = mutableStateListOf(mutableListOf(1, 2, 3))// `var` 也可以换成 `val`val nums = mutableStateListOf(mutableListOf(1, 2, 3))// mutableStateListOf 本身就代表一个可观测的 List，所以 mutableListOf 也可以去除val nums = mutableStateListOf(1, 2, 3) // 这就是最终的写法 这个时候我们就可以优化下代码了： 1234567891011121314151617181920class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val nums = mutableStateListOf(1, 2, 3) setContent { Column { Button(onClick = { nums.add(nums.last() + 1) }) { Text(&quot;List 加 1&quot;) } for (num in nums) { Text(&quot;第 $num 块文字&quot;) } } } }} 运行： 提到 List，我们就会想到 Map，同样 Map 也提供了一个 mutableStateMapOf！它也可以观测到内部 Map 的数据变化！ 12345678910111213141516171819class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val maps = mutableStateMapOf(1 to &quot;One&quot;, 2 to &quot;Two&quot;) setContent { Column { Button(onClick = { maps[3] = &quot;Three&quot; }) { Text(&quot;Maps 加 1&quot;) } for ((key, value) in maps) { Text(&quot;$key 对应 value: $value&quot;) } } } }} 运行：","link":"/2024/07/18/Compose%20--%20%E7%8A%B6%E6%80%81%E8%AE%A2%E9%98%85%20&%20%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%20--%2004.%20mutableStateListOf/"},{"title":"你真的了解 Compose 的重组吗？","text":"Source Code based on: androidx.compose.**:**:1.5.0 重组先考虑一个问题，什么时候会「重组」？ 123val name by remember { mutableStateOf(&quot;Hi Compose&quot;)}val nums = mutableStateListOf(1, 2, 3)val maps = mutableStateMapOf(1 to &quot;One&quot;, 2 to &quot;Two&quot;) 通过之前的几篇文章，你应该对这三行代码不陌生，当用 mutableState*Of 申明一个变量的时候，在可组合项中，「如果变量变化了，就会触发重组」。 比如下面代码： 12345678910111213class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var name by mutableStateOf(&quot;Hi, Compose&quot;) setContent { Column { Text(name, Modifier.clickable { name = &quot;Hi, Kotlin&quot; }) } } }} 我们知道：Text(name) 被重组了，但是并不是仅仅是 Text(name) 被重组，而是整个 Lambda 表达式 被重组，我们之前说过，这就是「重组作用域（Recompose scope）」！。 那么思考一个问题： 我们先看一个好玩的东西，查看 Column 函数： 1234567891011121314@Composableinline fun Column( modifier: Modifier = Modifier, verticalArrangement: Arrangement.Vertical = Arrangement.Top, horizontalAlignment: Alignment.Horizontal = Alignment.Start, content: @Composable ColumnScope.() -&gt; Unit) { val measurePolicy = columnMeasurePolicy(verticalArrangement, horizontalAlignment) Layout( content = { ColumnScopeInstance.content() }, measurePolicy = measurePolicy, modifier = modifier )} Column 是个 inline 函数（内联函数），这就意味着在实际编译之前，这个函数的调用会被替换成内部实际的代码。 比如会是下面这个样子： 12345678910111213141516class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var name by mutableStateOf(&quot;Hi, Compose&quot;) setContent { // Column { // 替换为 Layout( Text(name, Modifier.clickable { name = &quot;Hi, Kotlin&quot; }) ) // } } }} 再来看下 Layout()： 1234567891011@Composable inline fun Layout( content: @Composable @UiComposable () -&gt; Unit, modifier: Modifier = Modifier, measurePolicy: MeasurePolicy) { ... ReusableComposeNode&lt;ComposeUiNode, Applier&lt;Any&gt;&gt;( ... content = content )} Layout()也是个 inline 函数，那么代码又会变成这样： 123456789101112131415161718class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var name by mutableStateOf(&quot;Hi, Compose&quot;) setContent { // Column { // Layout( // 替换为 ReusableComposeNode( Text(name, Modifier.clickable { name = &quot;Hi, Kotlin&quot; }) ) // ) // } } }} 再来看下 ReusableComposeNode： 1234567891011@Composable @ExplicitGroupsComposableinline fun &lt;T, reified E : Applier&lt;*&gt;&gt; ReusableComposeNode( noinline factory: () -&gt; T, update: @DisallowComposableCalls Updater&lt;T&gt;.() -&gt; Unit, noinline skippableUpdate: @Composable SkippableUpdater&lt;T&gt;.() -&gt; Unit, content: @Composable () -&gt; Unit) { ... content() ...} 又是 inline 函数，而且你看它内部干了什么？- - 直接调用了 content()！ 所以最终代码在编译前其实会把 Column {} 给拿掉，就跟下面一样： 123456789101112131415161718class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var name by mutableStateOf(&quot;Hi, Compose&quot;) setContent { // Column { // Layout( // 替换为 // ReusableComposeNode( Text(name, Modifier.clickable { name = &quot;Hi, Kotlin&quot; }) // ) // ) // } } }} 那么这就意味着： 1234567891011121314151617class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var name by mutableStateOf(&quot;Hi, Compose&quot;) setContent { // 组件 1，这个地方会因为 name 的改变而一起重新调用 Column { // 组件 2，这个地方会因为 name 的改变而一起重新调用 Text(name, Modifier.clickable { name = &quot;Hi, Kotlin&quot; }) // 组件 3，这个地方会因为 name 的改变而一起重新调用 } // 组件4，这个地方会因为 name 的改变而一起重新调用 } }} 为了验证，我们测试下： 1234567891011121314151617class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var name by mutableStateOf(&quot;Hi, Compose&quot;) setContent { println(&quot;Recompose 范围测试 1&quot;) Column { println(&quot;Recompose 范围测试 2&quot;) Text(name, Modifier.clickable { name = &quot;Hi, Kotlin&quot; }) println(&quot;Recompose 范围测试 3&quot;) } println(&quot;Recompose 范围测试 4&quot;) } }} 运行： 这个 Log 没有任何问题，现在我们点击： Log 已经验证了我们刚才的结论，那这就涉及到了一个问题：性能风险！ 比如下面的代码有可能出现在你的代码中： 123456789101112131415161718192021222324class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var name by mutableStateOf(&quot;Hi, Compose&quot;) setContent { println(&quot;Recompose 范围测试 1&quot;) Column { println(&quot;Recompose 范围测试 2&quot;) Text(name, Modifier.clickable { name = &quot;Hi, Kotlin&quot; }) println(&quot;Recompose 范围测试 3&quot;) } NBFunction() println(&quot;Recompose 范围测试 4&quot;) } }}@Composablefun NBFunction() { println(&quot;Recompose 范围测试：我干了很多消耗性能的事～～～&quot;) // 这里面干了很多 NB 的事，逻辑量特别大} 你写了一个很牛逼的 Composable 函数，里面干了很多复杂的事，特别消耗性能，那么每次随着 name 的更改，NBFunction() 都会被执行一遍，就就会存在巨大的性能消耗！ 你要不信，我们运行一下，看下 Log： … 额，好尴尬…，点击 name 后，NBFunction() 竟然没有再次执行？但其他 Log 仍然执行了啊！ 难道 NBFunction() 没有被调用？ 其实 NBFunction() 被调用了，只不过进入 NBFunction() 内部后，内部的代码没有被执行！ 都进来了，你跟我说内部代码不执行？– 其实却是是这样，听起来很懵是吧？且听我给你解释～ 其实这是因为：在 Compose 的编译过程中，编译器插件会做干预，这个干预过程会修改我们的 Compose 函数，比如说它会给函数内部的代码加上一些条件判断，判断这个函数的参数跟上一次函数被调用的时候传入的参数有没有改变，如果没有改变，就直接跳过这个函数的内部代码的执行，这是 Compose 的优化。 而你看 NBFunction() 这个函数有参数吗？- - 没有，所以它内部代码永远不会执行，所以 Log 肯定不会打印出来。 那我们加个参数测试一下： 12345678910111213141516171819202122232425class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var name by mutableStateOf(&quot;Hi, Compose&quot;) setContent { println(&quot;Recompose 范围测试 1&quot;) Column { println(&quot;Recompose 范围测试 2&quot;) Text(name, Modifier.clickable { name = &quot;Hi, Kotlin&quot; }) println(&quot;Recompose 范围测试 3&quot;) NBFunction(name) } println(&quot;Recompose 范围测试 4&quot;) } }}@Composablefun NBFunction(name: String) { println(&quot;Recompose 范围测试：我干了很多消耗性能的事～～～&quot;) // 这里面干了很多 NB 的事，逻辑量特别大 Text(&quot;$name&quot;)} 我们给 NBFunction 加个参数，那么随着 name 的改变，看看它会不会被执行： 结果显而易见了！Compose 重组过程中会判断 NBFunction() 的参数 String 是否变化。 那么如果我的参数是一个对象呢？ 比如我传入的是： 1data class User(val name: String) Compose 在重组过程中，依然会对对象类型的参数做判断，不过它的判断规则是 Kotlin 中的 ==，等同于 Java 的 equals，是结构性相等判断。 现在我们修改下代码： 12345678910111213141516171819202122232425262728293031class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var name by mutableStateOf(&quot;Hi, Compose&quot;) var user = User(&quot;marco&quot;) // User 对象 setContent { println(&quot;Recompose 范围测试 1&quot;) Column { println(&quot;Recompose 范围测试 2&quot;) Text(name, Modifier.clickable { name = &quot;Hi, Kotlin&quot; user = User(&quot;marco&quot;) // 点击后，新的 User 对象 }) println(&quot;Recompose 范围测试 3&quot;) NBFunction(user) } println(&quot;Recompose 范围测试 4&quot;) } }}@Composablefun NBFunction(user: User) { println(&quot;Recompose 范围测试：我干了很多消耗性能的事～～～&quot;) // 这里面干了很多 NB 的事，逻辑量特别大 Text(&quot;${user.name}&quot;)}data class User(val name: String) 代码很简单，我们通过 Log 验证下： 我们再改下代码，把 User 换成一个新的内容： 123456var user = User(&quot;marco&quot;)Text(name, Modifier.clickable { name = &quot;Hi, Kotlin&quot; user = User(&quot;marco_2&quot;)}) 再看下 Log： 确实如我们前面预想一样，Compose 重组过程中同样会对 NBFunction() 的「对象参数」也做判断，是结构性相等判断。 @Stable接下来看个有趣的东西，我们再来改一下代码： 123456789101112131415var user = User(&quot;marco&quot;)Text(name, Modifier.clickable { name = &quot;Hi, Kotlin&quot; user = User(&quot;marco&quot;). // user 改回来，都是 marco 内容})==&gt; 此时肯定是会判断相等，不会执行 NBFunction() 内部的代码// 注意了：==&gt; 接下来我们只改一下关键字：data class User(val name: String)// val --&gt; vardata class User(var name: String) 仅仅把 val 改成 var，运行看 Log： Why ???? val 就会跳过 NBFunction() 内部代码，而 var 就不会跳过 NBFunction() 内部代码！ 其实，这是因为 Compose 的本身机制设定： 12data class User(val name: String) // Compose 会认为这是一个可靠的类data class User(var name: String) // Compose 会认为这是一个不可靠的类 对于不可靠的类，我就不管你了，直接进！这也是出于对界面正确性的考虑。 比如我们修改下代码： 与性能相比，准确性才是最终要的，所以就会无条件的进入 NBFunction() 函数再执行一遍。 那如果假设我们可以保证不会出现以上情况，保证 User 对象永远相等，希望 Composable 插件也可以跳过内部执行，提升性能，如何做呢？ 用 @Stable 注解，它是一个稳定性注解，告诉 Compose 编译器插件，这个类是可靠的。这样 Compose 重组过程中就会跳过 NBFunction() 内部代码。 12@Stabledata class User(var name: String) 运行看下 Log： 除了 @Stable 可以认定可靠以外，还有一种方式可以告诉 Compose 是可靠的： 123class User(name: String) { var name by mutableStateOf(name) // 这是一种更通用的写法}","link":"/2024/07/22/Compose%20--%20%E7%8A%B6%E6%80%81%E8%AE%A2%E9%98%85%20&%20%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%20--%2005.%20%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E9%87%8D%E7%BB%84%E5%90%97%EF%BC%9F/"},{"title":"细说 remember 和重组作用域","text":"Source Code based on: androidx.compose.**:**:1.5.0 阅读本篇文章主题之前，建议先看看【 解析 mutableStateOf 源码 】 一文，因为两篇文章是上下篇的关系，看完上篇，可以更好的串联知识点。 话不多说，还是老样子，从 Demo 一步步引出我们的核心知识点。 1234567891011121314151617class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var name by mutableStateOf(&quot;Compose&quot;) setContent { Text(name) // 延时更新 Text 内容 LaunchedEffect(true) { delay(3000) name = &quot;Kotlin&quot; } } }} 一段很简单的代码示例，3s 后文字从 Compose 变为 kotlin，执行看下效果： 现在我们改下代码： 1234567891011121314151617class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { // 从外面挪到里面来... var name by mutableStateOf(&quot;Compose&quot;) Text(name) // 延时更新 Text 内容 LaunchedEffect(true) { delay(3000) name = &quot;Kotlin&quot; } } }} 执行看下效果： 奇怪的事情发生了，3s 后文字没有刷新！ 重组作用域问题出在哪？ 首先我们回顾下 Compose 是怎么「刷新界面」的？比如上面的例子，当 name 重新赋值后，读取它的地方会被标记为「失效」，然后「重组刷新」。 关键知识点 在 Compose 中「重组刷新」并不是单纯的刷新 Text(name) 这一行，而是会把包含 Text(name) 的代码块给包起来，刷新的是「整个代码块」，或者说重组「整个代码块」！ 就像下面这个样子： 这段蓝色背景的代码块会被重新执行一遍，这个蓝色区域就是所谓的：重组作用域（Recompose scope）！ 所以导致没有刷新的根本原因就是： 不仅仅 Text(name) 会被重新执行，var name by mutableStateOf(&quot;Compose&quot;) 也会执行！导致 name 又被重新初始化了。 remember那怎么解决？不知道你发现没有，其实开发工具已经提示我们了： mutableStateOf 是标红的，并且错误提示：Creating a state object during composition without using remember. 意思就是：你在组合过程里面创建了 StateObject 对象，但是没有用 remember。 那怎么使用？很简单，只需要套一层 remember，代码如下： 123456789101112131415class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { var name by remember { mutableStateOf(&quot;Compose&quot;) } Text(name) LaunchedEffect(true) { delay(3000) name = &quot;Kotlin&quot; } } }} 加了 remember 后，在第一次执行的时候，会执行 Lambda 表达式，也就是执行 mutableStateOf(&quot;Compose&quot;)，并且 remember 会保存结果（StateObject），再次调用的时候会直接返回保存的老对象（StateObject），而不是再次执行 Lambda 表达式里面的代码，相当于充当了「缓存」的功能。 我们执行下修改后的代码： 文字更新了！remember 起到了缓存的作用，就是为了防止多次初始化变量而导致程序不可控！ 所以有个原则 在 Compose 里面你只要用了 mutableStateOf，那么能加 remember 我们就加 remember。 另外我们需要注意 remember 是可以带参数的：可以「一个」或者「多个」参数。 1234567891011121314151617181920212223242526272829📄 androidx.compose.runtime -&gt; Composables.kt/** * Remember the value returned by [calculation] if [key1] is equal to the previous composition, * otherwise produce and remember a new value by calling [calculation]. */@Composableinline fun &lt;T&gt; remember( key1: Any?, calculation: @DisallowComposableCalls () -&gt; T): T { return currentComposer.cache(currentComposer.changed(key1), calculation)}/** * Remember the value returned by [calculation] if [key1] and [key2] are equal to the previous * composition, otherwise produce and remember a new value by calling [calculation]. */@Composableinline fun &lt;T&gt; remember( key1: Any?, key2: Any?, calculation: @DisallowComposableCalls () -&gt; T): T { return currentComposer.cache( currentComposer.changed(key1) or currentComposer.changed(key2), calculation )} 有什么用，举个例子说明，比如我们自定义了一个 Composable 函数： 12345@Composablefun showCharCount(value: String) { val length = value.length Text(&quot;字符串长度：$length&quot;)} 很简单，一个显示字符串长度的函数。 现在我们来假设一个场景： 传入进来的字符串特别长； 并且 showCharCount 反复被调用了很多次； 那么 value.length 每次都被调用，就显得有点笨重了，所以我们可以给它加上一个 remember： 1234567@Composablefun showCharCount(value: String) { val length = remember { value.length } Text(&quot;字符串长度：$length&quot;)} 但此时就会出现一个问题： 12345678910@Composablefun showCharCount(value: String) { // 第一次传进来：abcd // 第二次传进来：abcdefg // 第三次传进来：abcdefghijklmn val length = remember { value.length } Text(&quot;字符串长度：$length&quot;)} 字符串长度永远都是：4，因为 value.length 不会被执行，那怎么办： 12345678910@Composablefun showCharCount(value: String) { // 第一次传进来：abcd // 第二次传进来：abcdefg // 第三次传进来：abcdefghijklmn val length = remember(value) { value.length } Text(&quot;字符串长度：$length&quot;)} 我们给 remember 加了一个参数：value，只要这个 key 变化了，那么就会重新执行 Lambda 表达式，这就是带参数的 remember 的用法。","link":"/2024/07/10/Compose%20--%20%E7%8A%B6%E6%80%81%E8%AE%A2%E9%98%85%20&%20%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%20--%2002.%20remember%20%E5%92%8C%E9%87%8D%E7%BB%84%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"title":"有状态、无状态、状态提升","text":"Source Code based on: androidx.compose.**:**:1.5.0 先来看两段 Compose 的官方描述： 利用 Compose，您可以构建不与特定 activity 或 fragment 相关联的小型「无状态」组件，这让您可以轻松重用和测试这些组件。 使用 remember 存储对象的可组合项包含「内部状态」，这会使该可组合项「有状态」。在调用方不需要控制状态，并且不必自行管理状态便可使用状态的情况下，「有状态」会非常有用。但是，具有「内部状态」的可组合项往往不易重复使用，也更难测试。 所以我们可以抛出三个问题： 什么是「无状态」？ 什么是「有状态」？ 什么是「内部状态」？ 带着这三个问题，我们开始探讨 Compose 中的状态。 无状态状态是什么？ 在传统 Android 中，比如 TextView，它的状态就是「内部的属性」，比如我们可以通过 getText() 获取 TextView 的文字，setText() 设置 TextView 的文字。 我们看下面的代码： 12345678910class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { val name = &quot;Hi, Compose&quot; Text(name) } }} 现在思考一个问题：Text() 组件在这里能像 TextView() 一样既能 getText()、也能 setText() 吗？ 很明显不能！Text(name) 只是用了 name，并没有保存，所以它是一个「无状态组件」。 有状态现在我们自定义一个 Compose 函数： 12345@Composablefun HiCompose() { val name = &quot;Hi, Compose&quot; Text(name)} 请问：Text() 有状态吗？- - 没有（我们刚刚才说过） 那么：HiCompose() 呢？- - 有！它的内部有一个属于它自己的变量：Hi, Compose，准确的来说，它是有「内部状态」的。 所以，Compose 组件是可以「有状态」，也可以「无状态」，而所谓的有没有状态 - - 其实都是指：「内部状态」！ 状态提升思考一个问题，既然 HiCompose() 函数是有「内部状态」的，那我如果想从「外部」获取它的「内部状态」，该如何做？ 比如下面的代码： 123456789101112131415class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { HiCompose().name ??? // 这里如何获取到 HiCompose 内部的 name? } }}@Composablefun HiCompose() { val name = &quot;Hi, Compose&quot; Text(name)} 这就相当于你要从外部获取一个函数内部的变量，是获取不到的，那如何做呢？ 123456789101112131415class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { val name = &quot;Hi, Compose&quot; HiCompose(name) } }}@Composablefun HiCompose(name: String) { Text(name)} 我们把 HiCompose() 「内部状态」给提到了「参数」里面，然后外部就可以传入「状态」，两者就联系起来了。 在 Compose 中这种做法就叫做：「状态提示」（State Hoisting） 那么，此时 HiCompose 还有状态吗？- - 现在它就是「无状态」的！因为它已经没有「内部状态」了，状态上提到外面去了。 输入框：TextFieldCompose 有一个典型的状态提升的组件示例：TextField，它是一个文本输入框，类似于 EditText。 123456789class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { TextField(value = , onValueChange = ) } }} 其中 value 就是从 TextField 内部提升上来的，我们来给它传个值： 12345678910class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { var name = &quot;&quot; TextField(name, onValueChange = ) } }} onValueChange 是一个函数类型的参数，可以写成 Lambda 表达式： 12345678910111213class MainActivity : ComponentActivity() { @OptIn(ExperimentalMaterial3Api::class) override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { var name = &quot;&quot; TextField(name, { }) } }} 此时什么也没填，运行看下效果： 键盘都敲冒烟了，但是输入框却没有任何内容，问题肯定出在 onValueChange，因为我们什么也没填，那填什么？ 12345678910111213class MainActivity : ComponentActivity() { @OptIn(ExperimentalMaterial3Api::class) override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { var name = &quot;&quot; TextField(name, { newValue -&gt; name = newValue }) } }} 这就这么简单，newValue 就是输入的内容，把 newValue 赋值给 name，name 才是输入框显示的内容实际值。 运行看下效果： 怎么还不行？如果你看了之前的文章，应该能找到问题点在哪！ 修改下代码： 12345678910111213class MainActivity : ComponentActivity() { @OptIn(ExperimentalMaterial3Api::class) override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { var name by remember { mutableStateOf(&quot;&quot;) } TextField(name, { newValue -&gt; name = newValue }) } }} 再次运行：","link":"/2024/07/13/Compose%20--%20%E7%8A%B6%E6%80%81%E8%AE%A2%E9%98%85%20&%20%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%20--%2003.%20%E6%9C%89%E7%8A%B6%E6%80%81%E3%80%81%E6%97%A0%E7%8A%B6%E6%80%81%E3%80%81%E7%8A%B6%E6%80%81%E6%8F%90%E5%8D%87/"},{"title":"解析 mutableStateOf 源码","text":"其实原理性分析的文章，真的很难讲的通俗易懂，讲的简单浅显没必要写，讲的繁琐难懂往往大家也不乐意看，所以怎么找个好的角度慢慢钻进去尤为重要，比如：Begin simple code，如果确实能帮助到大家完全理解了文章所讲述到的源码理论，那就点个赞吧！ 引入话题 正如我上面说的，直接讲原理太枯燥（你也会很懵），我喜欢从简单代码入手，带你一点点进入，现在开始。先看一个最简单的代码示例： 1234567891011121314class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // 这种定义变量的方式随处可见了 val name = mutableStateOf(&quot;Compose&quot;) setContent { ComposeBlogTheme { Text(name.value) } } }} 我先来简单解读一下这段代码的原理： 当我们定义一个变量，用 mutableStateOf 包起来后，它就变成了一个 MutableState 类型的对象。 同时，我们取值的话就必须要写 name.value，这样能才能取到 “Compose”，因为name 不再是一个 String，而是 MutableState 对象，也可以叫“状态” 。 此时，name 是一个被订阅的状态，name.value 就是一个被订阅的值，如果它发生变化，Text() 函数就会重新执行一遍，更新到最新的值。 现在我们修改下代码，3s 后改变 name.value 的值： 123456789101112131415161718class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val name = mutableStateOf(&quot;Compose&quot;) setContent { ComposeBlogTheme { Text(name.value) } LaunchedEffect(true) { delay(3000) // 3s 延迟 name.value = &quot;Kotlin&quot; // 修改 name.value } } }} 运行下： ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/141782121dd4b200a5d4e86a30eb3edf.gif =400x) 现在关于 mutableStateOf 的用法你已经掌握了，但同时就会产生了一个疑问，name 被自动订阅了，它的值改变了就会让界面重新刷新，这背后的“状态订阅&amp;刷新机制”的原理是什么？ 如果你想深入了解，那么接着往下看。 状态订阅&amp;自动刷新 基于 androidx.compose.runtime:runtime:1.4.0 版本 硬核部分走起，查看 mutableStateOf() 源码： 1234fun &lt;T&gt; mutableStateOf( value: T, policy: SnapshotMutationPolicy&lt;T&gt; = structuralEqualityPolicy()): MutableState&lt;T&gt; = createSnapshotMutableState(value, policy) mutableStateOf() 返回的是一个 MutableState 对象，这个我们前面说过。 mutableStateOf() 又调用了另一个函数：**createSnapshotMutableState()**。 进入 **createSnapshotMutableState()**： 1234internal actual fun &lt;T&gt; createSnapshotMutableState( value: T, policy: SnapshotMutationPolicy&lt;T&gt;): SnapshotMutableState&lt;T&gt; = ParcelableSnapshotMutableState(value, policy) 又调用了 ParcelableSnapshotMutableState() 函数： 1234567internal class ParcelableSnapshotMutableState&lt;T&gt;( value: T, policy: SnapshotMutationPolicy&lt;T&gt;) : SnapshotMutableStateImpl&lt;T&gt;(value, policy), Parcelable { // 这里内部的代码全部都是对 Parcelable 接口的实现，我们不用关心，不是核心内容 ... ...} 关键在 SnapshotMutableStateImpl，它里面才是最核心的逻辑： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788internal open class SnapshotMutableStateImpl&lt;T&gt;( value: T, override val policy: SnapshotMutationPolicy&lt;T&gt;) : StateObject, SnapshotMutableState&lt;T&gt; { @Suppress(&quot;UNCHECKED_CAST&quot;) override var value: T get() = next.readable(this).value set(value) = next.withCurrent { if (!policy.equivalent(it.value, value)) { next.overwritable(this, it) { this.value = value } } } private var next: StateStateRecord&lt;T&gt; = StateStateRecord(value) override val firstStateRecord: StateRecord get() = next override fun prependStateRecord(value: StateRecord) { @Suppress(&quot;UNCHECKED_CAST&quot;) next = value as StateStateRecord&lt;T&gt; } @Suppress(&quot;UNCHECKED_CAST&quot;) override fun mergeRecords( previous: StateRecord, current: StateRecord, applied: StateRecord ): StateRecord? { val previousRecord = previous as StateStateRecord&lt;T&gt; val currentRecord = current as StateStateRecord&lt;T&gt; val appliedRecord = applied as StateStateRecord&lt;T&gt; return if (policy.equivalent(currentRecord.value, appliedRecord.value)) current else { val merged = policy.merge( previousRecord.value, currentRecord.value, appliedRecord.value ) if (merged != null) { appliedRecord.create().also { (it as StateStateRecord&lt;T&gt;).value = merged } } else { null } } } override fun toString(): String = next.withCurrent { &quot;MutableState(value=${it.value})@${hashCode()}&quot; } private class StateStateRecord&lt;T&gt;(myValue: T) : StateRecord() { override fun assign(value: StateRecord) { @Suppress(&quot;UNCHECKED_CAST&quot;) this.value = (value as StateStateRecord&lt;T&gt;).value } override fun create(): StateRecord = StateStateRecord(value) var value: T = myValue } /** * The componentN() operators allow state objects to be used with the property destructuring * syntax * * ``` * var (foo, setFoo) = remember { mutableStateOf(0) } * setFoo(123) // set * foo == 123 // get * ``` */ override operator fun component1(): T = value override operator fun component2(): (T) -&gt; Unit = { value = it } /** * A function used by the debugger to display the value of the current value of the mutable * state object without triggering read observers. */ @Suppress(&quot;unused&quot;) val debuggerDisplayValue: T @JvmName(&quot;getDebuggerDisplayValue&quot;) get() = next.withCurrent { it }.value} 好长啊～算了，不看了🙈… 接下来我带你一步步探索其中的奥秘！ 先看开头部分： 12345678910111213141516171819internal open class SnapshotMutableStateImpl&lt;T&gt;( value: T, override val policy: SnapshotMutationPolicy&lt;T&gt;) : StateObject, SnapshotMutableState&lt;T&gt; { @Suppress(&quot;UNCHECKED_CAST&quot;) override var value: T get() = next.readable(this).value set(value) = next.withCurrent { if (!policy.equivalent(it.value, value)) { next.overwritable(this, it) { this.value = value } } } private var next: StateStateRecord&lt;T&gt; = StateStateRecord(value) override val firstStateRecord: StateRecord get() = next ... ...} 一个 value 属性印入眼帘，这就是文章开头代码里面用到的 name.value。 value 有 get() 和 set() 函数，并且都有具体的实现。 📓 next 是个啥？ 无论是 get() 还是 set() 都有一个 next。 12get() = next.readable(this).valueset(value) = next.withCurrent {...} 它是个啥？我们得先搞明白这个。 1private var next: StateStateRecord&lt;T&gt; = StateStateRecord(value) 它的类型是 StateStateRecord，那 StateStateRecord 有是个啥？ 12345678910private class StateStateRecord&lt;T&gt;(myValue: T) : StateRecord() { override fun assign(value: StateRecord) { @Suppress(&quot;UNCHECKED_CAST&quot;) this.value = (value as StateStateRecord&lt;T&gt;).value } override fun create(): StateRecord = StateStateRecord(value) var value: T = myValue} StateStateRecord 继承了 StateRecord，那 StateRecord 又是个啥呢？ 123456abstract class StateRecord { internal var snapshotId: Int = currentSnapshot().id // 记录快照 id internal var next: StateRecord? = null // 下一个状态记录的引用，状态记录存储在一个链表中 abstract fun assign(value: StateRecord) // 复制 StateRecord abstract fun create(): StateRecord // 创建一个新的记录相同的 StateRecord} 你只要知道 StateRecord 是一个链表的数据结构即可，而 StateStateRecord 实现了它，并且将 value 进行了封装。 下面我们要讲别的了，先记住：StateRecord 是一个链表的数据结构！ 接着说，如果你仔细看代码的话，会发现 SnapshotMutableStateImpl 其实继承了两个接口： 123456internal open class SnapshotMutableStateImpl&lt;T&gt;( value: T, override val policy: SnapshotMutationPolicy&lt;T&gt;) : StateObject, SnapshotMutableState&lt;T&gt; { ... ...} 一个 StateObjet、一个 SnapshotMutableState。 我们先来看下 SnapshotMutableState： 123456interface SnapshotMutableState&lt;T&gt; : MutableState&lt;T&gt; { /** * A policy to control how changes are handled in a mutable snapshot. */ val policy: SnapshotMutationPolicy&lt;T&gt;} SnapshotMutableState 继承了 MutableState，正好对应着我们文章开头说的，mutableStateOf() 返回的就是一个 MutableState，我们说是因为它实现了订阅从而可以刷新，但！！！真正的原因并不是因为它！ 真正实现状态订阅机制的是另外一个接口：StateObjet！ 我们现在来看下 StateObject 这个大佬干了什么事： 1234567891011121314interface StateObject { /** * The first state record in a linked list of state records. */ val firstStateRecord: StateRecord fun prependStateRecord(value: StateRecord) fun mergeRecords( previous: StateRecord, current: StateRecord, applied: StateRecord ): StateRecord? = null} 代码非常简单，但里面有一个核心： 1val firstStateRecord: StateRecord 它是干嘛用的？我们去瞅瞅哪里用了它： 1234private var next: StateStateRecord&lt;T&gt; = StateStateRecord(value) override val firstStateRecord: StateRecord get() = next 哦，原来 firstStateRecord 是用来记录 StateRecord 这个链表的 头节点 用的。 📓 get() 上面应该算是把 next 是什么讲清楚了吧？– 它就是 StateRecord，更准确的说就是 StateRecord 链表的头节点。 下面我们开始扒扒 get() 具体的逻辑了。 1get() = next.readable(this).value 进入 readable() ： 1234567891011fun &lt;T : StateRecord&gt; T.readable(state: StateObject): T { val snapshot = Snapshot.current // 第一件事 snapshot.readObserver?.invoke(state) // 第二件事 return readable(this, snapshot.id, snapshot.invalid) ?: sync { val syncSnapshot = Snapshot.current @Suppress(&quot;UNCHECKED_CAST&quot;) readable(state.firstStateRecord as T, syncSnapshot.id, syncSnapshot.invalid) ?: readError() }} 干了两件事，第一件事： 1snapshot.readObserver?.invoke(state) // 第一件事 readObserver 是一个读操作的观察者，这个操作是记录 StateObject 中的值被哪里调用了，比如开头的代码示例： 1234567891011121314151617181920class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val name = mutableStateOf(&quot;Compose&quot;) setContent { ComposeBlogTheme { // 这里调用了 name.value，就会执行到： // get() --&gt; readServer() --&gt; 记录这里调用了 value 值 Text(name.value) } LaunchedEffect(true) { delay(3000) name.value = &quot;Kotlin&quot; } } }} 所以，我们可以把这个操作理解为它是一个订阅操作：订阅状态，记录 name.value 在哪里调用了。 第二件事： 12345return readable(this, snapshot.id, snapshot.invalid) ?: sync { val syncSnapshot = Snapshot.current @Suppress(&quot;UNCHECKED_CAST&quot;) readable(state.firstStateRecord as T, syncSnapshot.id, syncSnapshot.invalid) ?: readError()} 调用了三参数的 readable()： 1234567891011121314151617private fun &lt;T : StateRecord&gt; readable(r: T, id: Int, invalid: SnapshotIdSet): T? { // The readable record is the valid record with the highest snapshotId var current: StateRecord? = r var candidate: StateRecord? = null while (current != null) { if (valid(current, id, invalid)) { candidate = if (candidate == null) current else if (candidate.snapshotId &lt; current.snapshotId) current else candidate } current = current.next } if (candidate != null) { @Suppress(&quot;UNCHECKED_CAST&quot;) return candidate as T } return null} 前边我们说错：StateRecord 是一个链表，三参数里面的工作就是通过表头对象遍历列表来获取 最新的、有效的 StateRecord。 最终返回一个 最新的、有效的 StateRecord。（什么是最新的、有效的，这个可以不用关心，这跟要结合 Snapshot 快照系统说，你直接过滤即可，不影响我们原理的理解） 所以，整个 readable() 方法就干了两件事： 返回最新的、有效的 StateRecord 记录在哪里调用了 value 1get() = next.readable(this).value 最后还剩一个 value，这就很简单了，前面我们说过 StateStateRecord (StateRecord 的实现类) 会对 value 进行封装，而 StateRecord 它们只是一个链表，我们要获取到值，就要再调用 value 获取内部被包着的值。 到这里 get() 就讲完了！ 📓 set() 现在来看 set() 的具体代码：（细节点注意：这边我把代码截图了，而不是纯代码段，你留意一下，下面会回归到这里） ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/548aff88360d4dffda83386ed2ee80e3.png =500x) next 是啥不用说了吧，那 withCurrent 是什么？ 12inline fun &lt;T : StateRecord, R&gt; T.withCurrent(block: (r: T) -&gt; R): R = block(current(this, Snapshot.current)) 它只有一个参数 block，而 block 是一个函数类型的参数，它的工作很直接，直接调用这个函数类型的参数，也就是 withCurrent 后面跟着的 Lambda 表达式。 ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/63c3c244bd0959768487d28c00ed08ca.png =500x) block 里面传入了一个 current 函数，它做了什么： 12internal fun &lt;T : StateRecord&gt; current(r: T, snapshot: Snapshot) = readable(r, snapshot.id, snapshot.invalid) ?: readError() 发现了什么？它调用了一个三参数的 readable()，你还记得三参数的 readable() 是做什么的吗？ ⇒ 获取 最新的、有效的 StateRecord。 这个时候你在看下我开头为啥对代码做了截图： ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/df81d16a784a74cbb297037fdce6eda0.png =500x) 懂啥意思没？withCurrent 传入的 current 函数的返回值就对应着代码提示器提示的 it 对象（一个 StateStateRecord）。 接着看代码： 123456set(value) = next.withCurrent { // 判断新旧值 if (!policy.equivalent(it.value, value)) { next.overwritable(this, it) { this.value = value } }} if 判断里面会判断取到的 StateRecord 的值和新设置的值是否相同，没变直接结束，变了就进入下一步 overwritable()。 我们看看它做了什么： 123456789101112131415internal inline fun &lt;T : StateRecord, R&gt; T.overwritable( state: StateObject, candidate: T, block: T.() -&gt; R): R { var snapshot: Snapshot = snapshotInitializer return sync { // 第一件事 snapshot = Snapshot.current // 第二件事 this.overwritableRecord(state, snapshot, candidate).block() }.also { notifyWrite(snapshot, state) }} 也干了两件事： 获取快照；2. 调用了overwritableRecord() 函数； Snapshot 快照的知识我们可以先忽略，来看 overwritableRecord() 做了什么： 12345678910111213141516171819internal fun &lt;T : StateRecord&gt; T.overwritableRecord( state: StateObject, snapshot: Snapshot, candidate: T): T { if (snapshot.readOnly) { snapshot.recordModified(state) } val id = snapshot.id if (candidate.snapshotId == id) return candidate val newData = newOverwritableRecord(state) newData.snapshotId = id snapshot.recordModified(state) return newData} 这段代码又涉及到了另外一个知识点：Snapshot（快照）。 我们将代码分为两端来看： ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/9b9068d1ad9357f3b556a0a502884f0c.png =700x) 核心代码块 1：如果传进来的 StateRecord 的快照 id 正好对应当前 snapshot 的 id，那么直接返回。 核心代码块 2：否则会创建一个新的或者返回一个弃用的 StateRecord，然后将快照 id 赋予新的 StateRecord。 说白了最终就是要取到一个对应当前 snapshot 的 StateRecord！ 🤔 此时就存在一个很大的疑问了？什么是 Snapshot（快照）？Snapshot 怎么和 StateRecord 绑在一起了？ 关于 Compose 的 Snapshot 机制，可以看看这篇文章 揭秘 Jetpack Compose快照系统 ，讲的很好。 但由于 Snapshot 真的不是一两句就能说清楚的，但我仍然告诉你它不影响你对这篇文章原理的理解。 继续回到代码： 1234567891011121314internal inline fun &lt;T : StateRecord, R&gt; T.overwritable( state: StateObject, candidate: T, block: T.() -&gt; R): R { var snapshot: Snapshot = snapshotInitializer return sync { snapshot = Snapshot.current // 取到一个对应当前 snapshot 的 StateRecord this.overwritableRecord(state, snapshot, candidate).block() }.also { notifyWrite(snapshot, state) }} 取到对应当前 snapshot 的 StateRecord 后，紧接着调用了 block()，它是传进来的参数，是外面传进来的，也就是 {this.value = value}。 123456set(value) = next.withCurrent { // 判断新旧值 if (!policy.equivalent(it.value, value)) { next.overwritable(this, it) { this.value = value } }} 又拐回来了，把传入的新值赋值给拿到的 StateRecord 内部的 value，这不就是写新值的操作么？ 到这里是不是 set() 流程是不是我们就讲完了？ No～，我们再看一下 overwritable() 方法内部： 1234567891011121314internal inline fun &lt;T : StateRecord, R&gt; T.overwritable( state: StateObject, candidate: T, block: T.() -&gt; R): R { var snapshot: Snapshot = snapshotInitializer return sync { snapshot = Snapshot.current // 这里讲完了 this.overwritableRecord(state, snapshot, candidate).block() }.also { notifyWrite(snapshot, state) // 但这里还有个 notifyWrite }} 还有一行我们遗漏了，notifyWrite() 又做了什么？ 123internal fun notifyWrite(snapshot: Snapshot, state: StateObject) { snapshot.writeObserver?.invoke(state)} 有种似曾相识的感觉，在前面分析 get() 函数的时候，我们看到过单参数的 readable() 里面有一行： 1snapshot.readObserver?.invoke(state) 那这里的作用呢？ ⇒ 寻找变量在哪里被读了，然后将这部分内容的组合标记为失效，等到下一帧的时候会重组刷新。 所以，整个 set() 方法就干了两件事： 将传入的值赋值给 StateRecord 内部的 value 写入通知刷新 到这里我们就基本上能够很清晰的明白了状态订阅&amp;自动刷新机制的原理了： 当 get() 被调用的时候，不仅返回值，还会记录读值的地方，也就是哪里调用了（相当于订阅）。 当 set() 被调用的时候，不仅修改值，还会查找读值的地方，然后进行刷新操作（相当于通知）。 📓 by 在实际开发中，如果每次获取值都要加上 value 会显得很冗余，所以 Compose 给我们提供了一种更方便的写法：by。它是 Kotlin 的一个关键字，表示左边的变量用右边的对象作为代理（委托）。 12345678910111213class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val name by mutableStateOf(&quot;Compose&quot;) setContent { ComposeBlogTheme { Text(name) // 可以直接 name，而不需要 name.value } } }} 如果你这么写，IDLE 会提示报错，因为 name 委托给了 mutableStateOf，如果我们要获取 name 的值，那委托对象需要调用 getValue() 和 setValue() 两个函数，这两个函数需要自己实现。 但实际上并不需要我们实现，你通过提示也可以看出来，我们可以直接导入，因为 Compose 内部已经帮我们实现好了这个方法。 12import androidx.compose.runtime.getValueimport androidx.compose.runtime.setValue 自此，关于 Compose 的状态订阅&amp;自动刷新机制的原理算是讲明白了吧…","link":"/2024/07/05/Compose%20--%20%E7%8A%B6%E6%80%81%E8%AE%A2%E9%98%85%20&%20%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%20--%2001.%20%E8%A7%A3%E6%9E%90%20mutableStateOf%20%E6%BA%90%E7%A0%81/"},{"title":"SQLite -- 从入门到精通","text":"@TOC SQLite 是遵循一套独特的称为语法的规则和准则。有个重要的点值得注意，SQLite 是不区分大小写的，但也有一些命令是大小写敏感的，比如 GLOB 和 glob 在 SQLite 的语句中有不同的含义。 一、数据库操作1.1 新建数据库可以直接执行 sqlite3 filename 打开或创建一个 SQLite 数据库。如果文件不存在，SQLite 会自动创建它。 1234maxin@maxindeMacBook-Pro db % sqlite3 test.dbSQLite version 3.46.1 2024-08-13 09:16:08Enter &quot;.help&quot; for usage hints.sqlite&gt; 1.2 查看数据库12sqlite&gt; .databasesmain: /Users/maxin/Desktop/db/test.db r/w 使用 .quit 或者 .exit 退出 sqlite3 工具。 再查看当前目录，会发现新增了一个 test.db 文件。 ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/3e4b894601524de49e534f2e78c6844b.png =430x) 1.3 查看帮助指令使用 .help 查看 帮助信息。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364sqlite&gt; .help.archive ... Manage SQL archives.auth ON|OFF Show authorizer callbacks.backup ?DB? FILE Backup DB (default &quot;main&quot;) to FILE.bail on|off Stop after hitting an error. Default OFF.cd DIRECTORY Change the working directory to DIRECTORY.changes on|off Show number of rows changed by SQL.check GLOB Fail if output since .testcase does not match.clone NEWDB Clone data into NEWDB from the existing database.connection [close] [#] Open or close an auxiliary database connection.databases List names and files of attached databases.dbconfig ?op? ?val? List or change sqlite3_db_config() options.dbinfo ?DB? Show status information about the database.dump ?OBJECTS? Render database content as SQL.echo on|off Turn command echo on or off.eqp on|off|full|... Enable or disable automatic EXPLAIN QUERY PLAN.excel Display the output of next command in spreadsheet.exit ?CODE? Exit this program with return-code CODE.expert EXPERIMENTAL. Suggest indexes for queries.explain ?on|off|auto? Change the EXPLAIN formatting mode. Default: auto.filectrl CMD ... Run various sqlite3_file_control() operations.fullschema ?--indent? Show schema and the content of sqlite_stat tables.headers on|off Turn display of headers on or off.help ?-all? ?PATTERN? Show help text for PATTERN.import FILE TABLE Import data from FILE into TABLE.indexes ?TABLE? Show names of indexes.intck ?STEPS_PER_UNLOCK? Run an incremental integrity check on the db.limit ?LIMIT? ?VAL? Display or change the value of an SQLITE_LIMIT.lint OPTIONS Report potential schema issues..load FILE ?ENTRY? Load an extension library.log FILE|on|off Turn logging on or off. FILE can be stderr/stdout.mode MODE ?OPTIONS? Set output mode.nonce STRING Suspend safe mode for one command if nonce matches.nullvalue STRING Use STRING in place of NULL values.once ?OPTIONS? ?FILE? Output for the next SQL command only to FILE.open ?OPTIONS? ?FILE? Close existing database and reopen FILE.output ?FILE? Send output to FILE or stdout if FILE is omitted.parameter CMD ... Manage SQL parameter bindings.print STRING... Print literal STRING.progress N Invoke progress handler after every N opcodes.prompt MAIN CONTINUE Replace the standard prompts.quit Stop interpreting input stream, exit if primary..read FILE Read input from FILE or command output.recover Recover as much data as possible from corrupt db..restore ?DB? FILE Restore content of DB (default &quot;main&quot;) from FILE.save ?OPTIONS? FILE Write database to FILE (an alias for .backup ...).scanstats on|off|est Turn sqlite3_stmt_scanstatus() metrics on or off.schema ?PATTERN? Show the CREATE statements matching PATTERN.separator COL ?ROW? Change the column and row separators.session ?NAME? CMD ... Create or control sessions.sha3sum ... Compute a SHA3 hash of database content.shell CMD ARGS... Run CMD ARGS... in a system shell.show Show the current values for various settings.stats ?ARG? Show stats or turn stats on or off.system CMD ARGS... Run CMD ARGS... in a system shell.tables ?TABLE? List names of tables matching LIKE pattern TABLE.timeout MS Try opening locked tables for MS milliseconds.timer on|off Turn SQL timer on or off.trace ?OPTIONS? Output each SQL statement as it is run.version Show source, library and compiler versions.vfsinfo ?AUX? Information about the top-level VFS.vfslist List all available VFSes.vfsname ?AUX? Print the name of the VFS stack.width NUM1 NUM2 ... Set minimum column widths for columnar output 二、表操作2.1 创建表SQLite 的 CREATE TABLE 语句用于在任何给定的数据库创建一个新表。创建基本表，涉及到命名表、定义列及每一列的数据类型。 CREATE TABLE 语句的基本语法如下： 1234567CREATE TABLE database_name.table_name( column1 datatype PRIMARY KEY(one or more columns), column2 datatype, column3 datatype, ..... columnN datatype,); CREATE TABLE 是告诉数据库系统创建一个新表的关键字。CREATE TABLE 语句后跟着表的唯一的名称或标识。你也可以选择指定带有 table_name 的 database_name。 例如：创建一个 COMPANY 表，ID 作为主键，NOT NULL 的约束表示在表中创建纪录时这些字段不能为 NULL： 1234567sqlite&gt; CREATE TABLE COMPANY( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL); 我们来解读一下这种语法结构： CREATE TABLE 语句 CREATE TABLE 是用来 创建数据库表 的 SQL 语句。 拆解 含义 说明 COMPANY 新表的 表名 你可以通过这个名字来引用该表 圆括号 () 括号中的内容定义了 表的结构 即每一列（字段）的名称、数据类型及约束条件 表的列定义 在这段语法中，每一行定义了一列（字段），包括字段名、数据类型，以及一些可选的约束条件。 列（字段名） 数据类型 是否允许为空 是否为主键 说明 ID INT 不允许 是 员工的唯一标识（主键） NAME TEXT 不允许 否 员工的姓名 AGE INT 不允许 否 员工的年龄 ADDRESS CHAR(50) 允许 否 员工的地址，最多 50 个字符 SALARY REAL 允许 否 员工的薪资（浮点数） 我们说过：SQLite 是不区分大小写的，所以如果你像下面这样定义也是可以的： 1234567create table company ( id int primary key not null, name text not null, age int not null, address char(50), salary real); 常见的编码习惯 大写关键字风格（例如：CREATE TABLE、SELECT、INSERT 等关键字大写）这种风格比较常见于官方文档和企业级开发，目的是让 SQL 关键字在代码中更醒目，易于识别。例如：CREATE TABLE COMPANY (ID INT PRIMARY KEY)。 小写关键字风格（例如：create table、select）有些开发者或社区更倾向于全小写，认为这样风格一致，看起来更加简洁。在某些语言中，如 Python 等，惯用全小写风格，开发者会把这个习惯带到 SQL 中。 这种差异主要是个人偏好或团队风格的选择，功能上没有任何影响。 编写风格建议 无论你使用大写还是小写，保持一致性 都是良好的编码习惯，尤其是在多人协作开发中。通常，团队会统一编码规范，比如： 所有 「SQL 关键字」 用大写，例如：SELECT、FROM。 「表名」 和 「列名」 用小写（或蛇形命名），例如：user_name、order_date。 比如像下面这样： 12345CREATE TABLE company ( id INT PRIMARY KEY, name TEXT NOT NULL, age INT NOT NULL); 再比如，我们创建名为 user、student 的表： 12345maxin@maxindeMacBook-Pro db % sqlite3 test.dbSQLite version 3.46.1 2024-08-13 09:16:08Enter &quot;.help&quot; for usage hints.sqlite&gt; CREATE TABLE user(name text, age int);sqlite&gt; CREATE TABLE student(id int, name text, age int, primary key(id)); 2.2 表信息表创建完成后，你可以使用 .tables 或者 .table tableName 命令查看所有现有表格或者单个表格的信息： 12345678sqlite&gt; .tablesCOMPANY student usersqlite&gt; .table COMPANYCOMPANYsqlite&gt; .table studentstudentsqlite&gt; .table useruser 2.3 表索引信息在 SQLite 中，.indices 是 SQLite 命令行工具中用于 列出一个表所有索引 的命令。这个命令的作用是「展示某个表已经定义的所有索引」。 基本语法： 1.indices 表名 例如： 1234567sqlite&gt; .indices COMPANYsqlite_autoindex_COMPANY_1------------------------------------------sqlite&gt; .indices studentsqlite_autoindex_student_1------------------------------------------sqlite&gt; .indices user # user 表没有建索引 sqlite_autoindex_company_1 / sqlite_autoindex_student_1 这是 SQLite 自动创建的索引，因为 COMPANY / student 表中的 ID 列定义为 主键（PRIMARY KEY）。SQLite 会自动为主键列创建索引，帮助快速查询。 2.4 表结构信息在 SQLite 中，.schema 是 SQLite 命令行工具中的一个常用命令，用来「查看数据库中表、视图、索引等对象的 创建语句（DDL）」。 查看所有对象的创建语句： 12345678910sqlite&gt; .schemaCREATE TABLE user(name text,age int);CREATE TABLE student(id int,name text,age int,primary key(id));CREATE TABLE COMPANY( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL); 查看指定表的创建语句： 1234567891011121314sqlite&gt; .schema userCREATE TABLE user(name text,age int);------------------------------------------sqlite&gt; .schema studentCREATE TABLE student(id int,name text,age int,primary key(id));------------------------------------------sqlite&gt; .schema COMPANYCREATE TABLE COMPANY( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL); 2.5 删除表SQLite 的 DROP TABLE 语句用来删除表定义及其所有相关数据、索引、触发器、约束和该表的权限规范。 使用此命令时要特别注意，因为一旦一个表被删除，表中所有信息也将永远丢失！！！ 基本语法： 1DROP TABLE database_name.table_name; 例如：我们删除 user 表 让我们先确认 user 表已经存在，然后我们将其从数据库中删除。 12sqlite&gt; .tablesCOMPANY student user 这意味着 user 表已存在数据库中，接下来让我们把它从数据库中删除，如下： 12sqlite&gt; drop table user;sqlite&gt; 现在，如果尝试 .tables 命令，那么将无法找到 user 表了： 123sqlite&gt; .tablesCOMPANY studentsqlite&gt; 三、数据记录操作3.1 新增记录SQLite 的 INSERT INTO 语句用于向数据库的某个表中添加新的数据行。 INSERT INTO 语句有两种基本语法，如下所示： 12INSERT INTO TABLE_NAME [(column1, column2, column3, ...columnN)] VALUES (value1, value2, value3, ...valueN); 在这里，column1, column2,…columnN 是要插入数据的表中的列的名称。如果要为表中的所有列添加值，你也可以不需要在 SQLite 查询中指定列名称。但要确保值的顺序与列在表中的顺序一致。 SQLite 的 INSERT INTO 语法如下： 1INSERT INTO TABLE_NAME VALUES (value1,value2,value3,...valueN); 例如，我们往 COMPANY 里面添加数据： 1234567891011121314151617INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)VALUES (1, 'Paul', 32, 'California', 20000.00 );INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)VALUES (2, 'Allen', 25, 'Texas', 15000.00 );INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)VALUES (3, 'Teddy', 23, 'Norway', 20000.00 );INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)VALUES (4, 'Mark', 25, 'Rich-Mond ', 65000.00 );INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)VALUES (5, 'David', 27, 'Texas', 85000.00 );INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)VALUES (6, 'Kim', 22, 'South-Hall', 45000.00 ); 你也可以使用第二种语法在 COMPANY 表中创建一个记录，如下所示： 123456INSERT INTO COMPANY VALUES (1, 'Paul', 32, 'California', 20000.00 );INSERT INTO COMPANY VALUES (2, 'Allen', 25, 'Texas', 15000.00 );INSERT INTO COMPANY VALUES (3, 'Teddy', 23, 'Norway', 20000.00 );INSERT INTO COMPANY VALUES (4, 'Mark', 25, 'Rich-Mond ', 65000.00 );INSERT INTO COMPANY VALUES (5, 'David', 27, 'Texas', 85000.00 );INSERT INTO COMPANY VALUES (6, 'Kim', 22, 'South-Hall', 45000.00 ); 3.2 查看记录SQLite 的 SELECT 语句用于从 SQLite 数据库表中获取数据，以结果表的形式返回数据。这些结果表也被称为结果集。 基本语法： 1SELECT column1, column2, columnN FROM table_name; 在这里，column1, column2… 是表的字段，它们的值即是你要获取的。如果你想获取所有可用的字段，那么可以使用下面的语法： 1SELECT * FROM table_name; 例如，我们刚刚给 COMPANY 表添加了数据，现在查看下： 1234567sqlite&gt; select * from company;1|Paul|32|California|20000.02|Allen|25|Texas|15000.03|Teddy|23|Norway|20000.04|Mark|25|Rich-Mond |65000.05|David|27|Texas|85000.06|Kim|22|South-Hall|45000.0 如果只想获取 COMPANY 表中指定的字段，则使用下面的查询： 12345678910sqlite&gt; .mode columnsqlite&gt; SELECT ID, NAME, SALARY FROM COMPANY;ID NAME SALARY-- ----- -------1 Paul 20000.02 Allen 15000.03 Teddy 20000.04 Mark 65000.05 David 85000.06 Kim 45000.0 3.3 不同格式输出在 SQLite 命令行工具中，.mode 用于控制「查询结果的输出格式」。根据需求，你可以选择不同的模式，比如将数据格式化为表格、CSV、HTML 或其他样式。这可以帮助你更方便地查看、调试和导出数据。 常见的 .mode 选项及其作用： 1. column（列模式） 数据以 表格形式 显示，列名和数据对齐，适合人类阅读。 命令：12sqlite&gt; .mode columnsqlite&gt; select * from company; 输出示例：12345678ID NAME AGE ADDRESS SALARY-- ----- --- ---------- -------1 Paul 32 California 20000.02 Allen 25 Texas 15000.03 Teddy 23 Norway 20000.04 Mark 25 Rich-Mond 65000.05 David 27 Texas 85000.06 Kim 22 South-Hall 45000.0 2. list（列表模式） 数据以 竖线（|）分隔，适合快速查看或复制。 命令：12sqlite&gt; .mode listsqlite&gt; select * from company; 输出示例：1234567ID|NAME|AGE|ADDRESS|SALARY1|Paul|32|California|20000.02|Allen|25|Texas|15000.03|Teddy|23|Norway|20000.04|Mark|25|Rich-Mond |65000.05|David|27|Texas|85000.06|Kim|22|South-Hall|45000.0 3. csv（CSV 模式） 数据以 逗号分隔值 格式输出，适合导出到文件或电子表格。 命令：12sqlite&gt; .mode csvsqlite&gt; select * from company; 输出示例：1234567ID,NAME,AGE,ADDRESS,SALARY1,Paul,32,California,20000.02,Allen,25,Texas,15000.03,Teddy,23,Norway,20000.04,Mark,25,&quot;Rich-Mond &quot;,65000.05,David,27,Texas,85000.06,Kim,22,South-Hall,45000.0 4. html（HTML 模式） 数据以 HTML 表格 格式输出，适合导出到网页或报告中。 命令：12sqlite&gt; .mode htmlsqlite&gt; select * from company; 输出示例：123456789101112131415161718192021222324252627282930313233343536373839404142&lt;TR&gt;&lt;TH&gt;ID&lt;/TH&gt;&lt;TH&gt;NAME&lt;/TH&gt;&lt;TH&gt;AGE&lt;/TH&gt;&lt;TH&gt;ADDRESS&lt;/TH&gt;&lt;TH&gt;SALARY&lt;/TH&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;1&lt;/TD&gt;&lt;TD&gt;Paul&lt;/TD&gt;&lt;TD&gt;32&lt;/TD&gt;&lt;TD&gt;California&lt;/TD&gt;&lt;TD&gt;20000.0&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;2&lt;/TD&gt;&lt;TD&gt;Allen&lt;/TD&gt;&lt;TD&gt;25&lt;/TD&gt;&lt;TD&gt;Texas&lt;/TD&gt;&lt;TD&gt;15000.0&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;3&lt;/TD&gt;&lt;TD&gt;Teddy&lt;/TD&gt;&lt;TD&gt;23&lt;/TD&gt;&lt;TD&gt;Norway&lt;/TD&gt;&lt;TD&gt;20000.0&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;4&lt;/TD&gt;&lt;TD&gt;Mark&lt;/TD&gt;&lt;TD&gt;25&lt;/TD&gt;&lt;TD&gt;Rich-Mond &lt;/TD&gt;&lt;TD&gt;65000.0&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;5&lt;/TD&gt;&lt;TD&gt;David&lt;/TD&gt;&lt;TD&gt;27&lt;/TD&gt;&lt;TD&gt;Texas&lt;/TD&gt;&lt;TD&gt;85000.0&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;6&lt;/TD&gt;&lt;TD&gt;Kim&lt;/TD&gt;&lt;TD&gt;22&lt;/TD&gt;&lt;TD&gt;South-Hall&lt;/TD&gt;&lt;TD&gt;45000.0&lt;/TD&gt;&lt;/TR&gt; 5. tabs（制表符分隔模式） 数据以 制表符 分隔，适合导出到文件并在代码或编辑器中处理。 命令：12sqlite&gt; .mode tabssqlite&gt; select * from company; 输出示例：1234567ID NAME AGE ADDRESS SALARY1 Paul 32 California 20000.02 Allen 25 Texas 15000.03 Teddy 23 Norway 20000.04 Mark 25 Rich-Mond 65000.05 David 27 Texas 85000.06 Kim 22 South-Hall 45000.0 6. insert（INSERT 模式） 数据以 INSERT INTO 语句 的形式输出，方便将数据重新导入数据库。 命令：12sqlite&gt; .mode insertsqlite&gt; select * from company; 输出示例：123456INSERT INTO &quot;table&quot;(ID,NAME,AGE,ADDRESS,SALARY) VALUES(1,'Paul',32,'California',20000.0);INSERT INTO &quot;table&quot;(ID,NAME,AGE,ADDRESS,SALARY) VALUES(2,'Allen',25,'Texas',15000.0);INSERT INTO &quot;table&quot;(ID,NAME,AGE,ADDRESS,SALARY) VALUES(3,'Teddy',23,'Norway',20000.0);INSERT INTO &quot;table&quot;(ID,NAME,AGE,ADDRESS,SALARY) VALUES(4,'Mark',25,'Rich-Mond ',65000.0);INSERT INTO &quot;table&quot;(ID,NAME,AGE,ADDRESS,SALARY) VALUES(5,'David',27,'Texas',85000.0);INSERT INTO &quot;table&quot;(ID,NAME,AGE,ADDRESS,SALARY) VALUES(6,'Kim',22,'South-Hall',45000.0); 7. json（JSON 模式） 数据以 JSON 格式 输出，适合在开发过程中使用，也非常适合与前端、API 交互，或者导出 JSON 数据。 命令：12sqlite&gt; .mode jsonsqlite&gt; select * from company; 输出示例：123456[{&quot;ID&quot;:1,&quot;NAME&quot;:&quot;Paul&quot;,&quot;AGE&quot;:32,&quot;ADDRESS&quot;:&quot;California&quot;,&quot;SALARY&quot;:20000.0},{&quot;ID&quot;:2,&quot;NAME&quot;:&quot;Allen&quot;,&quot;AGE&quot;:25,&quot;ADDRESS&quot;:&quot;Texas&quot;,&quot;SALARY&quot;:15000.0},{&quot;ID&quot;:3,&quot;NAME&quot;:&quot;Teddy&quot;,&quot;AGE&quot;:23,&quot;ADDRESS&quot;:&quot;Norway&quot;,&quot;SALARY&quot;:20000.0},{&quot;ID&quot;:4,&quot;NAME&quot;:&quot;Mark&quot;,&quot;AGE&quot;:25,&quot;ADDRESS&quot;:&quot;Rich-Mond &quot;,&quot;SALARY&quot;:65000.0},{&quot;ID&quot;:5,&quot;NAME&quot;:&quot;David&quot;,&quot;AGE&quot;:27,&quot;ADDRESS&quot;:&quot;Texas&quot;,&quot;SALARY&quot;:85000.0},{&quot;ID&quot;:6,&quot;NAME&quot;:&quot;Kim&quot;,&quot;AGE&quot;:22,&quot;ADDRESS&quot;:&quot;South-Hall&quot;,&quot;SALARY&quot;:45000.0}] 四、运算符SQLite 提供了多种运算符，用于数据操作、筛选和计算。主要运算符分为以下几类： 算术运算符 比较运算符 逻辑运算符 位运算符 4.1 算术运算符SQLite 支持常见的「算术运算符」，用于在查询语句中进行数学运算。这些运算符可以在 SELECT 语句中计算列值，也可以用于更新操作。常见的算术运算符包括 加、减、乘、除 和 取模。 算数运算符 描述 示例 实例 + 加法 10 + 5 15 - 减法 10 - 5 5 * 乘法 10 * 5 50 / 除法 10 / 5 2.0 % 取模（求余数） 10 % 3 1 例如：我们对前面的 COMPANY 表进行「算数运算符」的操作： 12345678910sqlite&gt; .mode columnsqlite&gt; select * from company;ID NAME AGE ADDRESS SALARY-- ----- --- ---------- -------1 Paul 32 California 20000.02 Allen 25 Texas 15000.03 Teddy 23 Norway 20000.04 Mark 25 Rich-Mond 65000.05 David 27 Texas 85000.06 Kim 22 South-Hall 45000.0 加法（+） 12345678910# 给每个员工的薪资增加 5000sqlite&gt; SELECT name, salary, salary + 5000 AS new_salary FROM company;NAME SALARY new_salary----- ------- ----------Paul 20000.0 25000.0Allen 15000.0 20000.0Teddy 20000.0 25000.0Mark 65000.0 70000.0David 85000.0 90000.0Kim 45000.0 50000.0 减法（-） 12345678910# 给每个员工的薪资减少 2000sqlite&gt; SELECT name, salary, salary - 2000 AS reduced_salary FROM company;NAME SALARY reduced_salary----- ------- --------------Paul 20000.0 18000.0Allen 15000.0 13000.0Teddy 20000.0 18000.0Mark 65000.0 63000.0David 85000.0 83000.0Kim 45000.0 43000.0 乘法（*） 12345678910# 给每个员工的薪资翻倍sqlite&gt; SELECT name, salary, salary * 2 AS doubled_salary FROM company;NAME SALARY doubled_salary----- ------- --------------Paul 20000.0 40000.0Allen 15000.0 30000.0Teddy 20000.0 40000.0Mark 65000.0 130000.0David 85000.0 170000.0Kim 45000.0 90000.0 除法（/） 12345678910# 将员工的年薪除以 12，计算月薪sqlite&gt; SELECT name, salary / 12 AS monthly_salary FROM company;NAME monthly_salary----- ----------------Paul 1666.66666666667Allen 1250.0Teddy 1666.66666666667Mark 5416.66666666667David 7083.33333333333Kim 3750.0 取模（%） 12345678910# 计算每个员工年龄除以 2 的余数，判断是否为偶数年龄（余数为 0）sqlite&gt; SELECT id, name, age % 2 AS age_mod FROM company;ID NAME age_mod-- ----- -------1 Paul 02 Allen 13 Teddy 14 Mark 15 David 16 Kim 0 结合 WHERE 条件使用 123456# 查询月薪大于 5000 的员工sqlite&gt; SELECT * FROM company WHERE salary / 12 &gt; 5000;ID NAME AGE ADDRESS SALARY-- ----- --- ---------- -------4 Mark 25 Rich-Mond 65000.05 David 27 Texas 85000.0 4.2 比较运算符用于比较两个值，返回 TRUE 或 FALSE。 比较运算符 描述 示例 实例 = 等于 age = 25 TRUE/FALSE != 不等于（SQLite 也支持 &lt;&gt;） age != 30 TRUE/FALSE &lt; 小于 age &lt; 25 TRUE/FALSE &gt; 大于 age &gt; 20 TRUE/FALSE &lt;= 小于等于 age &lt;= 25 TRUE/FALSE &gt;= 大于等于 age &gt;= 20 TRUE/FALSE 例如：我们对前面的 COMPANY 表进行「比较运算符」的操作： 12345678910sqlite&gt; .mode columnsqlite&gt; select * from company;ID NAME AGE ADDRESS SALARY-- ----- --- ---------- -------1 Paul 32 California 20000.02 Allen 25 Texas 15000.03 Teddy 23 Norway 20000.04 Mark 25 Rich-Mond 65000.05 David 27 Texas 85000.06 Kim 22 South-Hall 45000.0 列出 SALARY 大于 50,000.00 的所有记录 12345sqlite&gt; SELECT * FROM COMPANY WHERE SALARY &gt; 50000;ID NAME AGE ADDRESS SALARY-- ----- --- ---------- -------4 Mark 25 Rich-Mond 65000.05 David 27 Texas 85000.0 列出 SALARY 等于 20,000.00 的所有记录 12345sqlite&gt; SELECT * FROM COMPANY WHERE SALARY = 20000;ID NAME AGE ADDRESS SALARY-- ----- --- ---------- -------1 Paul 32 California 20000.03 Teddy 23 Norway 20000.0 列出 SALARY 不等于 20,000.00 的所有记录 123456789101112131415sqlite&gt; SELECT * FROM COMPANY WHERE SALARY != 20000;ID NAME AGE ADDRESS SALARY-- ----- --- ---------- -------2 Allen 25 Texas 15000.04 Mark 25 Rich-Mond 65000.05 David 27 Texas 85000.06 Kim 22 South-Hall 45000.0sqlite&gt; SELECT * FROM COMPANY WHERE SALARY &lt;&gt; 20000;ID NAME AGE ADDRESS SALARY-- ----- --- ---------- -------2 Allen 25 Texas 15000.04 Mark 25 Rich-Mond 65000.05 David 27 Texas 85000.06 Kim 22 South-Hall 45000.0 列出 SALARY 大于等于 65,000.00 的所有记录 12345sqlite&gt; SELECT * FROM COMPANY WHERE SALARY &gt;= 65000;ID NAME AGE ADDRESS SALARY-- ----- --- ---------- -------4 Mark 25 Rich-Mond 65000.05 David 27 Texas 85000.0 4.3 逻辑运算符用于连接多个条件表达式，返回布尔值。 逻辑运算符 描述 示例 实例 AND 逻辑与 age &gt; 20 AND salary &lt; 50000 TRUE/FALSE OR 逻辑或 age &lt; 25 OR salary &gt; 60000 TRUE/FALSE NOT 逻辑非 NOT age = 25 TRUE/FALSE IS NULL 判断是否为 NULL address IS NULL TRUE/FALSE IS NOT NULL 判断是否不为 NULL address IS NOT NULL TRUE/FALSE LIKE 模糊匹配 name LIKE ‘J%’ TRUE/FALSE GLOB 全局匹配（区分大小写） name GLOB ‘J*’ TRUE/FALSE IN 判断是否在列表内 age IN (22, 30) TRUE/FALSE BETWEEN 判断是否在范围内 age BETWEEN 20 AND 30 TRUE/FALSE 例如：我们对前面的 COMPANY 表进行「逻辑运算符」的操作： 12345678910sqlite&gt; .mode columnsqlite&gt; select * from company;ID NAME AGE ADDRESS SALARY-- ----- --- ---------- -------1 Paul 32 California 20000.02 Allen 25 Texas 15000.03 Teddy 23 Norway 20000.04 Mark 25 Rich-Mond 65000.05 David 27 Texas 85000.06 Kim 22 South-Hall 45000.0 列出 AGE 大于等于 25 且工资大于等于 65000.00 的所有记录 12345sqlite&gt; SELECT * FROM COMPANY WHERE AGE &gt;= 25 AND SALARY &gt;= 65000;ID NAME AGE ADDRESS SALARY-- ----- --- ---------- -------4 Mark 25 Rich-Mond 65000.05 David 27 Texas 85000.0 列出 AGE 大于等于 25 或工资大于等于 65000.00 的所有记录 1234567sqlite&gt; SELECT * FROM COMPANY WHERE AGE &gt;= 25 OR SALARY &gt;= 65000;ID NAME AGE ADDRESS SALARY-- ----- --- ---------- -------1 Paul 32 California 20000.02 Allen 25 Texas 15000.04 Mark 25 Rich-Mond 65000.05 David 27 Texas 85000.0 列出 AGE 不为 NULL 的所有记录，结果显示所有的记录，意味着没有一个记录的 AGE 等于 NULL 123456789sqlite&gt; SELECT * FROM COMPANY WHERE AGE IS NOT NULL;ID NAME AGE ADDRESS SALARY-- ----- --- ---------- -------1 Paul 32 California 20000.02 Allen 25 Texas 15000.03 Teddy 23 Norway 20000.04 Mark 25 Rich-Mond 65000.05 David 27 Texas 85000.06 Kim 22 South-Hall 45000.0 列出 NAME 以 ‘Ki’ 开始的所有记录，’Ki’ 之后的字符不做限制 123456789sqlite&gt; SELECT * FROM COMPANY WHERE NAME LIKE 'Ki%';ID NAME AGE ADDRESS SALARY-- ---- --- ---------- -------6 Kim 22 South-Hall 45000.0sqlite&gt; SELECT * FROM COMPANY WHERE NAME GLOB 'Ki*';ID NAME AGE ADDRESS SALARY-- ---- --- ---------- -------6 Kim 22 South-Hall 45000.0 列出 AGE 的值为 23 或 27 的所有记录 12345sqlite&gt; SELECT * FROM COMPANY WHERE AGE IN ( 23, 27 );ID NAME AGE ADDRESS SALARY-- ----- --- ------- -------3 Teddy 23 Norway 20000.05 David 27 Texas 85000.0 列出 AGE 的值在 23 与 27 之间的所有记录 1234567sqlite&gt; SELECT * FROM COMPANY WHERE AGE BETWEEN 23 AND 27;ID NAME AGE ADDRESS SALARY-- ----- --- ---------- -------2 Allen 25 Texas 15000.03 Teddy 23 Norway 20000.04 Mark 25 Rich-Mond 65000.05 David 27 Texas 85000.0 4.4 位运算符用于对整数执行位操作。 位运算符 描述 示例 实例 &amp; 按位与如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中 60 &amp; 13 12 | 按位或如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中 60 | 13 61 ~ 按位取反二进制补码运算符是一元运算符，具有”翻转”位效应，即 0 变成 1，1 变成 0 ~60 -61 &lt;&lt; 二进制左移运算符左操作数的值向左移动右操作数指定的位数 60 &lt;&lt; 2 240 &lt;&lt; 二进制右移运算符左操作数的值向右移动右操作数指定的位数 60 &gt;&gt; 2 15 假设如果 A = 60，且 B = 13，现在以二进制格式，它们如下所示： 123456789101112A = 0011 1100B = 0000 1101-----------------A &amp; B = 0000 1100A | B = 0011 1101~ A = 1100 0011-----------------A &lt;&lt; 20011 1100 --&gt; 左移两位 --&gt; 1111 0000 -&gt; 240-----------------A &gt;&gt; 20011 1100 --&gt; 右移两位 --&gt; 0000 1111 -&gt; 15","link":"/2024/04/01/%E6%95%B0%E6%8D%AE%E5%BA%93%20--%20SQLite%20--%20%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"title":"讲的不能再细的 AnimationSpec 动画规范","text":"Source Code based on: androidx.compose.**:**:1.5.0 千呼万唤始出来！前面我们讲解【 animate*AsState 】和【 Animatable 】两种动画 API 的用法时，都提到了它们的函数内部有一个共同的核心参数：AnimationSpec。 1234567@Composablefun animateDpAsState( targetValue: Dp, animationSpec: AnimationSpec&lt;Dp&gt; = dpDefaultSpring, // AnimationSpec label: String = &quot;DpAnimation&quot;, finishedListener: ((Dp) -&gt; Unit)? = null) 12345678910111213class Animatable&lt;T, V : AnimationVector&gt;( initialValue: T, val typeConverter: TwoWayConverter&lt;T, V&gt;, private val visibilityThreshold: T? = null, val label: String = &quot;Animatable&quot;) { suspend fun animateTo( targetValue: T, animationSpec: AnimationSpec&lt;T&gt; = defaultSpringSpec, // AnimationSpec initialVelocity: T = velocity, block: (Animatable&lt;T, V&gt;.() -&gt; Unit)? = null )} 这篇文章我们就开始详细介绍每一个 AnimationSpec 的用法及其原理。 动画规范图标首先看下 AnimationSpec 动画规范的图表，这里你先有个直观感受，等看完这篇文章再回来看这个图表就会一目了然。 之前我们看到过很多次 AnimationSpec 的定义了：它可以让你通过可选的 AnimationSpec 参数来自定义动画规范，从而实现不同类型的动画效果。 AnimationSpec 是一个接口，它有很多子接口和实现类： 这些 **Spec 就可以帮助我们实现各种动画效果。 虽然 AnimationSpec 有好几个子接口，但我们主要关注 FiniteAnimationSpec 这个接口的实现类即可。 AnimationSpec 实现类 说明 DurationBasedAnimationSpec(基于时长的动画) KeyframesSpec 关键帧动画 DurationBasedAnimationSpec(基于时长的动画) SnapSpec 即使生效动画 DurationBasedAnimationSpec(基于时长的动画) TweenSpec 补间动画 - RepeatableSpec 重复动画 - SpringSpec 弹簧动画 - InfiniteRepeatableSpec 无限重复动画 现在我们再回顾一下 animateDpAsState 和 Animatable.animateTo 的 animationSpec 参数： 12345animateDpAsState： -&gt; animationSpec: AnimationSpec&lt;Dp&gt; = dpDefaultSpringAnimatable.animateTo： -&gt; animationSpec: AnimationSpec&lt;T&gt; = defaultSpringSpec 它们默认都是一个 SpringSpec 的弹簧效果，而且默认是不回弹。 12345678@Immutableclass SpringSpec&lt;T&gt;( val dampingRatio: Float = Spring.DampingRatioNoBouncy, val stiffness: Float = Spring.StiffnessMedium, val visibilityThreshold: T? = null)const val DampingRatioNoBouncy = 1f // 无回弹效果 现在你应该大致了解 AnimationSpec 的用途了，接下来我们就开始挨个研究 AnimationSpec 实现类的具体动画效果。 TweenSpec TweenSpec 应该算是最简单的 Spec 了，它在指定的 durationMillis 内使用「缓和曲线」在「起始值」和「结束值」之间添加动画效果。 我们看一下它的构造函数： 123456@Immutableclass TweenSpec&lt;T&gt;( val durationMillis: Int = DefaultDurationMillis, val delay: Int = 0, val easing: Easing = FastOutSlowInEasing) : DurationBasedAnimationSpec&lt;T&gt; { } 它有三个参数： durationMillis： 动画时长，不填的话默认 300ms delay：动画启动延时，默认不延时 easing：Easing 类型，设置动画曲线，默认是 FastOutSlowInEasing 效果 除了 FastOutSlowInEasing，Compose 还提供了三个默认的动画曲线： 12345678// 默认曲线：先加速再减速val FastOutSlowInEasing: Easing = CubicBezierEasing(0.4f, 0.0f, 0.2f, 1.0f)// 全程减速val LinearOutSlowInEasing: Easing = CubicBezierEasing(0.0f, 0.0f, 0.2f, 1.0f)// 全程加速val FastOutLinearInEasing: Easing = CubicBezierEasing(0.4f, 0.0f, 1.0f, 1.0f)// 线性曲线：匀速运动val LinearEasing: Easing = Easing { fraction -&gt; fraction } 我们基于小刺猬骑车的案例测试下这几个动画曲线的效果（为了效果显示更好，我们改变下动画时长）： LinearEasing：匀速运动 123456789101112131415161718192021222324252627282930313233343536class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var bicycleStart by mutableStateOf(false) setContent { val offset = remember(bicycleStart) { if (bicycleStart) 335.dp else 0.dp } val anim = remember { Animatable(offset, Dp.VectorConverter) } LaunchedEffect(bicycleStart) { anim.animateTo( offset, TweenSpec(durationMillis = 2000, easing = LinearEasing) // 2s, 匀速运动 ) } Column{ Image( painter = painterResource(R.drawable.bicycle), contentDescription = null, modifier = Modifier .absoluteOffset(x = anim.value) ) Button( onClick = { bicycleStart = !bicycleStart }, modifier = Modifier .fillMaxWidth() .wrapContentSize(align = Alignment.Center) ) { Text(text = &quot;Ride&quot;) } } } }} FastOutSlowInEasing：先加速再减速（这是默认曲线，我们可以不填） 123456789101112131415161718192021222324252627282930313233343536class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var bicycleStart by mutableStateOf(false) setContent { val offset = remember(bicycleStart) { if (bicycleStart) 335.dp else 0.dp } val anim = remember { Animatable(offset, Dp.VectorConverter) } LaunchedEffect(bicycleStart) { anim.animateTo( offset, TweenSpec(durationMillis = 2000) // 2s，默认曲线，先加速后减速 ) } Column{ Image( painter = painterResource(R.drawable.bicycle), contentDescription = null, modifier = Modifier .absoluteOffset(x = anim.value) ) Button( onClick = { bicycleStart = !bicycleStart }, modifier = Modifier .fillMaxWidth() .wrapContentSize(align = Alignment.Center) ) { Text(text = &quot;Ride&quot;) } } } }} LinearOutSlowInEasing：全程减速 123456789101112131415161718192021222324252627282930313233343536class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var bicycleStart by mutableStateOf(false) setContent { val offset = remember(bicycleStart) { if (bicycleStart) 335.dp else 0.dp } val anim = remember { Animatable(offset, Dp.VectorConverter) } LaunchedEffect(bicycleStart) { anim.animateTo( offset, TweenSpec(durationMillis = 2000, easing = LinearOutSlowInEasing) // 2s, 全程减速 ) } Column{ Image( painter = painterResource(R.drawable.bicycle), contentDescription = null, modifier = Modifier .absoluteOffset(x = anim.value) ) Button( onClick = { bicycleStart = !bicycleStart }, modifier = Modifier .fillMaxWidth() .wrapContentSize(align = Alignment.Center) ) { Text(text = &quot;Ride&quot;) } } } }} FastOutLinearInEasing：全程加速 123456789101112131415161718192021222324252627282930313233343536class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var bicycleStart by mutableStateOf(false) setContent { val offset = remember(bicycleStart) { if (bicycleStart) 335.dp else 0.dp } val anim = remember { Animatable(offset, Dp.VectorConverter) } LaunchedEffect(bicycleStart) { anim.animateTo( offset, TweenSpec(durationMillis = 2000, easing = FastOutLinearInEasing) // 2s, 全程加速 ) } Column{ Image( painter = painterResource(R.drawable.bicycle), contentDescription = null, modifier = Modifier .absoluteOffset(x = anim.value) ) Button( onClick = { bicycleStart = !bicycleStart }, modifier = Modifier .fillMaxWidth() .wrapContentSize(align = Alignment.Center) ) { Text(text = &quot;Ride&quot;) } } } }} 现在我们把四种动画曲线合并在一起看下效果： 但是！但有点 low 啊！在实际开发中，我们需要的动画曲线效果未必就是这四种，通常 UX 设计师会提供给我们一些设计好的动画曲线。比如：（0.0，0.0，0.1，1.0），（0.2，0.1，0.0，1.0），我们应该怎么实现这些动画曲线？这些坐标点又是什么？ 现在我们再来看一下之前的动画曲线： 123val FastOutSlowInEasing: Easing = CubicBezierEasing(0.4f, 0.0f, 0.2f, 1.0f)val LinearOutSlowInEasing: Easing = CubicBezierEasing(0.0f, 0.0f, 0.2f, 1.0f)val FastOutLinearInEasing: Easing = CubicBezierEasing(0.4f, 0.0f, 1.0f, 1.0f) 他们都用一个 CubicBezierEasing 包起来了，它有四个参数，这四个参数是用来定义一个「三阶贝塞尔曲线」的。 三阶贝塞尔曲线 有四个点，其中有两个点是固定的，分别是：(0, 0) 和 (1, 1)，我们只需要给出另外两个点即可定义出三阶贝塞尔曲线。 所以无论是 Compose 提供的动画曲线，还是 UX 设计师提供的动画曲线，它们的四个数值就对应着我们需要的另外两个点！ 不懂的话，给你一个网站： 这是一个可以看到「三阶贝塞尔曲线」定制效果的工具网站，其中两个白点就是固定的 (0, 0) 和 (1, 1)，而「红色」和「绿色」两个点就对应我们动画曲线的四个参数，即 2 个坐标。 你可以随意拖动红点和蓝点，上方的坐标参数会同步更新，所以 UX 设计师提供给我们的坐标点，就可以在这个网站测试动画效果。 现在我们分别测试下 Compose 提供的几个动画曲线的效果： 12// 先加速后减速val FastOutSlowInEasing: Easing = CubicBezierEasing(0.4f, 0.0f, 0.2f, 1.0f) 12// 全程减速val LinearOutSlowInEasing: Easing = CubicBezierEasing(0.0f, 0.0f, 0.2f, 1.0f) 12// 全程加速val FastOutLinearInEasing: Easing = CubicBezierEasing(0.4f, 0.0f, 1.0f, 1.0f) TweenSpec 的用法和核心知识点也就这么多了，它的核心也就是 动画曲线 Easing，要么就用 Compose 提供给我们的动画曲线，要么你自己自定义：CubicBezierEasing(*, *, *, *)。 最后讲个小技巧，Compose 提供了一个 tween 函数简化写法，等同于 TweenSpec，它内部就是创建了 TweenSpec。 123456@Stablefun &lt;T&gt; tween( durationMillis: Int = DefaultDurationMillis, delayMillis: Int = 0, easing: Easing = FastOutSlowInEasing): TweenSpec&lt;T&gt; = TweenSpec(durationMillis, delayMillis, easing) 所以以下写法随便你写哪个： 12anim.animateTo(size, TweenSpec(easing = FastOutLinearInEasing))anim.animateTo(size, tween(easing = FastOutLinearInEasing)) SnapSpecsnap 是一个特殊的 AnimationSpec，它会立即将值切换到结束值。 我不知道你还有没有印象，在前面讲解 Animatable 的时候，我们提到过它有一个 snapTo 的函数，它可以指定目标值突变到某一个值，而 SnapSpec 其实跟它是差不多的意思，就是让动画效果突变，瞬间完成。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var bicycleStart by mutableStateOf(false) setContent { val offset = remember(bicycleStart) { if (bicycleStart) 335.dp else 0.dp } val anim = remember { Animatable(offset, Dp.VectorConverter) } LaunchedEffect(bicycleStart) { anim.animateTo(offset, SnapSpec()) } val anim2 = remember { Animatable(offset, Dp.VectorConverter) } LaunchedEffect(bicycleStart) { anim2.animateTo(offset, TweenSpec(durationMillis = 2000)) } Column{ Text(text = &quot;TweenSpec 默认：先加速再减速&quot;, fontSize = 16.sp) Image( painter = painterResource(R.drawable.bicycle), contentDescription = null, modifier = Modifier .absoluteOffset(x = anim2.value) ) Text(&quot;SnapSpec&quot;, fontSize = 16.sp, modifier = Modifier.padding(top = 25.dp)) Image( painter = painterResource(R.drawable.bicycle), contentDescription = null, modifier = Modifier .absoluteOffset(x = anim.value) ) Button( onClick = { bicycleStart = !bicycleStart }, modifier = Modifier .fillMaxWidth() .wrapContentSize(align = Alignment.Center) ) { Text(text = &quot;Ride&quot;) } } } }} 上面代码中我们同时写了 TweenSpec 和 SnapSpec 两个动画，看下对比效果： 效果很明显吧？SnapSpec 就跟 “瞬间移动” 差不多，它是一种 即时生效、即时完成 的动画效果。 另外，SnapSpec() 有个 delay 参数，用来延迟动画播放的开始时间。 1class SnapSpec&lt;T&gt;(val delay: Int = 0) : DurationBasedAnimationSpec&lt;T&gt; 比如我们添加一个 2s 的延时： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var bicycleStart by mutableStateOf(false) setContent { val offset = remember(bicycleStart) { if (bicycleStart) 335.dp else 0.dp } val anim = remember { Animatable(offset, Dp.VectorConverter) } LaunchedEffect(bicycleStart) { anim.animateTo(offset, SnapSpec(delay = 2000)) } val anim2 = remember { Animatable(offset, Dp.VectorConverter) } LaunchedEffect(bicycleStart) { anim2.animateTo(offset, TweenSpec(durationMillis = 2300)) } Column{ Text(text = &quot;TweenSpec 默认：先加速再减速&quot;, fontSize = 16.sp) Image( painter = painterResource(R.drawable.bicycle), contentDescription = null, modifier = Modifier .absoluteOffset(x = anim2.value) ) Text(&quot;SnapSpec&quot;, fontSize = 16.sp, modifier = Modifier.padding(top = 25.dp)) Image( painter = painterResource(R.drawable.bicycle), contentDescription = null, modifier = Modifier .absoluteOffset(x = anim.value) ) Button( onClick = { bicycleStart = !bicycleStart }, modifier = Modifier .fillMaxWidth() .wrapContentSize(align = Alignment.Center) ) { Text(text = &quot;Ride&quot;) } } } }} 跟 tween 一样，Compose 也提供了 SnapSpec 的简化写法：snap。 12anim.animateTo(size, SnapSpec())anim.animateTo(size, snap()) KeyframesSpecKeyframesSpce 就是「关键帧」的意思，可以让我们在动画过程中选取几个关键的时间点，并给出这些时间点对应的动画完成度，相当于分段式的 TweenSpec。 在讲解 KeyframesSpce 的使用方法之前，有个细节点需要说一下：如果我们用它的构造函数来创建的话会比较麻烦，需要像下面这样写： 123anim.animateTo(size, KeyframesSpec&lt;Dp&gt;(KeyframesSpec.KeyframesSpecConfig()).apply { }) 很长很啰嗦，Compose 同样提供了简便的 keyframes 来创建 KeyframesSpec： 123456@Stablefun &lt;T&gt; keyframes( init: KeyframesSpec.KeyframesSpecConfig&lt;T&gt;.() -&gt; Unit): KeyframesSpec&lt;T&gt; { return KeyframesSpec(KeyframesSpec.KeyframesSpecConfig&lt;T&gt;().apply(init))} 所以，我们通常会这么写： 1anim.animateTo(size, keyframes { }) 现在可以写内部代码了： 123456789101112131415161718192021222324252627282930313233343536class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var bicycleStart by mutableStateOf(false) setContent { val offset = remember(bicycleStart) { if (bicycleStart) 335.dp else 0.dp } val anim = remember { Animatable(offset, Dp.VectorConverter) } LaunchedEffect(bicycleStart) { anim.animateTo(offset, keyframes { durationMillis = 2000 100.dp at 1000 }) } Column{ Image( painter = painterResource(R.drawable.bicycle), contentDescription = null, modifier = Modifier .absoluteOffset(x = anim.value) ) Button( onClick = { bicycleStart = !bicycleStart }, modifier = Modifier .fillMaxWidth() .wrapContentSize(align = Alignment.Center) ) { Text(text = &quot;Ride&quot;) } } } }} 为了体现更好的 keyframes 动画效果，我们对动画指定了 2000ms 时长，然后加了一行 100.dp at 1000，含义就是：1000ms 内移动到 100dp，剩下的 1000ms 走完最后的路程。 看下动画，是不是这么回事？ 所以你其实可以很明显的发现：KeyframesSpec 通过添加关键帧，就是把动画进行了拆分，就像它的定义，它相当于分段式的 TweenSpec。 现在我们再来加一个关键帧测试一下： 12345678910111213141516171819202122232425262728293031323334353637class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var bicycleStart by mutableStateOf(false) setContent { val offset = remember(bicycleStart) { if (bicycleStart) 335.dp else 0.dp } val anim = remember { Animatable(offset, Dp.VectorConverter) } LaunchedEffect(bicycleStart) { anim.animateTo(offset, keyframes { durationMillis = 2000 100.dp at 1000 50.dp at 1500 }) } Column{ Image( painter = painterResource(R.drawable.bicycle), contentDescription = null, modifier = Modifier .absoluteOffset(x = anim.value) ) Button( onClick = { bicycleStart = !bicycleStart }, modifier = Modifier .fillMaxWidth() .wrapContentSize(align = Alignment.Center) ) { Text(text = &quot;Ride&quot;) } } } }} 想想下是不是下面的效果：（比如前进过程） 0 - 1000ms：0.dp -&gt; 100.dp 1000ms - 1500ms：100.dp -&gt; 50.dp 1500ms -2000ms：50.dp -&gt; 走完路程 另外 KeyframesSpec 也同样可以设置延迟： 12345678LaunchedEffect(bicycleStart) { anim.animateTo(offset, keyframes { durationMillis = 2000 delayMillis = 1000 100.dp at 1000 50.dp at 1500 })} 讲到这里，你应该已经掌握了 KeyframesSpec 的用法了。它跟 TweenSpec 基本上一样，但是我们在讲 TweenSpec 的时候，有一个重点知识：动画曲线 - - 不同动画曲线速度是不一样的。 那 KeyframesSpec 能设置动画曲线吗？？？ 也是可以的，比如： 12345678LaunchedEffect(bicycleStart) { anim.animateTo(offset, keyframes { durationMillis = 2000 delayMillis = 1000 100.dp at 1000 with FastOutSlowInEasing 50.dp at 1500 })} 不过，KeyframesSpace 是分段动画，可以给每段动画单独指定一个动画曲线，但是问题就来了： FastOutSlowInEasing 这个先加速后减速的动画曲线到底是 1000ms 之前的动画还是 1000ms 之后的动画？ 答案是：之后的动画，也就是 1000ms - 2000ms 之间的动画。 但是 1000ms 之前想设置动画曲线怎么办？ 123456789LaunchedEffect(bicycleStart) { anim.animateTo(offset, keyframes { durationMillis = 2000 delayMillis = 1000 0.dp at 0 with FastOutLinearInEasing 100.dp at 1000 with FastOutSlowInEasing 50.dp at 1500 })} 就这么简单，再加一个动画从 0ms 开始的动画曲线即可，不过需要注意的是：这个 0.dp 只是一个示例，因为如果是从右往左骑车的话，就应该写成 360.dp，所以根据实际情况，你要写对动画的初始值。 SpringSpec还记得我们刚开始讲动画的时候提到过 animateTo 有一个默认的动画效果吗？ 123456789suspend fun animateTo( targetValue: T, animationSpec: AnimationSpec&lt;T&gt; = defaultSpringSpec, initialVelocity: T = velocity, block: (Animatable&lt;T, V&gt;.() -&gt; Unit)? = null)internal val defaultSpringSpec: SpringSpec&lt;T&gt; = SpringSpec(visibilityThreshold = visibilityThreshold) SpringSpec 就是默认的动画：用来实现弹簧效果的！ 如果你要为组件指定一个弹簧效果，代码写起来也很简单： 123456789101112131415161718192021222324252627282930313233class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var bicycleStart by mutableStateOf(false) setContent { val offset = remember(bicycleStart) { if (bicycleStart) 335.dp else 0.dp } val anim = remember { Animatable(offset, Dp.VectorConverter) } LaunchedEffect(bicycleStart) { anim.animateTo(offset, spring()) // 弹簧效果 } Column{ Image( painter = painterResource(R.drawable.bicycle), contentDescription = null, modifier = Modifier .absoluteOffset(x = anim.value) ) Button( onClick = { bicycleStart = !bicycleStart }, modifier = Modifier .fillMaxWidth() .wrapContentSize(align = Alignment.Center) ) { Text(text = &quot;Ride&quot;) } } } }} 如代码里面写的：Compose 也提供了一个 spring() 快捷方法用于创建 SpringSpec。就这样，啥也不用填就可以自定义一个弹簧动画了。 如果要定制更复杂一点的弹簧动画呢？我们来看看 SpringSpec 构造函数有哪些参数： 123456@Immutableclass SpringSpec&lt;T&gt;( val dampingRatio: Float = Spring.DampingRatioNoBouncy, val stiffness: Float = Spring.StiffnessMedium, val visibilityThreshold: T? = null) : FiniteAnimationSpec&lt;T&gt; { } dampingRatio：阻尼比 就是弹簧弹的过程中会受到多大的阻力，默认值是：DampingRatioNoBouncy = 1f，没有任何弹簧效果。 dampingRatio = DampingRatioNoBouncy 1anim.animateTo(offset, spring()) dampingRatio = 0.2f 1anim.animateTo(offset, spring(dampingRatio = 0.2f)) dampingRatio = 10f 1anim.animateTo(offset, spring(dampingRatio = 10f)) 我们把三个「阻尼比」放一起看下效果： stiffness： 刚度 弹簧有多硬，越硬回弹越猛，默认值是：StiffnessMedium = 1500f。 DampingRatioNoBouncy = 0.1f， StiffnessMedium = 1500f 1anim.animateTo(offset, spring(dampingRatio = 0.1f, stiffness = 1500f)) DampingRatioNoBouncy = 0.1f， StiffnessHigh = 10_000f 1anim.animateTo(offset, spring(dampingRatio = 0.1f, stiffness = 10_000f)) DampingRatioNoBouncy = 0.1f， StiffnessMediumLow = 400f 1anim.animateTo(offset, spring(dampingRatio = 0.1f, stiffness = 400f)) 我们把三个「刚度」放一起看下效果： visibilityThreshold： 可视阈值 如果你把 DampingRatioNoBouncy 设置的特别特别小，它会一直弹，那么我们就可以通过设置 visibilityThreshold 阈值，让弹窗到达这个阈值后直接停止。 1anim.animateTo(offset, spring(dampingRatio = 0.05f, stiffness = 1500f, 50.dp)) 至此，SpringSpec 弹窗动画效果也讲完了。 RepeatableSpecRepeatableSpec 主要用于反复运行基于时长的动画（例如 tween 或 keyframes），直至达到指定的迭代计数。 看下它的构造函数你就懂了： 12345678@Stablefun &lt;T&gt; repeatable( iterations: Int, animation: DurationBasedAnimationSpec&lt;T&gt;, repeatMode: RepeatMode = RepeatMode.Restart, initialStartOffset: StartOffset = StartOffset(0)): RepeatableSpec&lt;T&gt; = RepeatableSpec(iterations, animation, repeatMode, initialStartOffset) iterations：迭代次数 就是要重复的次数，填 1 就是不重复 1anim.animateTo(size, repeatable(3)) animation：动画 需要传入一个 DurationBasedAnimationSpec 类型的动画，哪些动画是 DurationBasedAnimationSpec 类型？ 1anim.animateTo(offset, repeatable(3, tween())) 这样就可以运行了： repeatMode：重复模式 指定是 “重启” 还是 “倒放” 1anim.animateTo(offset, repeatable(3, tween(), RepeatMode.Reverse)) // 倒放 注意： 如果你设置了 repeatMode 模式为 “倒放”，那么 iterations 迭代次数不能设置成双数，只能单数，比如： 1anim.animateTo(offset, repeatable(2, tween(durationMillis = 1500), RepeatMode.Reverse)) 很明显动画不对了，一次往返之后应该停下，但是唰的一下又过去了，原因其实很简单：因为我们设了目标值 360dp。 initialStartOffset：初始启动偏移（时间偏移） 默认值为0，即不偏移 1anim.animateTo(offset, repeatable(3, tween(), RepeatMode.Reverse, StartOffset(1000))) 不过 StartOffset 还有第二个参数，可以设置是 “延时型偏移” 还是 “快进型偏移”。 延迟型偏移：StartOffsetType.Delay 12anim.animateTo(offset, repeatable(3, tween(durationMillis = 2000), RepeatMode.Reverse, StartOffset(1000, StartOffsetType.Delay))) 快进型偏移：StartOffsetType.FastForward 12anim.animateTo(offset, repeatable(3, tween(durationMillis = 2000), RepeatMode.Reverse, StartOffset(1000, StartOffsetType.FastForward))) 我们看下快进型效果： 动画时长 2s，快进了 1s 启动，所以会从中间开始。至此，RepeatableSpec 也讲完了。 InfiniteRepeatableSpec InfiniteRepeatableSpec 与 RepeatableSpec 类似，唯一的区别就是：它会重复无限次的迭代。 我们看下它的构造函数： 12345class InfiniteRepeatableSpec&lt;T&gt;( val animation: DurationBasedAnimationSpec&lt;T&gt;, val repeatMode: RepeatMode = RepeatMode.Restart, val initialStartOffset: StartOffset = StartOffset(0)) 与 RepeatableSpec 唯一区别就是去除了 iterations 迭代次数，用法没有任何特殊的地方。 123LaunchedEffect(bicycleStart) { anim.animateTo(offset, infiniteRepeatable(tween(durationMillis = 2000), RepeatMode.Reverse))} 对于InfiniteRepeatableSpec 这种无限重复的动画，只要它所依赖的协程取消，动画即可停止。","link":"/2024/08/05/Compose%20--%20%E5%8A%A8%E7%94%BB%20--%2003.%20%E8%AE%B2%E7%9A%84%E4%B8%8D%E8%83%BD%E5%86%8D%E7%BB%86%E7%9A%84%20AnimationSpec%20%E5%8A%A8%E7%94%BB%E8%A7%84%E8%8C%83/"}],"tags":[{"name":"Launcher3","slug":"Launcher3","link":"/tags/Launcher3/"},{"name":"Android 14.0","slug":"Android-14-0","link":"/tags/Android-14-0/"},{"name":"Compose","slug":"Compose","link":"/tags/Compose/"},{"name":"Modifier","slug":"Modifier","link":"/tags/Modifier/"},{"name":"CombinedModifier","slug":"CombinedModifier","link":"/tags/CombinedModifier/"},{"name":"ComposedModifier","slug":"ComposedModifier","link":"/tags/ComposedModifier/"},{"name":"DrawModifier","slug":"DrawModifier","link":"/tags/DrawModifier/"},{"name":"LayoutModifier","slug":"LayoutModifier","link":"/tags/LayoutModifier/"},{"name":"PointerInputModifier","slug":"PointerInputModifier","link":"/tags/PointerInputModifier/"},{"name":"副作用","slug":"副作用","link":"/tags/%E5%89%AF%E4%BD%9C%E7%94%A8/"},{"name":"附带效应","slug":"附带效应","link":"/tags/%E9%99%84%E5%B8%A6%E6%95%88%E5%BA%94/"},{"name":"Compose 协程","slug":"Compose-协程","link":"/tags/Compose-%E5%8D%8F%E7%A8%8B/"},{"name":"Compose 动画","slug":"Compose-动画","link":"/tags/Compose-%E5%8A%A8%E7%94%BB/"},{"name":"animate*AsState()","slug":"animate-AsState","link":"/tags/animate-AsState/"},{"name":"Animatable()","slug":"Animatable","link":"/tags/Animatable/"},{"name":"Transition","slug":"Transition","link":"/tags/Transition/"},{"name":"AnimatedVisibility","slug":"AnimatedVisibility","link":"/tags/AnimatedVisibility/"},{"name":"Crossfade","slug":"Crossfade","link":"/tags/Crossfade/"},{"name":"AnimatedContent","slug":"AnimatedContent","link":"/tags/AnimatedContent/"},{"name":"animateContentSize","slug":"animateContentSize","link":"/tags/animateContentSize/"},{"name":"状态订阅 &amp; 自动更新","slug":"状态订阅-自动更新","link":"/tags/%E7%8A%B6%E6%80%81%E8%AE%A2%E9%98%85-%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0/"},{"name":"mutableStateOf","slug":"mutableStateOf","link":"/tags/mutableStateOf/"},{"name":"mutableStateListOf","slug":"mutableStateListOf","link":"/tags/mutableStateListOf/"},{"name":"重组","slug":"重组","link":"/tags/%E9%87%8D%E7%BB%84/"},{"name":"remember","slug":"remember","link":"/tags/remember/"},{"name":"重组作用域","slug":"重组作用域","link":"/tags/%E9%87%8D%E7%BB%84%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"name":"Compose 状态","slug":"Compose-状态","link":"/tags/Compose-%E7%8A%B6%E6%80%81/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SQLite","slug":"SQLite","link":"/tags/SQLite/"},{"name":"AnimationSpec","slug":"AnimationSpec","link":"/tags/AnimationSpec/"}],"categories":[{"name":"Launcher3","slug":"Launcher3","link":"/categories/Launcher3/"},{"name":"Android 14.0","slug":"Launcher3/Android-14-0","link":"/categories/Launcher3/Android-14-0/"},{"name":"Compose","slug":"Compose","link":"/categories/Compose/"},{"name":"动画","slug":"Compose/动画","link":"/categories/Compose/%E5%8A%A8%E7%94%BB/"},{"name":"Modifier","slug":"Compose/Modifier","link":"/categories/Compose/Modifier/"},{"name":"状态订阅 &amp; 自动更新","slug":"Compose/状态订阅-自动更新","link":"/categories/Compose/%E7%8A%B6%E6%80%81%E8%AE%A2%E9%98%85-%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0/"},{"name":"附带效应","slug":"Compose/附带效应","link":"/categories/Compose/%E9%99%84%E5%B8%A6%E6%95%88%E5%BA%94/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SQLite","slug":"数据库/SQLite","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/SQLite/"}],"pages":[]}