{"posts":[{"title":"Compose 是如何将数据转换成 UI 的？","text":"Compose 是一个声明式的 UI 框架，提供了很多开箱即用的组件，比如 Text()、Button、Image() 等等，Compose 会经过几个不同的阶段，最终渲染出 UI 界面。 此转换过程分为【三个阶段】： 组合： 显示什么 布局： 放在哪里 绘制： 如何渲染 这三个阶段是逐一执行的，流程如下： # 组合阶段在组合阶段，Compose 运行时会执行代码中定义的可组合函数，最终会生成一棵视图树。这个视图树由一个个布局节点：LayoutNode 组成。比如 Text()、Button() 都对应一个 LayoutNode，这些 LayoutNode 持有组件的所有信息。 更形象一点的结构如下： 这是一个非常简单的示例，但有时候我们定义的可组合项包含逻辑和控制流，而 Compose 会在不同状态的情况下生成不同的树。 # 布局阶段布局阶段，对于视图树中的每个 LayoutNode 节点进行宽高尺寸测量并完成位置摆放，布局元素都会根据 2D 坐标来测量并放置自己及其所有子元素。 其实 Compose 的布局阶段和传统的 View 系统很像（测量、布局、绘制），唯独多了一个「 组合阶段 」，而 Compose 把 测量和布局 统一放入了「 布局阶段 」。 在布局阶段，使用以下 3 步算法遍历 LayoutNode 树： 测量子节点： 每一个节点会测量它的子节点，如果有的话。 决定自己的大小： 基于这些测量，节点决定自己的大小。 放置子节点： 每个子节点都相对于节点自身的位置进行放置。 布局阶段结束后，每个 LayoutNode 都将分配一个 宽度 和 高度，以及一个应该绘制的 x、y 坐标。 比如：我们现在分析下面这个简单示例的布局流程。 布局流程： 看到这，是不是发现个很牛逼的事？ **我们只访问了每个节点一次。通过视图树的一次遍历，我们就可以测量和放置所有节点**。 这对性能来说就很重要了！当树中节点的数量增加时，遍历它所花费的时间只会以线性方式增加。相比之下，如果我们多次访问每个节点，遍历时间则会以呈指数级增加。 # 绘制阶段绘制阶段，树中的每个节点都在屏幕上绘制其像素。 上面我们说过，在布局阶段结束后，所有布局节点会得到它们的 宽度 和 高度，以及 x、y 坐标。所以现在就可以进入绘制阶段了。 绘制阶段会从上到下再次遍历树，每个节点依次在屏幕上绘制自己。 首先 Row 将绘制它可能具有的任何内容，例如背景色。然后 Image 将绘制自己，然后是 Column，然后是第一个和第二个 Text。 # Modifier 修饰符上面我们给的简单代码示例都只是用了一些 Compose 提供给我们的现场的组件，实际开发过程中，会有一个大神级别一样的修饰符随处可见，它就是：Modifier 修饰符。 比如：Modifier.padding 是用来给组件设置边距的，它本质上是一个 LayoutModifier，而 LayoutModifier 会影响组件的测量和布局效果，会影响到组合项的整体 UI 效果。具体如何影响，这篇文章我们不讲它的深层次原理，而只是探讨思维模型。 所以，如果你想了解 LayoutModifier 的原理，可以阅读 【 聊聊 Jetpack Compose 原理 – LayoutModifier 和 Modifier.layout 】 这篇文章。 回到正题，如果我们加了 Modifier 修饰符，那么在最终生成的视图树中，可以将 Modifier 修饰符可视化为布局节点的包装节点： 当我们链接多个修饰符时，每个修饰符节点包裹链的其余部分和其中的布局节点。 例如，当我们链接一个 clip 和一个 size 修饰符时，clip 修饰符节点包裹 size 修饰符节点，然后包裹 Image 布局节点。 这里你可能有疑问，为什么不是先 clip 然后 size，而是先 size 然后在 clip？看完 【 聊聊 Jetpack Compose 原理 – LayoutModifier 和 Modifier.layout 】 这篇文章你就懂了。 接着说，在布局阶段，我们用来遍历树的算法保持不变，但 每个修饰符节点也会被访问。这样，修饰符可以更改其包裹的 修饰符 或 布局节点 的 大小要求 和 位置。 如果我们看一下 Image 可组合项的实现（底层更细的实现），实际上可以看到它本身由包裹单个布局节点的修饰符链组成。类似地，Text 可组合项也是通过包含布局节点的修饰符链实现的。最后，Row 和 Column 的实现只是描述如何布置其子节点的布局节点： 看不懂这张图？没事，这些细节原理都会有文章输出，比如我刚刚提到了两次的原理文章。","link":"/2024/07/01/Compose%20--%20%E5%8E%9F%E7%90%86%20--%20Compose%20%E6%98%AF%E5%A6%82%E4%BD%95%E5%B0%86%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E6%88%90%20UI%20%E7%9A%84%EF%BC%9F/"},{"title":"mutableStateListOf","text":"Jekpack Compose “状态订阅&amp;自动刷新” 系列： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;【 聊聊 Jetpack Compose 的 “状态订阅&amp;自动刷新” - - MutableState/mutableStateOf 】 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;【 聊聊 Jetpack Compose 的 “状态订阅&amp;自动刷新” - - remember 和重组作用域 】 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;【 聊聊 Jetpack Compose 的 “状态订阅&amp;自动刷新” - - 有状态、无状态、状态提升？】 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;【 聊聊 Jetpack Compose 的 “状态订阅&amp;自动刷新” - - mutableStateListOf 】 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;【 聊聊 Jetpack Compose 的 “状态订阅&amp;自动刷新” - - 你真的了解重组吗？】 讲任何一个新的主题或者知识点，习惯性的从 Demo 开始，比如： 1234567891011class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var name by mutableStateOf(&quot;Hi, Compose&quot;) setContent { Text(name) } }} 这段代码已经熟的不能再熟了，如果我们用 by mutableStateOf 初始化一个变量，那 name 就会变成一个被 Compose 自动订阅的变量。 我们前面所有的例子，都是用 by mutableStateOf 包了一个 String，如果换成别的类型，行不行？肯定可以，不用想。 1234fun &lt;T&gt; mutableStateOf( value: T, // 泛型参数 policy: SnapshotMutationPolicy&lt;T&gt; = structuralEqualityPolicy()): MutableState&lt;T&gt; = createSnapshotMutableState(value, policy) 比如 Int 类型： 12345678910111213141516class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var num by mutableStateOf(1) setContent { Text( text = &quot;当前数值：$num&quot;, Modifier.clickable { num++ } ) } }} 代码不做解释了，直接看效果： 比如：List 类型 123// num 类型：MutableList&lt;Int&gt;// mutableStateOf 类型：MutableState&lt;MutableList&lt;Int&gt;&gt;var nums by mutableStateOf(mutableListOf(1, 2, 3)) 我们在代码里面用起来： 123456789101112131415class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var nums by mutableStateOf(mutableListOf(1, 2, 3)) setContent { Column { for (num in nums) { Text(&quot;第 $num 块文字&quot;) } } } }} 运行： ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/0713f5cb717b322775fb08a8d3da410e.png =500x) 现在我们稍微改下代码： 1234567891011121314151617181920class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var nums by mutableStateOf(mutableListOf(1, 2, 3)) setContent { Column { Button(onClick = { nums.add(nums.last() + 1) }) { Text(&quot;List 加 1&quot;) } for (num in nums) { Text(&quot;第 $num 块文字&quot;) } } } }} 代码很简单：我们添加了一个 Button，每次点击后，nums 会添加一个值，比最有一个值大 1。 运行： ？？？没生效啊！为什么？ 我们先来考虑一个问题，mutableStateOf 原理是什么？前面的问题我们说过，可以回忆一下： mutableStateOf 之所以可以对变量进行订阅和刷新，主要是因为内部的 get() 和 set() 方法加了钩子，或者说它的 set() 方法是赋值！是改变了变量的指向，它是直接把对象可替换了，但在我们这个代码里面 nums 仅仅是改变了它内部的状态： ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/19308a90fec705d39e101e5c1cca0ca4.png =700x) 对这块如果有点懵，可以看【 聊聊 Jetpack Compose 的 “状态订阅&amp;自动刷新” - - MutableState/mutableStateOf 】 这篇文章。 所以，它不会出发 setValue() 的调用，所以不会出发自动刷新的操作。 ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/59408ca695a96074444fc4cdf201e0be.png =700x) 为了验证是不是因为没有重组，我们可以验证下： 12345678910111213141516171819202122class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var nums by mutableStateOf(mutableListOf(1, 2, 3)) var refresh by mutableStateOf(&quot;强制刷新&quot;) setContent { Column { Text(refresh, Modifier.clickable { refresh = &quot;刷新完成&quot;}) Button(onClick = { nums.add(nums.last() + 1) }) { Text(&quot;List 加 1&quot;) } for (num in nums) { Text(&quot;第 $num 块文字&quot;) } } } }} 我们添加了一个 Text() 组件，改变 refresh 的值，那么理论上它就会带着整个重组作用域内的组件全部刷新，包括 List。 运行： 成功刷新 List！ 现在我们就很清楚了，mutableStateOf 没法对 List 类型的对象没法实现类似 String、Int 的自动订阅及刷新，那有没有解决办法？ 上面我们说过了，问题的根本原因是 List 只是内部的变化，而不是它自己本身对象的变化，那我们直接在内部操作完后直接把 List 重新给换了不就行了，试试： 1234567891011121314151617181920212223class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var nums by mutableStateOf(mutableListOf(1, 2, 3)) setContent { Column { Button(onClick = { // nums 重新赋值 nums = nums.toMutableList().apply { add(nums.last() + 1) } }) { Text(&quot;List 加 1&quot;) } for (num in nums) { Text(&quot;第 $num 块文字&quot;) } } } }} 运行： 但这样写就会显得很奇怪，我是明白原理了，我这样也是可以实现正常的刷新，但不太对劲：既然对于 String、Int 这些类型，Compose 提供了 mutableStateOf，难道对于 List 这种这么常用的类型，就没有一个 mutable*** 的函数给我们用？ 有，它就是 mutableStateListOf！它可以观测到内部 List 的数据变化！ 我们可以像下面这样申明： 12345678910var nums by mutableStateListOf(mutableListOf(1, 2, 3)) // 有红线标注，写法错误// mutableStateListOf 是内部元素被观测，而不是它本身被观测，所以我们要把 `by` 换成 `=`var nums = mutableStateListOf(mutableListOf(1, 2, 3))// `var` 也可以换成 `val`val nums = mutableStateListOf(mutableListOf(1, 2, 3))// mutableStateListOf 本身就代表一个可观测的 List，所以 mutableListOf 也可以去除val nums = mutableStateListOf(1, 2, 3) // 这就是最终的写法 这个时候我们就可以优化下代码了： 1234567891011121314151617181920class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val nums = mutableStateListOf(1, 2, 3) setContent { Column { Button(onClick = { nums.add(nums.last() + 1) }) { Text(&quot;List 加 1&quot;) } for (num in nums) { Text(&quot;第 $num 块文字&quot;) } } } }} 运行： 提到 List，我们就会想到 Map，同样 Map 也提供了一个 mutableStateMapOf！它也可以观测到内部 Map 的数据变化！ 12345678910111213141516171819class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val maps = mutableStateMapOf(1 to &quot;One&quot;, 2 to &quot;Two&quot;) setContent { Column { Button(onClick = { maps[3] = &quot;Three&quot; }) { Text(&quot;Maps 加 1&quot;) } for ((key, value) in maps) { Text(&quot;$key 对应 value: $value&quot;) } } } }} 运行：","link":"/2024/07/18/Compose%20--%20%E7%8A%B6%E6%80%81%E8%AE%A2%E9%98%85%20&%20%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%20--%20mutableStateListOf/"},{"title":"细说 remember 和重组作用域","text":"Jekpack Compose “状态订阅&amp;自动刷新” 系列： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;【 聊聊 Jetpack Compose 的 “状态订阅&amp;自动刷新” - - MutableState/mutableStateOf 】 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;【 聊聊 Jetpack Compose 的 “状态订阅&amp;自动刷新” - - remember 和重组作用域 】 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;【 聊聊 Jetpack Compose 的 “状态订阅&amp;自动刷新” - - 有状态、无状态、状态提升？】 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;【 聊聊 Jetpack Compose 的 “状态订阅&amp;自动刷新” - - mutableStateListOf 】 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;【 聊聊 Jetpack Compose 的 “状态订阅&amp;自动刷新” - - 你真的了解重组吗？】 在讲本篇文章主题之前，建议先看看 聊聊 Jetpack Compose 原理 – 状态订阅&amp;自动刷新机制 一文，因为两篇文章是上下篇的关系，看完上篇，可以更好的串联知识点。 话不多说，还是老样子，从 Demo 一步步引出我们的核心知识点。 一、话题引入12345678910111213141516class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var name by mutableStateOf(&quot;Compose&quot;) setContent { Text(name) LaunchedEffect(true) { delay(3000) name = &quot;Kotlin&quot; } } }} 一段很简单的代码示例，就是前一篇文章的开头示例，我们看下效果： ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/141782121dd4b200a5d4e86a30eb3edf.gif =400x) 很简单，3s 后从 Compose 变为 kotlin。 现在我们改下代码： 123456789101112131415class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { var name by mutableStateOf(&quot;Compose&quot;) Text(name) LaunchedEffect(true) { delay(3000) name = &quot;Kotlin&quot; } } }} 我们把 var name by mutableStateOf(&quot;Compose&quot;) 从 setContent 外面挪到里面来了。 执行看下效果： ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/893bfeec0b8b5729f88d4b614ebe9c47.gif =400x) 奇怪了，文字没有刷新！ 二、重组作用域问题出在哪？首先我们回顾下 Compose 是怎么刷新界面的？比如上面的例子，当 name 重新赋值后，读取它的地方会被标记为失效，然后重组刷新。 在 Compose 中并不是单纯的刷新 Text(name) 这一行，而是会把包含 Text(name) 的代码块给包起来，刷新的是整个代码块，或者说重组整个代码块： ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/26bf6ee50ba5b59a5bfa4162b7fd948b.png =600x) 所以这段蓝色背景的代码块会被重新执行一遍，这个蓝色区域就是：重组作用域（Recompose scope）！ 所以问题原因你应该就能找到了： 不仅仅 Text(name) 会被重新执行，var name by mutableStateOf(&quot;Compose&quot;) 也会执行！name 又被重新初始化了。 ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/09fcc4a6a553b39de5976bb1b35775ac.png =600x) 三、remember那怎么解决？其实开发工具已经提示你了： mutableStateOf 是标红的，并且错误提示：Creating a state object during composition without using remember. 意思就是：你在组合过程里面创建了 StateObject 对象，但是没有用 remember。 所以怎么包？如下： 123456789101112131415class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { var name by remember { mutableStateOf(&quot;Compose&quot;) } Text(name) LaunchedEffect(true) { delay(3000) name = &quot;Kotlin&quot; } } }} 加了 remember 后，在第一次执行的时候，会执行 Lambda 表达式，也就是执行 mutableStateOf(&quot;Compose&quot;)，并且 remember 会保存结果（StateObject），再次调用的时候会直接返回保存的老对象（StateObject），而不是在执行 Lambda 表达式里面的代码，相当于充当了缓存的功能。 我们执行看下： ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/618f435bbc747ba2039730589b5f3353.gif =400x) 所以 remember 起到缓存作用，就是为了防止多次初始化变量而导致程序不可控，所以在 Compose 里面你只要 mutableStateOf，那么能加 remember 我们就加 remember。 另外我们需要注意 remember 是可以带参数的：可以一个或者多个参数。 12345678910111213141516171819@Composableinline fun &lt;T&gt; remember( key1: Any?, calculation: @DisallowComposableCalls () -&gt; T): T { return currentComposer.cache(currentComposer.changed(key1), calculation)}@Composableinline fun &lt;T&gt; remember( key1: Any?, key2: Any?, calculation: @DisallowComposableCalls () -&gt; T): T { return currentComposer.cache( currentComposer.changed(key1) or currentComposer.changed(key2), calculation )} 有什么用，我们举个例子说明，比如我们自定义了一个 Composable 函数： 12345@Composablefun showCharCount(value: String) { val length = value.length Text(&quot;字符串长度：$length&quot;)} 很简单，一个显示字符串长度的函数。 我们假设一场场景： 传入进来的字符串特别长， 并且 showCharCount 反复被调用了很多次。 那么 value.length 每次都被调用，就显得有点笨重了，所以我们可以给它加上一个 remember。 1234567@Composablefun showCharCount(value: String) { val length = remember { value.length } Text(&quot;字符串长度：$length&quot;)} 但此时就会出现一个问题： 12345678910@Composablefun showCharCount(value: String) { // 第一次传进来：abcd // 第二次传进来：abcdefg // 第三次传进来：abcdefghijklmn val length = remember { value.length } Text(&quot;字符串长度：$length&quot;)} 字符串长度永远都是：4，因为 value.length 不会被执行，那怎么办： 12345678910@Composablefun showCharCount(value: String) { // 第一次传进来：abcd // 第二次传进来：abcdefg // 第三次传进来：abcdefghijklmn val length = remember(value) { value.length } Text(&quot;字符串长度：$length&quot;)} 我们给 remember 加了一个参数：value，只要这个 key 变化了，那么就会重新执行 Lambda 表达式，这就是带参数的 remember 的用法。","link":"/2024/07/10/Compose%20--%20%E7%8A%B6%E6%80%81%E8%AE%A2%E9%98%85%20&%20%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%20--%20remember%20%E5%92%8C%E9%87%8D%E7%BB%84%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"title":"状态转移型动画 API：animate*AsState()","text":"Jetpack Compose 提供了一系列功能强大且可扩展的 API，可用于在应用界面中轻松实现各种「动画效果」。这一系列文章会逐个介绍所有的动画 API，通过最直观的 Demo 示例，手把手教你怎么写动画以及带你了解动画背后的原理。 状态转移型动画 API：animate*AsStateanimate*AsState 函数应该算是 Jetpack Compose 中最简单的一组动画 API 了，主要用于将某个 UI 状态的变化平滑过渡成动画。它可以帮助开发者在状态切换时，通过动画使界面更自然地过渡。 说的直白一点，它主要用于为单个值添加动画效果。你只需提供结束值（或目标值），该 API 就会从当前值开始向指定值播放动画。 一直以来我都认为：探索新技术的最佳方式就是尝试它们！ 接下来我们先构建一个简单场景： 12345678910111213141516171819202122232425class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { Column{ Image( painter = painterResource(R.drawable.bicycle), contentDescription = null, modifier = Modifier .height(90.dp) .absoluteOffset(x = 0.dp) ) Button(onClick = {}, modifier = Modifier .fillMaxWidth() .wrapContentSize(align = Alignment.Center) ) { Text(text = &quot;Ride&quot;) } } } }} 这是一个极其简单的场景：一个图片，一个 Button，初始效果如下： ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/45d8e4da5a9a09094d71117684888d61.png =700x) 现在我们让小刺猬动起来（从左到右），代码可以这样写： 12345678910111213141516171819202122232425262728class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { var offset by remember { mutableStateOf(0.dp) } // 定义偏移变量 Column{ Image( painter = painterResource(R.drawable.bicycle), contentDescription = null, modifier = Modifier .height(90.dp) .absoluteOffset(x = offset) // 获取偏移值 ) Button( onClick = { offset = 360.dp }, // 修改偏移值 modifier = Modifier .fillMaxWidth() .wrapContentSize(align = Alignment.Center) ) { Text(text = &quot;Ride&quot;) } } } }} 如注释说明，我只修改了三个地方，现在来看下效果： ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/a0e68a638637f7dd9087ea12f6c1a9b7.gif =700x) 小刺猬确实动起来了，但是这种效果给人的感觉就很生硬，完全称不上是动画，而是“瞬间移动”。 现在我们可以开始尝试用 animate*AsState 改善动画效果，写法很简单： 1234567891011121314151617181920212223242526272829class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { // var offset by remember { mutableStateOf(0.dp) } // 定义偏移变量 var offset by remember { animateDpAsState(0.dp) } // 替换为 animateDpAsState Column{ Image( painter = painterResource(R.drawable.bicycle), contentDescription = null, modifier = Modifier .height(90.dp) .absoluteOffset(x = offset) // 获取偏移值 ) Button( onClick = { offset = 360.dp }, // 修改偏移值 modifier = Modifier .fillMaxWidth() .wrapContentSize(align = Alignment.Center) ) { Text(text = &quot;Ride&quot;) } } } }} 如你所见，我仅仅用 animateDpAsState 替换 mutableStateOf 后，就可以对数值的大小实现渐变的调整，但很遗憾，这样直接替换是有红线报错的。 ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/53d0b370d07fcd300603e816ee068ddc.png =700x) 接下来我们一起修复这个报错，最终推导出 animateDpAsState 的正确写法。 首先我们回顾下 remember 的作用：它是防止变量被多次重复初始化的，而 animateDpAsState 天生自带这个能力（它的源码内部是包了 remember 的），所以这里我们可以去掉 remember。 ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/910c2898f6d21b3bcc5c45ee5cc4fe28.png =700x) 再来回顾下 by 的作用：把左边 offset 变量委托给右边的 mutableStateOf，mutableStateOf 提供了读和写的功能，但是有一个细节需要注意了，我们对比下 mutableStateOf 和 animateDpAsState 函数的定义： 1234fun &lt;T&gt; mutableStateOf( value: T, policy: SnapshotMutationPolicy&lt;T&gt; = structuralEqualityPolicy()): MutableState&lt;T&gt; = createSnapshotMutableState(value, policy) 1234567@Composablefun animateDpAsState( targetValue: Dp, animationSpec: AnimationSpec&lt;Dp&gt; = dpDefaultSpring, label: String = &quot;DpAnimation&quot;, finishedListener: ((Dp) -&gt; Unit)? = null): State&lt;Dp&gt; { ⇒ mutableStateOf 返回的是一个 MutableState 对象 ⇒ animateDpAsState 返回的是一个 State 对象 在 Compose 中，State 对象只提供读的功能，你是没办法写的！但例子中 var 就代表 offset 是可写的，这就冲突了。Android Studio 的报错提示其实已经说明了： 所以现在我们把 var 改成 val： ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/04cdedd0e7bd089ae58c20c75e151397.png =700x) 这里特别说明一下： ⇒ 蓝色地方有波浪线是因为随着官方 API 的更新，不带 label 参数的 animateDpAsState 函数被弃用了。 12345678910@Deprecated( &quot;animate*AsState APIs now have a new label parameter added.&quot;, level = DeprecationLevel.HIDDEN)@Composablefun animateDpAsState( targetValue: Dp, animationSpec: AnimationSpec&lt;Dp&gt; = dpDefaultSpring, finishedListener: ((Dp) -&gt; Unit)? = null) 官方建议我们使用带 label 参数的 animateDpAsState，所以如果你就不想加，也不会影响程序运行（至于为什么官方这么强烈建议加上这个 label 标签，会在别的动画文章里面说明）。 1val offset by animateDpAsState(0.dp, label = &quot;&quot;) ⇒ 红色地方报错的原因是显而易见的，因为 offset 不可以手动写，那该怎么修改 offset 值？ 以下是正确的写法： 123456789101112131415161718192021222324252627282930class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var bicycleStart by mutableStateOf(false) setContent { val offset by animateDpAsState(if (bicycleStart) 360.dp else 0.dp, label = &quot;&quot;) Column{ Image( painter = painterResource(R.drawable.bicycle), contentDescription = null, modifier = Modifier .height(90.dp) .absoluteOffset(x = offset) ) Button( onClick = { bicycleStart = !bicycleStart }, modifier = Modifier .fillMaxWidth() .wrapContentSize(align = Alignment.Center) ) { Text(text = &quot;Ride&quot;) } } } }} 既然我没法手动修改值，让就通过改变另外一个 bicycleStart 状态，引发重组，从而改变 animateDpAsState 内部的值。 到这里程序就没有任何错误了，这也是 animateDpAsState 的正确写法！ 现在，运行下看看效果：（对比 mutableStateOf 和 animateDpAsState） ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/d08ad4fdef56b06e444395886ba987f0.gif =700x) 效果是很明显的，起码我们能够看出来车是开起来了，而不是瞬间移动。 说明除了 Dp，Compose 为 Float、Color、Size、Offset、Rect、Int、IntOffset 和 IntSize 都提供了开箱即用的 animate*AsState 函数，用法差不多，不再过多举例了。 ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/6861ad0c94dc772b03ac7200db683940.png =700x) 至此，Animate*AsState() 的基本用法了解完了，就这么简单，但是我们还得细看下这个函数的定义： 1234567@Composablefun animateDpAsState( targetValue: Dp, animationSpec: AnimationSpec&lt;Dp&gt; = dpDefaultSpring, label: String = &quot;DpAnimation&quot;, finishedListener: ((Dp) -&gt; Unit)? = null) 它还有一个核心参数：animationSpec，它是一个 AnimationSpec 类型的，你可以通过可选的 AnimationSpec 参数来自定义动画规范（也就是可以实现不同类型的动画效果）。 AnimationSpec 的内容着实不少，作为单独的知识点放在 【 AnimationSpect 详解 】 一文细说。","link":"/2024/07/26/Compose%20--%20%E5%8A%A8%E7%94%BB%20--%20%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E5%9E%8B%E5%8A%A8%E7%94%BB%20API%EF%BC%9Aanimate*AsState()/"},{"title":"流程定制型动画 API：Animatable()","text":"Jetpack Compose 提供了一系列功能强大且可扩展的 API，可用于在应用界面中轻松实现各种动画效果。这一系列文章会逐个介绍所有的动画 API，通过最直观的 Demo 示例，手把手教你怎么写动画以及带你了解动画背后的原理。 系列 文章 手把手教你写 Compose 动画 📑 状态转移型动画 API：animate*AsState() 手把手教你写 Compose 动画 📑 流程定制型动画 API：Animatable() 手把手教你写 Compose 动画 📑 讲的不能再细的 AnimationSpec 动画规范 手把手教你写 Compose 动画 📑 过渡动画 API：Transition 手把手教你写 Compose 动画 📑 显示与消失 API：AnimatedVisibility 手把手教你写 Compose 动画 📑 简单页面切换动画 API：Crossfade 手把手教你写 Compose 动画 📑 更强大的多组件切换动画 API：AnimatedContent 手把手教你写 Compose 动画 📑 组件大小变化 API：animateContentSize 动画图表 在每一篇文章开头，我都会放一张 Compose 动画 API 的图表，以便你有最直观的感受。 流程定制型动画 API：Animatable() Animatable 是一个值容器，会在内部储存一个值，它可以在通过 animateTo 更改值时为值添加动画效果。该 API 支持 animate*AsState 的实现。它可确保一致的连续性和互斥性，这意味着值变化始终是连续的，并且会取消任何正在播放的动画。 Animatable 的许多功能（包括 animateTo）以 “挂起函数“ 的形式提供。这意味着，它们需要封装在适当的 “协程作用域“ 内。例如，你可以使用 LaunchedEffect 可组合项针对指定键值的时长创建一个作用域。 正如我之前一直所说：探索新技术的最佳方式就是尝试它们，看不懂没关系，我带你一起来 Coding： 123456789class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { val anim = Animatable() } }} 注意：Animatable 导包的时候不要选错： 此时，光秃秃的写个 Animatable 是会报错的： ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/412c5b548363bd00c7f3a6b3ae3fc7a2.png =700x) 提示我们想要用 Animatable，那就得用 remember 包起来： ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/2442cca31c5b2152dbbf34bc48203886.png =700x) 提示我们需要填写 “初始值”，这个初始值填什么？我们来看下 Animatable 的定义： 1234fun Animatable( initialValue: Float, visibilityThreshold: Float = Spring.DefaultDisplacementThreshold) 它需要一个 Float 类型的初始值： 123456789class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { val anim = remember { Animatable(0f) } } }} 当然除了 Float 类型，我们也可以填写 Dp 类型，但需要转换类型，如下这样写也能满足 Animatable 的要求： 123456789class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { val anim = remember { Animatable(0.dp, Dp.VectorConverter) } } }} animateTo()现在 Animatable 创建好了，它内部存储了一个 Dp 类型的值。接下来就可以配置动画了，调用 animateTo() 函数即可。 ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/d36ca2dc2f15b34be744fe4d9bbab918.png =700x) 提示我们：animateTo() 是个 suspend 函数，必须要在协程里面使用： 123456789101112class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { val anim = remember { Animatable(0.dp, Dp.VectorConverter) } LaunchedEffect(Unit) { anim.animateTo() } } }} 现在只需要在 animateTo() 里面添加目标值即可。 123456789101112class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { val anim = remember { Animatable(0.dp, Dp.VectorConverter) } LaunchedEffect(Unit) { anim.animateTo(360.dp) } } }} 到这里 Animatable 所需要做的工作全部完成了，现在我们还是使用 【 animate*AsState 用法 】 一文中的小刺猬骑车示例测试： 123456789101112131415161718192021222324252627282930313233class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var bicycleStart by mutableStateOf(false) setContent { val offset = remember(bicycleStart) { if (bicycleStart) 360.dp else 0.dp } val anim = remember { Animatable(offset, Dp.VectorConverter) } LaunchedEffect(bicycleStart) { anim.animateTo(offset) } Column{ Image( painter = painterResource(R.drawable.bicycle), contentDescription = null, modifier = Modifier .absoluteOffset(x = anim.value) ) Button( onClick = { bicycleStart = !bicycleStart }, modifier = Modifier .fillMaxWidth() .wrapContentSize(align = Alignment.Center) ) { Text(text = &quot;Ride&quot;) } } } }} 让我来解读下这段代码： 小刺猬骑车的偏移距离取决于 anim 的值，它的值会随着动画逐渐变化。 点击 Button 会改变 bicycleStart 值，bicycleStart 值变化会重新执行 LaunchedEffect 协程，animateTo 会执行，动画再次启动。 bicycleStart 从 false -&gt; true，小刺猬往前骑，true -&gt; false，小刺猬往后骑。 效果如下： ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/74f73abf27849ba3362a805c44c4a2ba.gif =700x) 结合之前 animate*AsState 动画，我们可以做个对比： ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/3ef7bde6787d5403b45150f9d90c5a63.gif =700x) Animatable 的 animateTo() 可以实现和 animateDpAsState 一样的效果，而 animateDpAsState 内部实际上也是通过 Animatable 实现动画的。 现在我们再来看下 animateTo() 函数的参数： 123456suspend fun animateTo( targetValue: T, animationSpec: AnimationSpec&lt;T&gt; = defaultSpringSpec, initialVelocity: T = velocity, block: (Animatable&lt;T, V&gt;.() -&gt; Unit)? = null) 它和 animateDpAsState 一样也有一个核心参数：animationSpec，之前我们就说过，它是一个 AnimationSpec 类型，你可以通过可选的 AnimationSpec 参数来自定义动画规范（也就是可以实现不同类型的动画效果）。 这篇文章仍然不做讲解，而是会把它作为单独的知识点放在 【 AnimationSpect 详解 】 一文细说。 📓 snapTo() 除了 animateTo 以外，Animatable 还可以通过 snapTo() 在动画开始前设定初始值。 例如下面的代码： 12345678910111213141516171819202122232425262728293031323334class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var bicycleStart by mutableStateOf(false) setContent { val offset = remember(bicycleStart) { if (bicycleStart) 360.dp else 0.dp } val anim = remember { Animatable(offset, Dp.VectorConverter) } LaunchedEffect(bicycleStart) { anim.snapTo(if (bicycleStart) 300.dp else 100.dp) // 指定动画初始值 anim.animateTo(offset) } Column{ Image( painter = painterResource(R.drawable.bicycle), contentDescription = null, modifier = Modifier .absoluteOffset(x = anim.value) ) Button( onClick = { bicycleStart = !bicycleStart }, modifier = Modifier .fillMaxWidth() .wrapContentSize(align = Alignment.Center) ) { Text(text = &quot;Ride&quot;) } } } }} 这个函数的作用不难理解：在动画开始前指定初始值，也就是让动画可以从一个指定的值开始运动，看下面的对比图： ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/a504853b388a3090372f75e57ed42c9a.gif =700x) 虽然动画很快（默认只有 300ms），但我们还是能看出来 snapTo() 后，小刺猬会跳到指定的值开始运动。","link":"/2024/08/01/Compose%20--%20%E5%8A%A8%E7%94%BB%20--%20%E6%B5%81%E7%A8%8B%E5%AE%9A%E5%88%B6%E5%9E%8B%E5%8A%A8%E7%94%BB%20API%EF%BC%9AAnimatable()/"},{"title":"你真的了解重组吗？","text":"Jekpack Compose “状态订阅&amp;自动刷新” 系列： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;【 聊聊 Jetpack Compose 的 “状态订阅&amp;自动刷新” - - MutableState/mutableStateOf 】 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;【 聊聊 Jetpack Compose 的 “状态订阅&amp;自动刷新” - - remember 和重组作用域 】 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;【 聊聊 Jetpack Compose 的 “状态订阅&amp;自动刷新” - - 有状态、无状态、状态提升？】 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;【 聊聊 Jetpack Compose 的 “状态订阅&amp;自动刷新” - - mutableStateListOf 】 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;【 聊聊 Jetpack Compose 的 “状态订阅&amp;自动刷新” - - 你真的了解重组吗？】 先考虑一个问题，什么时候会重组？ 123val name by remember { mutableStateOf(&quot;Hi Compose&quot;)}val nums = mutableStateListOf(1, 2, 3)val maps = mutableStateMapOf(1 to &quot;One&quot;, 2 to &quot;Two&quot;) 通过之前的几篇文章，你应该对这三行代码不陌生，当用 mutableState*Of 申明一个变量的时候，在可组合项中，如果变量变化了，就会触发重组。 比如下面代码： 12345678910111213class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var name by mutableStateOf(&quot;Hi, Compose&quot;) setContent { Column { Text(name, Modifier.clickable { name = &quot;Hi, Kotlin&quot; }) } } }} 运行： Text(name) 被重组了，但是并不是仅仅 Text(name) 被重组，而是整个 Lambda 表达式，我们之前说过，这就是重组作用域。 ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/7236814c37702499a201631fe2696fc5.png =500x) 那么思考一个问题： ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/e76b5b12964dbcb729a2f6ab29c6f6c4.png =500x) 我们先看一个好玩的东西，查看 Column 函数： 1234567891011121314@Composableinline fun Column( modifier: Modifier = Modifier, verticalArrangement: Arrangement.Vertical = Arrangement.Top, horizontalAlignment: Alignment.Horizontal = Alignment.Start, content: @Composable ColumnScope.() -&gt; Unit) { val measurePolicy = columnMeasurePolicy(verticalArrangement, horizontalAlignment) Layout( content = { ColumnScopeInstance.content() }, measurePolicy = measurePolicy, modifier = modifier )} Column 是个 inline 函数（内联函数），这就意味着在实际编译之前，这个函数的调用会被替换成内部实际的代码，比如会是下面这个样子： 12345678910111213141516class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var name by mutableStateOf(&quot;Hi, Compose&quot;) setContent { // Column { // 替换为 Layout( Text(name, Modifier.clickable { name = &quot;Hi, Kotlin&quot; }) ) // } } }} 再来看下 Layout()： 1234567891011@Composable inline fun Layout( content: @Composable @UiComposable () -&gt; Unit, modifier: Modifier = Modifier, measurePolicy: MeasurePolicy) { ... ... ReusableComposeNode&lt;ComposeUiNode, Applier&lt;Any&gt;&gt;( ... ... content = content )} 也是个 inline 函数，那么代码又回变成这样： 123456789101112131415161718class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var name by mutableStateOf(&quot;Hi, Compose&quot;) setContent { // Column { // Layout( // 替换为 ReusableComposeNode( Text(name, Modifier.clickable { name = &quot;Hi, Kotlin&quot; }) ) // ) // } } }} 再来看下 ReusableComposeNode： 1234567891011@Composable @ExplicitGroupsComposableinline fun &lt;T, reified E : Applier&lt;*&gt;&gt; ReusableComposeNode( noinline factory: () -&gt; T, update: @DisallowComposableCalls Updater&lt;T&gt;.() -&gt; Unit, noinline skippableUpdate: @Composable SkippableUpdater&lt;T&gt;.() -&gt; Unit, content: @Composable () -&gt; Unit) { ... ... content() ... ...} 又是 inline 函数，而且你看它内部干啥了？直接调用了 content()！ 所以最终代码在编译前其实会把 Column {} 给拿掉，就跟下面一样： 123456789101112131415161718class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var name by mutableStateOf(&quot;Hi, Compose&quot;) setContent { // Column { // Layout( // 替换为 // ReusableComposeNode( Text(name, Modifier.clickable { name = &quot;Hi, Kotlin&quot; }) // ) // ) // } } }} 那么这就意味着： 1234567891011121314151617class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var name by mutableStateOf(&quot;Hi, Compose&quot;) setContent { // 组件 1，这个地方会因为 name 的改变而一起重新调用 Column { // 组件 2，这个地方会因为 name 的改变而一起重新调用 Text(name, Modifier.clickable { name = &quot;Hi, Kotlin&quot; }) // 组件 3，这个地方会因为 name 的改变而一起重新调用 } // 组件4，这个地方会因为 name 的改变而一起重新调用 } }} 为了验证，我们测试下： 1234567891011121314151617class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var name by mutableStateOf(&quot;Hi, Compose&quot;) setContent { println(&quot;Recompose 范围测试 1&quot;) Column { println(&quot;Recompose 范围测试 2&quot;) Text(name, Modifier.clickable { name = &quot;Hi, Kotlin&quot; }) println(&quot;Recompose 范围测试 3&quot;) } println(&quot;Recompose 范围测试 4&quot;) } }} 运行： 这个 Log 没有任何问题，现在我们点击： Log 已经验证了我们刚才的结论，那这就涉及到了一个问题：性能风险！ 比如下面的代码有可能出现在你的代码中： 123456789101112131415161718192021222324class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var name by mutableStateOf(&quot;Hi, Compose&quot;) setContent { println(&quot;Recompose 范围测试 1&quot;) Column { println(&quot;Recompose 范围测试 2&quot;) Text(name, Modifier.clickable { name = &quot;Hi, Kotlin&quot; }) println(&quot;Recompose 范围测试 3&quot;) } NBFunction() println(&quot;Recompose 范围测试 4&quot;) } }}@Composablefun NBFunction() { println(&quot;Recompose 范围测试：我干了很多消耗性能的事～～～&quot;) // 这里面干了很多 NB 的事，逻辑量特别大} 你写了一个很牛逼的 Composable 函数，里面干了很多复杂的事，特别消耗性能，那么每次随着 name 的更改，NBFunction() 都会被执行一遍，就就会存在巨大的性能消耗。 你要不信，我们运行一下，看下 Log： 🤔？？？点击 name 后，NBFunction() 竟然没有再次执行？但其他 Log 仍然执行了啊！ 难道 NBFunction() 没有被调用？ 其实 NBFunction() 被调用了，只不过进入 NBFunction() 内部后，内部的代码没有被执行。 🤔？？？都进来了，你跟我说内部代码不执行？– 对！ 其实这是因为：在 Compose 的编译过程中，编译器插件会做干预，这个干预过程会修改我们的 Compose 函数，比如说它会给函数内部的代码加上一些条件判断，判断这个函数的参数跟上一次函数被调用的时候传入的参数有没有改变，如果没有改变，就直接跳过这个函数的内部代码的执行，这是 Compose 的优化。 而你看 NBFunction() 这个函数有参数吗？– 没有，所以它内部代码永远不会执行，所以 Log 肯定不会打印出来。 来试一下，改下代码： 12345678910111213141516171819202122232425class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var name by mutableStateOf(&quot;Hi, Compose&quot;) setContent { println(&quot;Recompose 范围测试 1&quot;) Column { println(&quot;Recompose 范围测试 2&quot;) Text(name, Modifier.clickable { name = &quot;Hi, Kotlin&quot; }) println(&quot;Recompose 范围测试 3&quot;) NBFunction(name) } println(&quot;Recompose 范围测试 4&quot;) } }}@Composablefun NBFunction(name: String) { println(&quot;Recompose 范围测试：我干了很多消耗性能的事～～～&quot;) // 这里面干了很多 NB 的事，逻辑量特别大 Text(&quot;$name&quot;)} 我们给 NBFunction 加个参数，那么随着 name 的改变，看看它会不会被执行： 结果显而易见了！Compose 重组过程中会判断 NBFunction() 的参数 String 是否变化，那么如果我的参数是一个对象呢？ 比如我传入的是： 1data class User(val name: String) Compose 在重组过程中，依然会对对象类型的参数做判断，不过它的判断规则是 Kotlin 中的 “==”，等同于 Java 的 “equals”，是结构性相等判断。 现在我们修改下代码： 12345678910111213141516171819202122232425262728293031class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var name by mutableStateOf(&quot;Hi, Compose&quot;) var user = User(&quot;marco&quot;) // User 对象 setContent { println(&quot;Recompose 范围测试 1&quot;) Column { println(&quot;Recompose 范围测试 2&quot;) Text(name, Modifier.clickable { name = &quot;Hi, Kotlin&quot; user = User(&quot;marco&quot;) // 点击后，新的 User 对象 }) println(&quot;Recompose 范围测试 3&quot;) NBFunction(user) } println(&quot;Recompose 范围测试 4&quot;) } }}@Composablefun NBFunction(user: User) { println(&quot;Recompose 范围测试：我干了很多消耗性能的事～～～&quot;) // 这里面干了很多 NB 的事，逻辑量特别大 Text(&quot;${user.name}&quot;)}data class User(val name: String) 代码很简单，我们通过 Log 验证下： 我们再改下代码，把 User 换成一个新的内容： 123456var user = User(&quot;marco&quot;)Text(name, Modifier.clickable { name = &quot;Hi, Kotlin&quot; user = User(&quot;marco_2&quot;)}) 再看下 Log： 确实如我们前面预想一样，Compose 重组过程中同样会对 NBFunction() 的对象参数也做判断，是结构性相等判断。 接下来我们看个有意思的东西，我们再来改一下代码： 12345678910111213var user = User(&quot;marco&quot;)Text(name, Modifier.clickable { name = &quot;Hi, Kotlin&quot; user = User(&quot;marco&quot;). // user 改回来，都是 marco 内容})==&gt; 此时肯定是会判断相等，不会执行 NBFunction() 内部的代码---==&gt; 接下来我们只改一下关键字：data class User(val name: String)// val --&gt; vardata class User(var name: String) 仅仅把 val 改成 var，运行看 Log： 🤔？？？val 就会跳过 NBFunction() 内部代码，var 就不会跳过 NBFunction() 内部代码？Why？ 这是因为 Compose 的本身机制设定： 12data class User(val name: String) // Compose 会认为这是一个可靠的类data class User(var name: String) // Compose 会认为这是一个不可靠的类 对于不可靠的类，我就不管你了，直接进！这是因为出于界面正确性的考虑。 比如我们修改下代码： 所以，与性能相比，准确性才是最终要的，所以就会无条件的进入 NBFunction() 函数再执行一遍。 那如果假设我们可以保证不会出现以上情况，保证 User 对象永远相等，希望 Composable 插件也可以跳过内部执行，提升性能，如何做呢？ 用 @Stable 注解，它是一个稳定性注解，告诉 Compose 编译器插件，这个类是可靠的。这样 Compose 重组过程中就会跳过 NBFunction() 内部代码。 12@Stabledata class User(var name: String) 运行看下 Log： 除了 @Stable 可以认定可靠以外，还有一种方式可以告诉 Compose 是可靠的： 123class User(name: String) { var name by mutableStateOf(name) // 这是一种更通用的写法}","link":"/2024/07/22/Compose%20--%20%E7%8A%B6%E6%80%81%E8%AE%A2%E9%98%85%20&%20%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%20--%20%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E9%87%8D%E7%BB%84%E5%90%97%EF%BC%9F/"},{"title":"SQLite -- 从入门到精通","text":"@TOC SQLite 是遵循一套独特的称为语法的规则和准则。有个重要的点值得注意，SQLite 是不区分大小写的，但也有一些命令是大小写敏感的，比如 GLOB 和 glob 在 SQLite 的语句中有不同的含义。 一、数据库操作1.1 新建数据库可以直接执行 sqlite3 filename 打开或创建一个 SQLite 数据库。如果文件不存在，SQLite 会自动创建它。 1234maxin@maxindeMacBook-Pro db % sqlite3 test.dbSQLite version 3.46.1 2024-08-13 09:16:08Enter &quot;.help&quot; for usage hints.sqlite&gt; 1.2 查看数据库12sqlite&gt; .databasesmain: /Users/maxin/Desktop/db/test.db r/w 使用 .quit 或者 .exit 退出 sqlite3 工具。 再查看当前目录，会发现新增了一个 test.db 文件。 ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/3e4b894601524de49e534f2e78c6844b.png =430x) 1.3 查看帮助指令使用 .help 查看 帮助信息。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364sqlite&gt; .help.archive ... Manage SQL archives.auth ON|OFF Show authorizer callbacks.backup ?DB? FILE Backup DB (default &quot;main&quot;) to FILE.bail on|off Stop after hitting an error. Default OFF.cd DIRECTORY Change the working directory to DIRECTORY.changes on|off Show number of rows changed by SQL.check GLOB Fail if output since .testcase does not match.clone NEWDB Clone data into NEWDB from the existing database.connection [close] [#] Open or close an auxiliary database connection.databases List names and files of attached databases.dbconfig ?op? ?val? List or change sqlite3_db_config() options.dbinfo ?DB? Show status information about the database.dump ?OBJECTS? Render database content as SQL.echo on|off Turn command echo on or off.eqp on|off|full|... Enable or disable automatic EXPLAIN QUERY PLAN.excel Display the output of next command in spreadsheet.exit ?CODE? Exit this program with return-code CODE.expert EXPERIMENTAL. Suggest indexes for queries.explain ?on|off|auto? Change the EXPLAIN formatting mode. Default: auto.filectrl CMD ... Run various sqlite3_file_control() operations.fullschema ?--indent? Show schema and the content of sqlite_stat tables.headers on|off Turn display of headers on or off.help ?-all? ?PATTERN? Show help text for PATTERN.import FILE TABLE Import data from FILE into TABLE.indexes ?TABLE? Show names of indexes.intck ?STEPS_PER_UNLOCK? Run an incremental integrity check on the db.limit ?LIMIT? ?VAL? Display or change the value of an SQLITE_LIMIT.lint OPTIONS Report potential schema issues..load FILE ?ENTRY? Load an extension library.log FILE|on|off Turn logging on or off. FILE can be stderr/stdout.mode MODE ?OPTIONS? Set output mode.nonce STRING Suspend safe mode for one command if nonce matches.nullvalue STRING Use STRING in place of NULL values.once ?OPTIONS? ?FILE? Output for the next SQL command only to FILE.open ?OPTIONS? ?FILE? Close existing database and reopen FILE.output ?FILE? Send output to FILE or stdout if FILE is omitted.parameter CMD ... Manage SQL parameter bindings.print STRING... Print literal STRING.progress N Invoke progress handler after every N opcodes.prompt MAIN CONTINUE Replace the standard prompts.quit Stop interpreting input stream, exit if primary..read FILE Read input from FILE or command output.recover Recover as much data as possible from corrupt db..restore ?DB? FILE Restore content of DB (default &quot;main&quot;) from FILE.save ?OPTIONS? FILE Write database to FILE (an alias for .backup ...).scanstats on|off|est Turn sqlite3_stmt_scanstatus() metrics on or off.schema ?PATTERN? Show the CREATE statements matching PATTERN.separator COL ?ROW? Change the column and row separators.session ?NAME? CMD ... Create or control sessions.sha3sum ... Compute a SHA3 hash of database content.shell CMD ARGS... Run CMD ARGS... in a system shell.show Show the current values for various settings.stats ?ARG? Show stats or turn stats on or off.system CMD ARGS... Run CMD ARGS... in a system shell.tables ?TABLE? List names of tables matching LIKE pattern TABLE.timeout MS Try opening locked tables for MS milliseconds.timer on|off Turn SQL timer on or off.trace ?OPTIONS? Output each SQL statement as it is run.version Show source, library and compiler versions.vfsinfo ?AUX? Information about the top-level VFS.vfslist List all available VFSes.vfsname ?AUX? Print the name of the VFS stack.width NUM1 NUM2 ... Set minimum column widths for columnar output 二、表操作2.1 创建表SQLite 的 CREATE TABLE 语句用于在任何给定的数据库创建一个新表。创建基本表，涉及到命名表、定义列及每一列的数据类型。 CREATE TABLE 语句的基本语法如下： 1234567CREATE TABLE database_name.table_name( column1 datatype PRIMARY KEY(one or more columns), column2 datatype, column3 datatype, ..... columnN datatype,); CREATE TABLE 是告诉数据库系统创建一个新表的关键字。CREATE TABLE 语句后跟着表的唯一的名称或标识。你也可以选择指定带有 table_name 的 database_name。 例如：创建一个 COMPANY 表，ID 作为主键，NOT NULL 的约束表示在表中创建纪录时这些字段不能为 NULL： 1234567sqlite&gt; CREATE TABLE COMPANY( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL); 我们来解读一下这种语法结构： CREATE TABLE 语句 CREATE TABLE 是用来 创建数据库表 的 SQL 语句。 拆解 含义 说明 COMPANY 新表的 表名 你可以通过这个名字来引用该表 圆括号 () 括号中的内容定义了 表的结构 即每一列（字段）的名称、数据类型及约束条件 表的列定义 在这段语法中，每一行定义了一列（字段），包括字段名、数据类型，以及一些可选的约束条件。 列（字段名） 数据类型 是否允许为空 是否为主键 说明 ID INT 不允许 是 员工的唯一标识（主键） NAME TEXT 不允许 否 员工的姓名 AGE INT 不允许 否 员工的年龄 ADDRESS CHAR(50) 允许 否 员工的地址，最多 50 个字符 SALARY REAL 允许 否 员工的薪资（浮点数） 我们说过：SQLite 是不区分大小写的，所以如果你像下面这样定义也是可以的： 1234567create table company ( id int primary key not null, name text not null, age int not null, address char(50), salary real); 常见的编码习惯 大写关键字风格（例如：CREATE TABLE、SELECT、INSERT 等关键字大写）这种风格比较常见于官方文档和企业级开发，目的是让 SQL 关键字在代码中更醒目，易于识别。例如：CREATE TABLE COMPANY (ID INT PRIMARY KEY)。 小写关键字风格（例如：create table、select）有些开发者或社区更倾向于全小写，认为这样风格一致，看起来更加简洁。在某些语言中，如 Python 等，惯用全小写风格，开发者会把这个习惯带到 SQL 中。 这种差异主要是个人偏好或团队风格的选择，功能上没有任何影响。 编写风格建议 无论你使用大写还是小写，保持一致性 都是良好的编码习惯，尤其是在多人协作开发中。通常，团队会统一编码规范，比如： 所有 「SQL 关键字」 用大写，例如：SELECT、FROM。 「表名」 和 「列名」 用小写（或蛇形命名），例如：user_name、order_date。 比如像下面这样： 12345CREATE TABLE company ( id INT PRIMARY KEY, name TEXT NOT NULL, age INT NOT NULL); 再比如，我们创建名为 user、student 的表： 12345maxin@maxindeMacBook-Pro db % sqlite3 test.dbSQLite version 3.46.1 2024-08-13 09:16:08Enter &quot;.help&quot; for usage hints.sqlite&gt; CREATE TABLE user(name text, age int);sqlite&gt; CREATE TABLE student(id int, name text, age int, primary key(id)); 2.2 表信息表创建完成后，你可以使用 .tables 或者 .table tableName 命令查看所有现有表格或者单个表格的信息： 12345678sqlite&gt; .tablesCOMPANY student usersqlite&gt; .table COMPANYCOMPANYsqlite&gt; .table studentstudentsqlite&gt; .table useruser 2.3 表索引信息在 SQLite 中，.indices 是 SQLite 命令行工具中用于 列出一个表所有索引 的命令。这个命令的作用是「展示某个表已经定义的所有索引」。 基本语法： 1.indices 表名 例如： 1234567sqlite&gt; .indices COMPANYsqlite_autoindex_COMPANY_1------------------------------------------sqlite&gt; .indices studentsqlite_autoindex_student_1------------------------------------------sqlite&gt; .indices user # user 表没有建索引 sqlite_autoindex_company_1 / sqlite_autoindex_student_1 这是 SQLite 自动创建的索引，因为 COMPANY / student 表中的 ID 列定义为 主键（PRIMARY KEY）。SQLite 会自动为主键列创建索引，帮助快速查询。 2.4 表结构信息在 SQLite 中，.schema 是 SQLite 命令行工具中的一个常用命令，用来「查看数据库中表、视图、索引等对象的 创建语句（DDL）」。 查看所有对象的创建语句： 12345678910sqlite&gt; .schemaCREATE TABLE user(name text,age int);CREATE TABLE student(id int,name text,age int,primary key(id));CREATE TABLE COMPANY( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL); 查看指定表的创建语句： 1234567891011121314sqlite&gt; .schema userCREATE TABLE user(name text,age int);------------------------------------------sqlite&gt; .schema studentCREATE TABLE student(id int,name text,age int,primary key(id));------------------------------------------sqlite&gt; .schema COMPANYCREATE TABLE COMPANY( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL); 2.5 删除表SQLite 的 DROP TABLE 语句用来删除表定义及其所有相关数据、索引、触发器、约束和该表的权限规范。 使用此命令时要特别注意，因为一旦一个表被删除，表中所有信息也将永远丢失！！！ 基本语法： 1DROP TABLE database_name.table_name; 例如：我们删除 user 表 让我们先确认 user 表已经存在，然后我们将其从数据库中删除。 12sqlite&gt; .tablesCOMPANY student user 这意味着 user 表已存在数据库中，接下来让我们把它从数据库中删除，如下： 12sqlite&gt; drop table user;sqlite&gt; 现在，如果尝试 .tables 命令，那么将无法找到 user 表了： 123sqlite&gt; .tablesCOMPANY studentsqlite&gt; 三、数据记录操作3.1 新增记录SQLite 的 INSERT INTO 语句用于向数据库的某个表中添加新的数据行。 INSERT INTO 语句有两种基本语法，如下所示： 12INSERT INTO TABLE_NAME [(column1, column2, column3, ...columnN)] VALUES (value1, value2, value3, ...valueN); 在这里，column1, column2,…columnN 是要插入数据的表中的列的名称。如果要为表中的所有列添加值，你也可以不需要在 SQLite 查询中指定列名称。但要确保值的顺序与列在表中的顺序一致。 SQLite 的 INSERT INTO 语法如下： 1INSERT INTO TABLE_NAME VALUES (value1,value2,value3,...valueN); 例如，我们往 COMPANY 里面添加数据： 1234567891011121314151617INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)VALUES (1, 'Paul', 32, 'California', 20000.00 );INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)VALUES (2, 'Allen', 25, 'Texas', 15000.00 );INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)VALUES (3, 'Teddy', 23, 'Norway', 20000.00 );INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)VALUES (4, 'Mark', 25, 'Rich-Mond ', 65000.00 );INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)VALUES (5, 'David', 27, 'Texas', 85000.00 );INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)VALUES (6, 'Kim', 22, 'South-Hall', 45000.00 ); 你也可以使用第二种语法在 COMPANY 表中创建一个记录，如下所示： 123456INSERT INTO COMPANY VALUES (1, 'Paul', 32, 'California', 20000.00 );INSERT INTO COMPANY VALUES (2, 'Allen', 25, 'Texas', 15000.00 );INSERT INTO COMPANY VALUES (3, 'Teddy', 23, 'Norway', 20000.00 );INSERT INTO COMPANY VALUES (4, 'Mark', 25, 'Rich-Mond ', 65000.00 );INSERT INTO COMPANY VALUES (5, 'David', 27, 'Texas', 85000.00 );INSERT INTO COMPANY VALUES (6, 'Kim', 22, 'South-Hall', 45000.00 ); 3.2 查看记录SQLite 的 SELECT 语句用于从 SQLite 数据库表中获取数据，以结果表的形式返回数据。这些结果表也被称为结果集。 基本语法： 1SELECT column1, column2, columnN FROM table_name; 在这里，column1, column2… 是表的字段，它们的值即是你要获取的。如果你想获取所有可用的字段，那么可以使用下面的语法： 1SELECT * FROM table_name; 例如，我们刚刚给 COMPANY 表添加了数据，现在查看下： 1234567sqlite&gt; select * from company;1|Paul|32|California|20000.02|Allen|25|Texas|15000.03|Teddy|23|Norway|20000.04|Mark|25|Rich-Mond |65000.05|David|27|Texas|85000.06|Kim|22|South-Hall|45000.0 如果只想获取 COMPANY 表中指定的字段，则使用下面的查询： 12345678910sqlite&gt; .mode columnsqlite&gt; SELECT ID, NAME, SALARY FROM COMPANY;ID NAME SALARY-- ----- -------1 Paul 20000.02 Allen 15000.03 Teddy 20000.04 Mark 65000.05 David 85000.06 Kim 45000.0 3.3 不同格式输出在 SQLite 命令行工具中，.mode 用于控制「查询结果的输出格式」。根据需求，你可以选择不同的模式，比如将数据格式化为表格、CSV、HTML 或其他样式。这可以帮助你更方便地查看、调试和导出数据。 常见的 .mode 选项及其作用： 1. column（列模式） 数据以 表格形式 显示，列名和数据对齐，适合人类阅读。 命令：12sqlite&gt; .mode columnsqlite&gt; select * from company; 输出示例：12345678ID NAME AGE ADDRESS SALARY-- ----- --- ---------- -------1 Paul 32 California 20000.02 Allen 25 Texas 15000.03 Teddy 23 Norway 20000.04 Mark 25 Rich-Mond 65000.05 David 27 Texas 85000.06 Kim 22 South-Hall 45000.0 2. list（列表模式） 数据以 竖线（|）分隔，适合快速查看或复制。 命令：12sqlite&gt; .mode listsqlite&gt; select * from company; 输出示例：1234567ID|NAME|AGE|ADDRESS|SALARY1|Paul|32|California|20000.02|Allen|25|Texas|15000.03|Teddy|23|Norway|20000.04|Mark|25|Rich-Mond |65000.05|David|27|Texas|85000.06|Kim|22|South-Hall|45000.0 3. csv（CSV 模式） 数据以 逗号分隔值 格式输出，适合导出到文件或电子表格。 命令：12sqlite&gt; .mode csvsqlite&gt; select * from company; 输出示例：1234567ID,NAME,AGE,ADDRESS,SALARY1,Paul,32,California,20000.02,Allen,25,Texas,15000.03,Teddy,23,Norway,20000.04,Mark,25,&quot;Rich-Mond &quot;,65000.05,David,27,Texas,85000.06,Kim,22,South-Hall,45000.0 4. html（HTML 模式） 数据以 HTML 表格 格式输出，适合导出到网页或报告中。 命令：12sqlite&gt; .mode htmlsqlite&gt; select * from company; 输出示例：123456789101112131415161718192021222324252627282930313233343536373839404142&lt;TR&gt;&lt;TH&gt;ID&lt;/TH&gt;&lt;TH&gt;NAME&lt;/TH&gt;&lt;TH&gt;AGE&lt;/TH&gt;&lt;TH&gt;ADDRESS&lt;/TH&gt;&lt;TH&gt;SALARY&lt;/TH&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;1&lt;/TD&gt;&lt;TD&gt;Paul&lt;/TD&gt;&lt;TD&gt;32&lt;/TD&gt;&lt;TD&gt;California&lt;/TD&gt;&lt;TD&gt;20000.0&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;2&lt;/TD&gt;&lt;TD&gt;Allen&lt;/TD&gt;&lt;TD&gt;25&lt;/TD&gt;&lt;TD&gt;Texas&lt;/TD&gt;&lt;TD&gt;15000.0&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;3&lt;/TD&gt;&lt;TD&gt;Teddy&lt;/TD&gt;&lt;TD&gt;23&lt;/TD&gt;&lt;TD&gt;Norway&lt;/TD&gt;&lt;TD&gt;20000.0&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;4&lt;/TD&gt;&lt;TD&gt;Mark&lt;/TD&gt;&lt;TD&gt;25&lt;/TD&gt;&lt;TD&gt;Rich-Mond &lt;/TD&gt;&lt;TD&gt;65000.0&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;5&lt;/TD&gt;&lt;TD&gt;David&lt;/TD&gt;&lt;TD&gt;27&lt;/TD&gt;&lt;TD&gt;Texas&lt;/TD&gt;&lt;TD&gt;85000.0&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;6&lt;/TD&gt;&lt;TD&gt;Kim&lt;/TD&gt;&lt;TD&gt;22&lt;/TD&gt;&lt;TD&gt;South-Hall&lt;/TD&gt;&lt;TD&gt;45000.0&lt;/TD&gt;&lt;/TR&gt; 5. tabs（制表符分隔模式） 数据以 制表符 分隔，适合导出到文件并在代码或编辑器中处理。 命令：12sqlite&gt; .mode tabssqlite&gt; select * from company; 输出示例：1234567ID NAME AGE ADDRESS SALARY1 Paul 32 California 20000.02 Allen 25 Texas 15000.03 Teddy 23 Norway 20000.04 Mark 25 Rich-Mond 65000.05 David 27 Texas 85000.06 Kim 22 South-Hall 45000.0 6. insert（INSERT 模式） 数据以 INSERT INTO 语句 的形式输出，方便将数据重新导入数据库。 命令：12sqlite&gt; .mode insertsqlite&gt; select * from company; 输出示例：123456INSERT INTO &quot;table&quot;(ID,NAME,AGE,ADDRESS,SALARY) VALUES(1,'Paul',32,'California',20000.0);INSERT INTO &quot;table&quot;(ID,NAME,AGE,ADDRESS,SALARY) VALUES(2,'Allen',25,'Texas',15000.0);INSERT INTO &quot;table&quot;(ID,NAME,AGE,ADDRESS,SALARY) VALUES(3,'Teddy',23,'Norway',20000.0);INSERT INTO &quot;table&quot;(ID,NAME,AGE,ADDRESS,SALARY) VALUES(4,'Mark',25,'Rich-Mond ',65000.0);INSERT INTO &quot;table&quot;(ID,NAME,AGE,ADDRESS,SALARY) VALUES(5,'David',27,'Texas',85000.0);INSERT INTO &quot;table&quot;(ID,NAME,AGE,ADDRESS,SALARY) VALUES(6,'Kim',22,'South-Hall',45000.0); 7. json（JSON 模式） 数据以 JSON 格式 输出，适合在开发过程中使用，也非常适合与前端、API 交互，或者导出 JSON 数据。 命令：12sqlite&gt; .mode jsonsqlite&gt; select * from company; 输出示例：123456[{&quot;ID&quot;:1,&quot;NAME&quot;:&quot;Paul&quot;,&quot;AGE&quot;:32,&quot;ADDRESS&quot;:&quot;California&quot;,&quot;SALARY&quot;:20000.0},{&quot;ID&quot;:2,&quot;NAME&quot;:&quot;Allen&quot;,&quot;AGE&quot;:25,&quot;ADDRESS&quot;:&quot;Texas&quot;,&quot;SALARY&quot;:15000.0},{&quot;ID&quot;:3,&quot;NAME&quot;:&quot;Teddy&quot;,&quot;AGE&quot;:23,&quot;ADDRESS&quot;:&quot;Norway&quot;,&quot;SALARY&quot;:20000.0},{&quot;ID&quot;:4,&quot;NAME&quot;:&quot;Mark&quot;,&quot;AGE&quot;:25,&quot;ADDRESS&quot;:&quot;Rich-Mond &quot;,&quot;SALARY&quot;:65000.0},{&quot;ID&quot;:5,&quot;NAME&quot;:&quot;David&quot;,&quot;AGE&quot;:27,&quot;ADDRESS&quot;:&quot;Texas&quot;,&quot;SALARY&quot;:85000.0},{&quot;ID&quot;:6,&quot;NAME&quot;:&quot;Kim&quot;,&quot;AGE&quot;:22,&quot;ADDRESS&quot;:&quot;South-Hall&quot;,&quot;SALARY&quot;:45000.0}] 四、运算符SQLite 提供了多种运算符，用于数据操作、筛选和计算。主要运算符分为以下几类： 算术运算符 比较运算符 逻辑运算符 位运算符 4.1 算术运算符SQLite 支持常见的「算术运算符」，用于在查询语句中进行数学运算。这些运算符可以在 SELECT 语句中计算列值，也可以用于更新操作。常见的算术运算符包括 加、减、乘、除 和 取模。 算数运算符 描述 示例 实例 + 加法 10 + 5 15 - 减法 10 - 5 5 * 乘法 10 * 5 50 / 除法 10 / 5 2.0 % 取模（求余数） 10 % 3 1 例如：我们对前面的 COMPANY 表进行「算数运算符」的操作： 12345678910sqlite&gt; .mode columnsqlite&gt; select * from company;ID NAME AGE ADDRESS SALARY-- ----- --- ---------- -------1 Paul 32 California 20000.02 Allen 25 Texas 15000.03 Teddy 23 Norway 20000.04 Mark 25 Rich-Mond 65000.05 David 27 Texas 85000.06 Kim 22 South-Hall 45000.0 加法（+） 12345678910# 给每个员工的薪资增加 5000sqlite&gt; SELECT name, salary, salary + 5000 AS new_salary FROM company;NAME SALARY new_salary----- ------- ----------Paul 20000.0 25000.0Allen 15000.0 20000.0Teddy 20000.0 25000.0Mark 65000.0 70000.0David 85000.0 90000.0Kim 45000.0 50000.0 减法（-） 12345678910# 给每个员工的薪资减少 2000sqlite&gt; SELECT name, salary, salary - 2000 AS reduced_salary FROM company;NAME SALARY reduced_salary----- ------- --------------Paul 20000.0 18000.0Allen 15000.0 13000.0Teddy 20000.0 18000.0Mark 65000.0 63000.0David 85000.0 83000.0Kim 45000.0 43000.0 乘法（*） 12345678910# 给每个员工的薪资翻倍sqlite&gt; SELECT name, salary, salary * 2 AS doubled_salary FROM company;NAME SALARY doubled_salary----- ------- --------------Paul 20000.0 40000.0Allen 15000.0 30000.0Teddy 20000.0 40000.0Mark 65000.0 130000.0David 85000.0 170000.0Kim 45000.0 90000.0 除法（/） 12345678910# 将员工的年薪除以 12，计算月薪sqlite&gt; SELECT name, salary / 12 AS monthly_salary FROM company;NAME monthly_salary----- ----------------Paul 1666.66666666667Allen 1250.0Teddy 1666.66666666667Mark 5416.66666666667David 7083.33333333333Kim 3750.0 取模（%） 12345678910# 计算每个员工年龄除以 2 的余数，判断是否为偶数年龄（余数为 0）sqlite&gt; SELECT id, name, age % 2 AS age_mod FROM company;ID NAME age_mod-- ----- -------1 Paul 02 Allen 13 Teddy 14 Mark 15 David 16 Kim 0 结合 WHERE 条件使用 123456# 查询月薪大于 5000 的员工sqlite&gt; SELECT * FROM company WHERE salary / 12 &gt; 5000;ID NAME AGE ADDRESS SALARY-- ----- --- ---------- -------4 Mark 25 Rich-Mond 65000.05 David 27 Texas 85000.0 4.2 比较运算符用于比较两个值，返回 TRUE 或 FALSE。 比较运算符 描述 示例 实例 = 等于 age = 25 TRUE/FALSE != 不等于（SQLite 也支持 &lt;&gt;） age != 30 TRUE/FALSE &lt; 小于 age &lt; 25 TRUE/FALSE &gt; 大于 age &gt; 20 TRUE/FALSE &lt;= 小于等于 age &lt;= 25 TRUE/FALSE &gt;= 大于等于 age &gt;= 20 TRUE/FALSE 例如：我们对前面的 COMPANY 表进行「比较运算符」的操作： 12345678910sqlite&gt; .mode columnsqlite&gt; select * from company;ID NAME AGE ADDRESS SALARY-- ----- --- ---------- -------1 Paul 32 California 20000.02 Allen 25 Texas 15000.03 Teddy 23 Norway 20000.04 Mark 25 Rich-Mond 65000.05 David 27 Texas 85000.06 Kim 22 South-Hall 45000.0 列出 SALARY 大于 50,000.00 的所有记录 12345sqlite&gt; SELECT * FROM COMPANY WHERE SALARY &gt; 50000;ID NAME AGE ADDRESS SALARY-- ----- --- ---------- -------4 Mark 25 Rich-Mond 65000.05 David 27 Texas 85000.0 列出 SALARY 等于 20,000.00 的所有记录 12345sqlite&gt; SELECT * FROM COMPANY WHERE SALARY = 20000;ID NAME AGE ADDRESS SALARY-- ----- --- ---------- -------1 Paul 32 California 20000.03 Teddy 23 Norway 20000.0 列出 SALARY 不等于 20,000.00 的所有记录 123456789101112131415sqlite&gt; SELECT * FROM COMPANY WHERE SALARY != 20000;ID NAME AGE ADDRESS SALARY-- ----- --- ---------- -------2 Allen 25 Texas 15000.04 Mark 25 Rich-Mond 65000.05 David 27 Texas 85000.06 Kim 22 South-Hall 45000.0sqlite&gt; SELECT * FROM COMPANY WHERE SALARY &lt;&gt; 20000;ID NAME AGE ADDRESS SALARY-- ----- --- ---------- -------2 Allen 25 Texas 15000.04 Mark 25 Rich-Mond 65000.05 David 27 Texas 85000.06 Kim 22 South-Hall 45000.0 列出 SALARY 大于等于 65,000.00 的所有记录 12345sqlite&gt; SELECT * FROM COMPANY WHERE SALARY &gt;= 65000;ID NAME AGE ADDRESS SALARY-- ----- --- ---------- -------4 Mark 25 Rich-Mond 65000.05 David 27 Texas 85000.0 4.3 逻辑运算符用于连接多个条件表达式，返回布尔值。 逻辑运算符 描述 示例 实例 AND 逻辑与 age &gt; 20 AND salary &lt; 50000 TRUE/FALSE OR 逻辑或 age &lt; 25 OR salary &gt; 60000 TRUE/FALSE NOT 逻辑非 NOT age = 25 TRUE/FALSE IS NULL 判断是否为 NULL address IS NULL TRUE/FALSE IS NOT NULL 判断是否不为 NULL address IS NOT NULL TRUE/FALSE LIKE 模糊匹配 name LIKE ‘J%’ TRUE/FALSE GLOB 全局匹配（区分大小写） name GLOB ‘J*’ TRUE/FALSE IN 判断是否在列表内 age IN (22, 30) TRUE/FALSE BETWEEN 判断是否在范围内 age BETWEEN 20 AND 30 TRUE/FALSE 例如：我们对前面的 COMPANY 表进行「逻辑运算符」的操作： 12345678910sqlite&gt; .mode columnsqlite&gt; select * from company;ID NAME AGE ADDRESS SALARY-- ----- --- ---------- -------1 Paul 32 California 20000.02 Allen 25 Texas 15000.03 Teddy 23 Norway 20000.04 Mark 25 Rich-Mond 65000.05 David 27 Texas 85000.06 Kim 22 South-Hall 45000.0 列出 AGE 大于等于 25 且工资大于等于 65000.00 的所有记录 12345sqlite&gt; SELECT * FROM COMPANY WHERE AGE &gt;= 25 AND SALARY &gt;= 65000;ID NAME AGE ADDRESS SALARY-- ----- --- ---------- -------4 Mark 25 Rich-Mond 65000.05 David 27 Texas 85000.0 列出 AGE 大于等于 25 或工资大于等于 65000.00 的所有记录 1234567sqlite&gt; SELECT * FROM COMPANY WHERE AGE &gt;= 25 OR SALARY &gt;= 65000;ID NAME AGE ADDRESS SALARY-- ----- --- ---------- -------1 Paul 32 California 20000.02 Allen 25 Texas 15000.04 Mark 25 Rich-Mond 65000.05 David 27 Texas 85000.0 列出 AGE 不为 NULL 的所有记录，结果显示所有的记录，意味着没有一个记录的 AGE 等于 NULL 123456789sqlite&gt; SELECT * FROM COMPANY WHERE AGE IS NOT NULL;ID NAME AGE ADDRESS SALARY-- ----- --- ---------- -------1 Paul 32 California 20000.02 Allen 25 Texas 15000.03 Teddy 23 Norway 20000.04 Mark 25 Rich-Mond 65000.05 David 27 Texas 85000.06 Kim 22 South-Hall 45000.0 列出 NAME 以 ‘Ki’ 开始的所有记录，’Ki’ 之后的字符不做限制 123456789sqlite&gt; SELECT * FROM COMPANY WHERE NAME LIKE 'Ki%';ID NAME AGE ADDRESS SALARY-- ---- --- ---------- -------6 Kim 22 South-Hall 45000.0sqlite&gt; SELECT * FROM COMPANY WHERE NAME GLOB 'Ki*';ID NAME AGE ADDRESS SALARY-- ---- --- ---------- -------6 Kim 22 South-Hall 45000.0 列出 AGE 的值为 23 或 27 的所有记录 12345sqlite&gt; SELECT * FROM COMPANY WHERE AGE IN ( 23, 27 );ID NAME AGE ADDRESS SALARY-- ----- --- ------- -------3 Teddy 23 Norway 20000.05 David 27 Texas 85000.0 列出 AGE 的值在 23 与 27 之间的所有记录 1234567sqlite&gt; SELECT * FROM COMPANY WHERE AGE BETWEEN 23 AND 27;ID NAME AGE ADDRESS SALARY-- ----- --- ---------- -------2 Allen 25 Texas 15000.03 Teddy 23 Norway 20000.04 Mark 25 Rich-Mond 65000.05 David 27 Texas 85000.0 4.4 位运算符用于对整数执行位操作。 位运算符 描述 示例 实例 &amp; 按位与如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中 60 &amp; 13 12 | 按位或如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中 60 | 13 61 ~ 按位取反二进制补码运算符是一元运算符，具有”翻转”位效应，即 0 变成 1，1 变成 0 ~60 -61 &lt;&lt; 二进制左移运算符左操作数的值向左移动右操作数指定的位数 60 &lt;&lt; 2 240 &lt;&lt; 二进制右移运算符左操作数的值向右移动右操作数指定的位数 60 &gt;&gt; 2 15 假设如果 A = 60，且 B = 13，现在以二进制格式，它们如下所示： 123456789101112A = 0011 1100B = 0000 1101-----------------A &amp; B = 0000 1100A | B = 0011 1101~ A = 1100 0011-----------------A &lt;&lt; 20011 1100 --&gt; 左移两位 --&gt; 1111 0000 -&gt; 240-----------------A &gt;&gt; 20011 1100 --&gt; 右移两位 --&gt; 0000 1111 -&gt; 15","link":"/2024/04/01/%E6%95%B0%E6%8D%AE%E5%BA%93%20--%20SQLite%20--%20%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"title":"解析 mutableStateOf 源码","text":"其实原理性分析的文章，真的很难讲的通俗易懂，讲的简单浅显没必要写，讲的繁琐难懂往往大家也不乐意看，所以怎么找个好的角度慢慢钻进去尤为重要，比如：Begin simple code，如果确实能帮助到大家完全理解了文章所讲述到的源码理论，那就点个赞吧！ 引入话题 正如我上面说的，直接讲原理太枯燥（你也会很懵），我喜欢从简单代码入手，带你一点点进入，现在开始。先看一个最简单的代码示例： 1234567891011121314class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // 这种定义变量的方式随处可见了 val name = mutableStateOf(&quot;Compose&quot;) setContent { ComposeBlogTheme { Text(name.value) } } }} 我先来简单解读一下这段代码的原理： 当我们定义一个变量，用 mutableStateOf 包起来后，它就变成了一个 MutableState 类型的对象。 同时，我们取值的话就必须要写 name.value，这样能才能取到 “Compose”，因为name 不再是一个 String，而是 MutableState 对象，也可以叫“状态” 。 此时，name 是一个被订阅的状态，name.value 就是一个被订阅的值，如果它发生变化，Text() 函数就会重新执行一遍，更新到最新的值。 现在我们修改下代码，3s 后改变 name.value 的值： 123456789101112131415161718class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val name = mutableStateOf(&quot;Compose&quot;) setContent { ComposeBlogTheme { Text(name.value) } LaunchedEffect(true) { delay(3000) // 3s 延迟 name.value = &quot;Kotlin&quot; // 修改 name.value } } }} 运行下： ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/141782121dd4b200a5d4e86a30eb3edf.gif =400x) 现在关于 mutableStateOf 的用法你已经掌握了，但同时就会产生了一个疑问，name 被自动订阅了，它的值改变了就会让界面重新刷新，这背后的“状态订阅&amp;刷新机制”的原理是什么？ 如果你想深入了解，那么接着往下看。 状态订阅&amp;自动刷新 基于 androidx.compose.runtime:runtime:1.4.0 版本 硬核部分走起，查看 mutableStateOf() 源码： 1234fun &lt;T&gt; mutableStateOf( value: T, policy: SnapshotMutationPolicy&lt;T&gt; = structuralEqualityPolicy()): MutableState&lt;T&gt; = createSnapshotMutableState(value, policy) mutableStateOf() 返回的是一个 MutableState 对象，这个我们前面说过。 mutableStateOf() 又调用了另一个函数：**createSnapshotMutableState()**。 进入 **createSnapshotMutableState()**： 1234internal actual fun &lt;T&gt; createSnapshotMutableState( value: T, policy: SnapshotMutationPolicy&lt;T&gt;): SnapshotMutableState&lt;T&gt; = ParcelableSnapshotMutableState(value, policy) 又调用了 ParcelableSnapshotMutableState() 函数： 1234567internal class ParcelableSnapshotMutableState&lt;T&gt;( value: T, policy: SnapshotMutationPolicy&lt;T&gt;) : SnapshotMutableStateImpl&lt;T&gt;(value, policy), Parcelable { // 这里内部的代码全部都是对 Parcelable 接口的实现，我们不用关心，不是核心内容 ... ...} 关键在 SnapshotMutableStateImpl，它里面才是最核心的逻辑： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788internal open class SnapshotMutableStateImpl&lt;T&gt;( value: T, override val policy: SnapshotMutationPolicy&lt;T&gt;) : StateObject, SnapshotMutableState&lt;T&gt; { @Suppress(&quot;UNCHECKED_CAST&quot;) override var value: T get() = next.readable(this).value set(value) = next.withCurrent { if (!policy.equivalent(it.value, value)) { next.overwritable(this, it) { this.value = value } } } private var next: StateStateRecord&lt;T&gt; = StateStateRecord(value) override val firstStateRecord: StateRecord get() = next override fun prependStateRecord(value: StateRecord) { @Suppress(&quot;UNCHECKED_CAST&quot;) next = value as StateStateRecord&lt;T&gt; } @Suppress(&quot;UNCHECKED_CAST&quot;) override fun mergeRecords( previous: StateRecord, current: StateRecord, applied: StateRecord ): StateRecord? { val previousRecord = previous as StateStateRecord&lt;T&gt; val currentRecord = current as StateStateRecord&lt;T&gt; val appliedRecord = applied as StateStateRecord&lt;T&gt; return if (policy.equivalent(currentRecord.value, appliedRecord.value)) current else { val merged = policy.merge( previousRecord.value, currentRecord.value, appliedRecord.value ) if (merged != null) { appliedRecord.create().also { (it as StateStateRecord&lt;T&gt;).value = merged } } else { null } } } override fun toString(): String = next.withCurrent { &quot;MutableState(value=${it.value})@${hashCode()}&quot; } private class StateStateRecord&lt;T&gt;(myValue: T) : StateRecord() { override fun assign(value: StateRecord) { @Suppress(&quot;UNCHECKED_CAST&quot;) this.value = (value as StateStateRecord&lt;T&gt;).value } override fun create(): StateRecord = StateStateRecord(value) var value: T = myValue } /** * The componentN() operators allow state objects to be used with the property destructuring * syntax * * ``` * var (foo, setFoo) = remember { mutableStateOf(0) } * setFoo(123) // set * foo == 123 // get * ``` */ override operator fun component1(): T = value override operator fun component2(): (T) -&gt; Unit = { value = it } /** * A function used by the debugger to display the value of the current value of the mutable * state object without triggering read observers. */ @Suppress(&quot;unused&quot;) val debuggerDisplayValue: T @JvmName(&quot;getDebuggerDisplayValue&quot;) get() = next.withCurrent { it }.value} 好长啊～算了，不看了🙈… 接下来我带你一步步探索其中的奥秘！ 先看开头部分： 12345678910111213141516171819internal open class SnapshotMutableStateImpl&lt;T&gt;( value: T, override val policy: SnapshotMutationPolicy&lt;T&gt;) : StateObject, SnapshotMutableState&lt;T&gt; { @Suppress(&quot;UNCHECKED_CAST&quot;) override var value: T get() = next.readable(this).value set(value) = next.withCurrent { if (!policy.equivalent(it.value, value)) { next.overwritable(this, it) { this.value = value } } } private var next: StateStateRecord&lt;T&gt; = StateStateRecord(value) override val firstStateRecord: StateRecord get() = next ... ...} 一个 value 属性印入眼帘，这就是文章开头代码里面用到的 name.value。 value 有 get() 和 set() 函数，并且都有具体的实现。 📓 next 是个啥？ 无论是 get() 还是 set() 都有一个 next。 12get() = next.readable(this).valueset(value) = next.withCurrent {...} 它是个啥？我们得先搞明白这个。 1private var next: StateStateRecord&lt;T&gt; = StateStateRecord(value) 它的类型是 StateStateRecord，那 StateStateRecord 有是个啥？ 12345678910private class StateStateRecord&lt;T&gt;(myValue: T) : StateRecord() { override fun assign(value: StateRecord) { @Suppress(&quot;UNCHECKED_CAST&quot;) this.value = (value as StateStateRecord&lt;T&gt;).value } override fun create(): StateRecord = StateStateRecord(value) var value: T = myValue} StateStateRecord 继承了 StateRecord，那 StateRecord 又是个啥呢？ 123456abstract class StateRecord { internal var snapshotId: Int = currentSnapshot().id // 记录快照 id internal var next: StateRecord? = null // 下一个状态记录的引用，状态记录存储在一个链表中 abstract fun assign(value: StateRecord) // 复制 StateRecord abstract fun create(): StateRecord // 创建一个新的记录相同的 StateRecord} 你只要知道 StateRecord 是一个链表的数据结构即可，而 StateStateRecord 实现了它，并且将 value 进行了封装。 下面我们要讲别的了，先记住：StateRecord 是一个链表的数据结构！ 接着说，如果你仔细看代码的话，会发现 SnapshotMutableStateImpl 其实继承了两个接口： 123456internal open class SnapshotMutableStateImpl&lt;T&gt;( value: T, override val policy: SnapshotMutationPolicy&lt;T&gt;) : StateObject, SnapshotMutableState&lt;T&gt; { ... ...} 一个 StateObjet、一个 SnapshotMutableState。 我们先来看下 SnapshotMutableState： 123456interface SnapshotMutableState&lt;T&gt; : MutableState&lt;T&gt; { /** * A policy to control how changes are handled in a mutable snapshot. */ val policy: SnapshotMutationPolicy&lt;T&gt;} SnapshotMutableState 继承了 MutableState，正好对应着我们文章开头说的，mutableStateOf() 返回的就是一个 MutableState，我们说是因为它实现了订阅从而可以刷新，但！！！真正的原因并不是因为它！ 真正实现状态订阅机制的是另外一个接口：StateObjet！ 我们现在来看下 StateObject 这个大佬干了什么事： 1234567891011121314interface StateObject { /** * The first state record in a linked list of state records. */ val firstStateRecord: StateRecord fun prependStateRecord(value: StateRecord) fun mergeRecords( previous: StateRecord, current: StateRecord, applied: StateRecord ): StateRecord? = null} 代码非常简单，但里面有一个核心： 1val firstStateRecord: StateRecord 它是干嘛用的？我们去瞅瞅哪里用了它： 1234private var next: StateStateRecord&lt;T&gt; = StateStateRecord(value) override val firstStateRecord: StateRecord get() = next 哦，原来 firstStateRecord 是用来记录 StateRecord 这个链表的 头节点 用的。 📓 get() 上面应该算是把 next 是什么讲清楚了吧？– 它就是 StateRecord，更准确的说就是 StateRecord 链表的头节点。 下面我们开始扒扒 get() 具体的逻辑了。 1get() = next.readable(this).value 进入 readable() ： 1234567891011fun &lt;T : StateRecord&gt; T.readable(state: StateObject): T { val snapshot = Snapshot.current // 第一件事 snapshot.readObserver?.invoke(state) // 第二件事 return readable(this, snapshot.id, snapshot.invalid) ?: sync { val syncSnapshot = Snapshot.current @Suppress(&quot;UNCHECKED_CAST&quot;) readable(state.firstStateRecord as T, syncSnapshot.id, syncSnapshot.invalid) ?: readError() }} 干了两件事，第一件事： 1snapshot.readObserver?.invoke(state) // 第一件事 readObserver 是一个读操作的观察者，这个操作是记录 StateObject 中的值被哪里调用了，比如开头的代码示例： 1234567891011121314151617181920class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val name = mutableStateOf(&quot;Compose&quot;) setContent { ComposeBlogTheme { // 这里调用了 name.value，就会执行到： // get() --&gt; readServer() --&gt; 记录这里调用了 value 值 Text(name.value) } LaunchedEffect(true) { delay(3000) name.value = &quot;Kotlin&quot; } } }} 所以，我们可以把这个操作理解为它是一个订阅操作：订阅状态，记录 name.value 在哪里调用了。 第二件事： 12345return readable(this, snapshot.id, snapshot.invalid) ?: sync { val syncSnapshot = Snapshot.current @Suppress(&quot;UNCHECKED_CAST&quot;) readable(state.firstStateRecord as T, syncSnapshot.id, syncSnapshot.invalid) ?: readError()} 调用了三参数的 readable()： 1234567891011121314151617private fun &lt;T : StateRecord&gt; readable(r: T, id: Int, invalid: SnapshotIdSet): T? { // The readable record is the valid record with the highest snapshotId var current: StateRecord? = r var candidate: StateRecord? = null while (current != null) { if (valid(current, id, invalid)) { candidate = if (candidate == null) current else if (candidate.snapshotId &lt; current.snapshotId) current else candidate } current = current.next } if (candidate != null) { @Suppress(&quot;UNCHECKED_CAST&quot;) return candidate as T } return null} 前边我们说错：StateRecord 是一个链表，三参数里面的工作就是通过表头对象遍历列表来获取 最新的、有效的 StateRecord。 最终返回一个 最新的、有效的 StateRecord。（什么是最新的、有效的，这个可以不用关心，这跟要结合 Snapshot 快照系统说，你直接过滤即可，不影响我们原理的理解） 所以，整个 readable() 方法就干了两件事： 返回最新的、有效的 StateRecord 记录在哪里调用了 value 1get() = next.readable(this).value 最后还剩一个 value，这就很简单了，前面我们说过 StateStateRecord (StateRecord 的实现类) 会对 value 进行封装，而 StateRecord 它们只是一个链表，我们要获取到值，就要再调用 value 获取内部被包着的值。 到这里 get() 就讲完了！ 📓 set() 现在来看 set() 的具体代码：（细节点注意：这边我把代码截图了，而不是纯代码段，你留意一下，下面会回归到这里） ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/548aff88360d4dffda83386ed2ee80e3.png =500x) next 是啥不用说了吧，那 withCurrent 是什么？ 12inline fun &lt;T : StateRecord, R&gt; T.withCurrent(block: (r: T) -&gt; R): R = block(current(this, Snapshot.current)) 它只有一个参数 block，而 block 是一个函数类型的参数，它的工作很直接，直接调用这个函数类型的参数，也就是 withCurrent 后面跟着的 Lambda 表达式。 ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/63c3c244bd0959768487d28c00ed08ca.png =500x) block 里面传入了一个 current 函数，它做了什么： 12internal fun &lt;T : StateRecord&gt; current(r: T, snapshot: Snapshot) = readable(r, snapshot.id, snapshot.invalid) ?: readError() 发现了什么？它调用了一个三参数的 readable()，你还记得三参数的 readable() 是做什么的吗？ ⇒ 获取 最新的、有效的 StateRecord。 这个时候你在看下我开头为啥对代码做了截图： ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/df81d16a784a74cbb297037fdce6eda0.png =500x) 懂啥意思没？withCurrent 传入的 current 函数的返回值就对应着代码提示器提示的 it 对象（一个 StateStateRecord）。 接着看代码： 123456set(value) = next.withCurrent { // 判断新旧值 if (!policy.equivalent(it.value, value)) { next.overwritable(this, it) { this.value = value } }} if 判断里面会判断取到的 StateRecord 的值和新设置的值是否相同，没变直接结束，变了就进入下一步 overwritable()。 我们看看它做了什么： 123456789101112131415internal inline fun &lt;T : StateRecord, R&gt; T.overwritable( state: StateObject, candidate: T, block: T.() -&gt; R): R { var snapshot: Snapshot = snapshotInitializer return sync { // 第一件事 snapshot = Snapshot.current // 第二件事 this.overwritableRecord(state, snapshot, candidate).block() }.also { notifyWrite(snapshot, state) }} 也干了两件事： 获取快照；2. 调用了overwritableRecord() 函数； Snapshot 快照的知识我们可以先忽略，来看 overwritableRecord() 做了什么： 12345678910111213141516171819internal fun &lt;T : StateRecord&gt; T.overwritableRecord( state: StateObject, snapshot: Snapshot, candidate: T): T { if (snapshot.readOnly) { snapshot.recordModified(state) } val id = snapshot.id if (candidate.snapshotId == id) return candidate val newData = newOverwritableRecord(state) newData.snapshotId = id snapshot.recordModified(state) return newData} 这段代码又涉及到了另外一个知识点：Snapshot（快照）。 我们将代码分为两端来看： ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/9b9068d1ad9357f3b556a0a502884f0c.png =700x) 核心代码块 1：如果传进来的 StateRecord 的快照 id 正好对应当前 snapshot 的 id，那么直接返回。 核心代码块 2：否则会创建一个新的或者返回一个弃用的 StateRecord，然后将快照 id 赋予新的 StateRecord。 说白了最终就是要取到一个对应当前 snapshot 的 StateRecord！ 🤔 此时就存在一个很大的疑问了？什么是 Snapshot（快照）？Snapshot 怎么和 StateRecord 绑在一起了？ 关于 Compose 的 Snapshot 机制，可以看看这篇文章 揭秘 Jetpack Compose快照系统 ，讲的很好。 但由于 Snapshot 真的不是一两句就能说清楚的，但我仍然告诉你它不影响你对这篇文章原理的理解。 继续回到代码： 1234567891011121314internal inline fun &lt;T : StateRecord, R&gt; T.overwritable( state: StateObject, candidate: T, block: T.() -&gt; R): R { var snapshot: Snapshot = snapshotInitializer return sync { snapshot = Snapshot.current // 取到一个对应当前 snapshot 的 StateRecord this.overwritableRecord(state, snapshot, candidate).block() }.also { notifyWrite(snapshot, state) }} 取到对应当前 snapshot 的 StateRecord 后，紧接着调用了 block()，它是传进来的参数，是外面传进来的，也就是 {this.value = value}。 123456set(value) = next.withCurrent { // 判断新旧值 if (!policy.equivalent(it.value, value)) { next.overwritable(this, it) { this.value = value } }} 又拐回来了，把传入的新值赋值给拿到的 StateRecord 内部的 value，这不就是写新值的操作么？ 到这里是不是 set() 流程是不是我们就讲完了？ No～，我们再看一下 overwritable() 方法内部： 1234567891011121314internal inline fun &lt;T : StateRecord, R&gt; T.overwritable( state: StateObject, candidate: T, block: T.() -&gt; R): R { var snapshot: Snapshot = snapshotInitializer return sync { snapshot = Snapshot.current // 这里讲完了 this.overwritableRecord(state, snapshot, candidate).block() }.also { notifyWrite(snapshot, state) // 但这里还有个 notifyWrite }} 还有一行我们遗漏了，notifyWrite() 又做了什么？ 123internal fun notifyWrite(snapshot: Snapshot, state: StateObject) { snapshot.writeObserver?.invoke(state)} 有种似曾相识的感觉，在前面分析 get() 函数的时候，我们看到过单参数的 readable() 里面有一行： 1snapshot.readObserver?.invoke(state) 那这里的作用呢？ ⇒ 寻找变量在哪里被读了，然后将这部分内容的组合标记为失效，等到下一帧的时候会重组刷新。 所以，整个 set() 方法就干了两件事： 将传入的值赋值给 StateRecord 内部的 value 写入通知刷新 到这里我们就基本上能够很清晰的明白了状态订阅&amp;自动刷新机制的原理了： 当 get() 被调用的时候，不仅返回值，还会记录读值的地方，也就是哪里调用了（相当于订阅）。 当 set() 被调用的时候，不仅修改值，还会查找读值的地方，然后进行刷新操作（相当于通知）。 📓 by 在实际开发中，如果每次获取值都要加上 value 会显得很冗余，所以 Compose 给我们提供了一种更方便的写法：by。它是 Kotlin 的一个关键字，表示左边的变量用右边的对象作为代理（委托）。 12345678910111213class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val name by mutableStateOf(&quot;Compose&quot;) setContent { ComposeBlogTheme { Text(name) // 可以直接 name，而不需要 name.value } } }} 如果你这么写，IDLE 会提示报错，因为 name 委托给了 mutableStateOf，如果我们要获取 name 的值，那委托对象需要调用 getValue() 和 setValue() 两个函数，这两个函数需要自己实现。 但实际上并不需要我们实现，你通过提示也可以看出来，我们可以直接导入，因为 Compose 内部已经帮我们实现好了这个方法。 12import androidx.compose.runtime.getValueimport androidx.compose.runtime.setValue 自此，关于 Compose 的状态订阅&amp;自动刷新机制的原理算是讲明白了吧…","link":"/2024/07/05/Compose%20--%20%E7%8A%B6%E6%80%81%E8%AE%A2%E9%98%85%20&%20%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%20--%20%E8%A7%A3%E6%9E%90%20mutableStateOf%20%E6%BA%90%E7%A0%81/"},{"title":"有状态、无状态、状态提升","text":"Jekpack Compose “状态订阅&amp;自动刷新” 系列： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;【 聊聊 Jetpack Compose 的 “状态订阅&amp;自动刷新” - - MutableState/mutableStateOf 】 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;【 聊聊 Jetpack Compose 的 “状态订阅&amp;自动刷新” - - remember 和重组作用域 】 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;【 聊聊 Jetpack Compose 的 “状态订阅&amp;自动刷新” - - 有状态、无状态、状态提升？】 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;【 聊聊 Jetpack Compose 的 “状态订阅&amp;自动刷新” - - mutableStateListOf 】 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;【 聊聊 Jetpack Compose 的 “状态订阅&amp;自动刷新” - - 你真的了解重组吗？】 先来看两段 Compose 的官方描述： 利用 Compose，您可以构建不与特定 activity 或 fragment 相关联的小型 无状态组件。这让您可以轻松重用和测试这些组件：“我们给自己设定的目标是，交付一组新的无状态界面组件，确保它们易于使用和维护，且可直观实现/扩展/自定义。就这一点而言，Compose 确实为我们提供了一个可靠的答案。”(Twitter) 使用 remember 存储对象的可组合项包含 内部状态，这会使该可组合项 有状态。在调用方不需要控制状态，并且不必自行管理状态便可使用状态的情况下，“有状态”会非常有用。但是，具有内部状态的可组合项往往不易重复使用，也更难测试。 所以我们可以抛出三个问题： 什么是无状态？ 什么是优状态？ 什么又是内部状态？ 带着这三个问题，我们开始探讨 Compose 中的状态。 无状态状态是什么？在传统 Android 中，比如 TextView，它的状态就是内部的属性，比如我们可以通过 getText() 获取 TextView 的文字，setText() 设置 TextView 的文字。 那么看下面的代码示例： 12345678910class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { val name = &quot;Hi, Compose&quot; Text(name) } }} 那么 Text() 组件在这里能像 TextView() 一样既能 getText() 也能 setText() 吗？很明显不能，Text(name) 只是用了 name，并没有保存，所以它是一个 无状态组件！ 有状态现在我们自定义一个 Compose 函数（组合项）： 12345@Composablefun HiCompose() { val name = &quot;Hi, Compose&quot; Text(name)} Text() 有状态吗？– 没有，那 HiCompose() 呢？– 有！它的内部有一个它自己的变量：Hi, Compose，准确的来说，它是有 内部状态 的。 所以，Compose 组件是可以有状态，也可以无状态，而所谓的状态是指：内部状态！ 状态提升思考一个问题，既然 HiCompose() 函数是有内部状态的，那我如果想从外部获取它的内部状态，该如何做？比如： 123456789101112131415class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { HiCompose().name ??? // 这里如何获取到 HiCompose 内部的 name? } }}@Composablefun HiCompose() { val name = &quot;Hi, Compose&quot; Text(name)} 这就相当于你要从外部获取一个函数内部的变量，是获取不到的，那如何做呢？ 123456789101112131415class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { val name = &quot;Hi, Compose&quot; HiCompose(name) } }}@Composablefun HiCompose(name: String) { Text(name)} 你可以很清楚的发现，我们把 HiCompose() 内部状态给提到参数里面，然后外部就可以传入状态，两者就联系起来了。 在 Compose 中这种做法就叫做：状态提示（State Hoisting）。 此时 HiCompose 还有状态吗？- - 无状态！因为它已经没有内部状态了，状态上提到外面去了。 输入框：TextFieldCompose 有一个典型的状态提升的组件示例：TextField，它是一个文本输入框，类似于 EditText。 123456789class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { TextField(value = , onValueChange = ) } }} 其中 value 就是从 TextField 内部提升上来的，来给它传个值： 12345678910class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { var name = &quot;&quot; TextField(name, onValueChange = ) } }} onValueChange 是一个函数类型的参数，可以写出 Lambda 表达式。 12345678910111213class MainActivity : ComponentActivity() { @OptIn(ExperimentalMaterial3Api::class) override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { var name = &quot;&quot; TextField(name, { }) } }} 此时什么也没填，运行看下效果： 键盘输入了，但是输入框没有任何内容，问题肯定出在 onValueChange，因为我们什么也没填，那填什么？ 12345678910111213class MainActivity : ComponentActivity() { @OptIn(ExperimentalMaterial3Api::class) override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { var name = &quot;&quot; TextField(name, { newValue -&gt; name = newValue }) } }} 这就这么简单，newValue 就是输入的内容，把 newValue 赋值给 name，name 才是输入框显示的内容实际值。 运行看下效果： ？？？怎么还不行？如果你看了之前的文章，应该能找到问题点在哪！ ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/d4bcd805bdb40c9231a7442e1c80d288.png =500x) 懂的都懂，我们修改下代码： 12345678910111213class MainActivity : ComponentActivity() { @OptIn(ExperimentalMaterial3Api::class) override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { var name by remember { mutableStateOf(&quot;&quot;) } TextField(name, { newValue -&gt; name = newValue }) } }} 运行：","link":"/2024/07/13/Compose%20--%20%E7%8A%B6%E6%80%81%E8%AE%A2%E9%98%85%20&%20%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%20--%20%E6%9C%89%E7%8A%B6%E6%80%81%E3%80%81%E6%97%A0%E7%8A%B6%E6%80%81%E3%80%81%E7%8A%B6%E6%80%81%E6%8F%90%E5%8D%87/"}],"tags":[{"name":"Compose","slug":"Compose","link":"/tags/Compose/"},{"name":"状态订阅 &amp; 自动更新","slug":"状态订阅-自动更新","link":"/tags/%E7%8A%B6%E6%80%81%E8%AE%A2%E9%98%85-%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0/"},{"name":"mutableStateOf","slug":"mutableStateOf","link":"/tags/mutableStateOf/"},{"name":"mutableStateListOf","slug":"mutableStateListOf","link":"/tags/mutableStateListOf/"},{"name":"remember","slug":"remember","link":"/tags/remember/"},{"name":"重组作用域","slug":"重组作用域","link":"/tags/%E9%87%8D%E7%BB%84%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"name":"Compose 动画","slug":"Compose-动画","link":"/tags/Compose-%E5%8A%A8%E7%94%BB/"},{"name":"animate*AsState()","slug":"animate-AsState","link":"/tags/animate-AsState/"},{"name":"Animatable()","slug":"Animatable","link":"/tags/Animatable/"},{"name":"重组","slug":"重组","link":"/tags/%E9%87%8D%E7%BB%84/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SQLite","slug":"SQLite","link":"/tags/SQLite/"},{"name":"Compose 状态","slug":"Compose-状态","link":"/tags/Compose-%E7%8A%B6%E6%80%81/"}],"categories":[{"name":"Compose","slug":"Compose","link":"/categories/Compose/"},{"name":"状态订阅 &amp; 自动更新","slug":"Compose/状态订阅-自动更新","link":"/categories/Compose/%E7%8A%B6%E6%80%81%E8%AE%A2%E9%98%85-%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0/"},{"name":"动画","slug":"Compose/动画","link":"/categories/Compose/%E5%8A%A8%E7%94%BB/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SQLite","slug":"数据库/SQLite","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/SQLite/"}],"pages":[]}