{"posts":[{"title":"解析 Modifier &amp; CombinedModifier","text":"基于 androidx.compose.runtime:runtime:1.7.1 版本 什么是 Modifier ？ 当你想深入了解 Modifier 的时候，你应该已经在实际代码中用起来了，因为随处可见各种 Modifier，比如： 12345678Modifier.size() // 尺寸Modifier.width() // 宽度Modifier.height() // 高度Modifier.padding() // 间距Modifier.background() // 背景Modifier.clip() // 裁切Modifier.clickable() // 点击... ... 那么你有没有思考过一个问题：这个像根部（起点）一样的 Modifier 是个啥？ 我们来看下它的定义： 12345678910111213141516📄 androidx.compose.ui.Modifier.ktinterface Modifier { // 重点：申明一个 Modifier 的伴生对象（单例对象） companion object : Modifier { // 里面全部都是最简单的实现，这里面的方法我们后面会详细了解到，暂时不用关心 override fun &lt;R&gt; foldIn(initial: R, operation: (R, Element) -&gt; R): R = initial override fun &lt;R&gt; foldOut(initial: R, operation: (Element, R) -&gt; R): R = initial override fun any(predicate: (Element) -&gt; Boolean): Boolean = false override fun all(predicate: (Element) -&gt; Boolean): Boolean = true override infix fun then(other: Modifier): Modifier = other override fun toString() = &quot;Modifier&quot; }} 所以如果你单写一个 Modifier，就可以获取到一个最简单的 Modifier 接口的对象（即伴生对象），它的作用就是作为一个起点用于链式调用。 OK，现在我们来看一段简单的代码： 12345678910111213141516class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Custom() } } }}@Composablefun Custom() { Box(Modifier.size(40.dp).background(Color.Blue)) {}} 这里我们自定义了一个 Composable 函数 custom()，内部就是一个 Box，同时对 Box 添加了尺寸和背景。 效果如下： 现在我们定义的这个 Custom() 就是一个通用的可组合函数，如果现在我希望外部调用这个 Custom 函数的时候可以从外部去改变 Box 的透明度，该怎么写？ 我们可能会很自然的写出下面的代码： 12345678910111213141516class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Custom(modifier = Modifier.alpha(0.5f)) } } }}@Composablefun Custom(modifier: Modifier) { Box(modifier.size(40.dp).background(Color.Blue)) {}} 这段代码不难理解吧？效果如下： 我们可以给 Custom() 加一个 Modifier 类型的参数，这样外部就可以通过传入一个 Modifier 来修改 Box 的尺寸了。 但是这就会存在一个问题：现在外部调用 custom() ，就必须传入一个 Modifier，这就不合理了，相当于强制要求外部必须加这个 Modifier 参数，所以针对这种情况，我们一般会像下面这么写： 1234567891011121314151617class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Custom(modifier = Modifier.alpha(0.5f)) // 传了，custom 就用传入的 Modifier Custom() // 不传，custom 就用默认的 Modifier } } }}@Composablefun Custom(modifier: Modifier = Modifier) { // 设定一个默认的 Modifier，作为一个占位符使用 Box(modifier.size(40.dp).background(Color.Blue)) {}} 现在是不是就能解决我们前面的问题了？ 请记住：这是一个很标准的写法！ 为什么说是一个标准写法呢？ 我们看下 Box 的源码定义： 1234567@Composableinline fun Box( modifier: Modifier = Modifier, // 这里 contentAlignment: Alignment = Alignment.TopStart, propagateMinConstraints: Boolean = false, content: @Composable BoxScope.() -&gt; Unit) 再换一个 Button 看看： 1234567@Composablefun Button( onClick: () -&gt; Unit, modifier: Modifier = Modifier, // 这里 enabled: Boolean = true, ... ...) 再换一个 Column 看看： 1234567@Composableinline fun Column( modifier: Modifier = Modifier, // 这里 verticalArrangement: Arrangement.Vertical = Arrangement.Top, horizontalAlignment: Alignment.Horizontal = Alignment.Start, content: @Composable ColumnScope.() -&gt; Unit) Compose 默认提供的函数的参数也是这种标准写法，所以以后我们写自定义的 Compose 函数，按照这种标准写法就会很方便。 Modifier 链 所谓的「 Modifier 链 」其实就是类似「 Modifier.padding().background() 」这样的链式调用。在实际开发过程中，这种链式调用对顺序的敏感度还是很强的，不同的调用顺序显示出来的结果会完全不一样。 接下来我们结合实际代码深入分析 Modifier 链的创建步骤。 1234567891011class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.background(Color.Blue)) } } }} 前面你应该知道了 Modifier 是什么了，它就相当于一个白板，现在我们来看看 Modifier.background() 做了什么： 123456789101112131415161718192021📄 androidx.compose.foundation.Background.ktfun Modifier.background( color: Color, shape: Shape = RectangleShape): Modifier { val alpha = 1.0f // for solid colors return this.then( // this：就是 Modifier，这里又调用了 then() BackgroundElement( color = color, shape = shape, alpha = alpha, inspectorInfo = debugInspectorInfo { name = &quot;background&quot; value = color properties[&quot;color&quot;] = color properties[&quot;shape&quot;] = shape } ) )} 我们可以发现 Modifier.backgroud 实际上又调用了 this.then(BackgroundElement())，此时 this 指针指向的是伴生对象 Modifier，接下来我们看看 then() 做了什么。 12345678📄 androidx.compose.ui.Modifier.ktinterface Modifier { infix fun then(other: Modifier): Modifier = if (other === Modifier) this else CombinedModifier(this, other) } 可以看到 then() 是有参数的，它的参数也是一个 Modifier 类型的，所以传递进来的 BackgroundElement() 也是一个 Modifier 吗？ 我们来看下它的定义： 123456789📄 androidx.compose.foundation.Background.ktprivate class BackgroundElement( private val color: Color = Color.Unspecified, private val brush: Brush? = null, private val alpha: Float, private val shape: Shape, private val inspectorInfo: InspectorInfo.() -&gt; Unit) : ModifierNodeElement&lt;BackgroundNode&gt;() {} 123📄 androidx.compose.ui.node.ModifierNodeElement.ktabstract class ModifierNodeElement&lt;N : Modifier.Node&gt;: Modifier.Element, InspectableValue {} 123📄 androidx.compose.ui.Modifier.ktinterface Element : Modifier {} 回归主题，现在我们再来看看 then() 的作用：它主要负责把调用的 Modifier（左边）和参数传入的 Modifier（右边）进行合并的。 1. if (other === Modifier) this 如果参数是一个最基本的 Modifier 伴生对象：companion object，则返回自己，即调用者。 比如我这么写： 123Box(Modifier.background(Color.Blue).then(Modifier))==&gt;就会直接返回 Box(Modifier.background(Color.Blue) 自身 那我们例子里的 Modifier.background() 返回的是什么呢？ 1234567891011121314151617Box(Modifier.background(Color.Blue))/** * 此时 then(Background()) 很明显不满足 other === Modifier 的条件 * 所以根据判断条件： * if (other === Modifier) this else CombinedModifier(this, other) * 此时应该走到 else 分支，执行 CombinedModifier(this, other) * * 是吗？ 🤔🤔🤔🤔🤔🤔🤔 * * 我们来回顾一下 Modifier 这个伴生对象，如果你够仔细的话，应该注意到了： * 它内部覆写了 then() 方法 */companion object : Modifier { ... override infix fun then(other: Modifier): Modifier = other} Modifier 内部对 then() 的操作极其简单：你传进来什么，我就给你返回什么！ 所以 Modifier.background() 这种调用方本身就是一个伴生对象的情况，会走到它自己内部的 then() 方法，返回的是 BackgroundElement() 自身。 此时 Modifier 链的数据结构如下： 如果“调用者”和“传进来的参数”都不是 Modifier 伴生对象的话，就会走到下面一个条件。 2. else CombinedModifier(this, other) 调用 CombinedModifier() 进行两个 Modifier 的融合，并返回 CombinedModifier 自身。 比如我们现在再添加一个尺寸： 1Box(Modifier.background(Color.Blue).size(40.dp)) 查看 size() 函数： 12345678910111213141516📄 androidx.compose.foundation.layout.Size.kt@Stablefun Modifier.size(size: Dp) = this.then( SizeElement( minWidth = size, maxWidth = size, minHeight = size, maxHeight = size, enforceIncoming = true, inspectorInfo = debugInspectorInfo { name = &quot;size&quot; value = size } )) 这个时候的 this 就是 BackgroudElement 了，而 then() 内部的参数又是一个 SizeElement，所以就要用到 CombinedModifier 进行融合了。 我们来看下 CombinedModifier： 123456📄 androidx.compose.ui.Modifier.ktclass CombinedModifier( internal val outer: Modifier, internal val inner: Modifier) : Modifier {} CombinedModifier 具体怎么融合的，我们先不需要关注，下面会讲。 我们这里主要关注它的两个参数：「 outer 」 和 「 inner 」! 所以：BackgroudElement 是 outer，SizeElement 是 inner ！ 此时 Modifier 链的数据结构如下： 现在我们再添加一个边距： 1Box(Modifier.background(Color.Blue).size(40.dp).padding(10.dp)) 查看 padding() 函数： 1234567891011121314📄 androidx.compose.foundation.layout.Padding.kt@Stablefun Modifier.padding(all: Dp) = this then PaddingElement( start = all, top = all, end = all, bottom = all, rtlAware = true, inspectorInfo = { name = &quot;padding&quot; value = all }) 这个时候的 this 指向的是 CombinedModifier 实例，而 then() 内部的参数又是一个 PaddingElement，所以又要用到 CombinedModifier 进行融合了。 此时 Modifier 链的数据结构如下： 到这里，你有没有发现？Modifier 链条内部都有一个 then() 作为最外层调用，它就相当于一个套子，打造一个一环套一环的链条。 CombinedModifier 现在我们开始正式研究 CombinedModifier 的源码本质！ 1234class CombinedModifier( internal val outer: Modifier, internal val inner: Modifier) : Modifier 前面我们知道了：CombinedModifier 连接的两个 Modifier 分别存储在 outer 与 inner，而 Compose 对 Modifier 的遍历，其实就是从外（outer）到内（inner）一层层访问的。 需要注意的是， outer 与 innner 字段都被 internal 关键字申明，意味着不能被外部模块直接访问，但官方为我们提供了 foldOut() 与 foldIn() 专门用来遍历 Modifier 链。 123456789101112131415161718192021222324252627📄 androidx.compose.ui.Modifier.ktclass CombinedModifier( internal val outer: Modifier, internal val inner: Modifier) : Modifier { override fun &lt;R&gt; foldIn(initial: R, operation: (R, Modifier.Element) -&gt; R): R = inner.foldIn(outer.foldIn(initial, operation), operation) // 正向遍历 override fun &lt;R&gt; foldOut(initial: R, operation: (Modifier.Element, R) -&gt; R): R = outer.foldOut(inner.foldOut(initial, operation), operation) // 反向遍历 override fun any(predicate: (Modifier.Element) -&gt; Boolean): Boolean = outer.any(predicate) || inner.any(predicate) // 或运算 override fun all(predicate: (Modifier.Element) -&gt; Boolean): Boolean = outer.all(predicate) &amp;&amp; inner.all(predicate) // 与运算 override fun equals(other: Any?): Boolean = other is CombinedModifier &amp;&amp; outer == other.outer &amp;&amp; inner == other.inner override fun hashCode(): Int = outer.hashCode() + 31 * inner.hashCode() override fun toString() = &quot;[&quot; + foldIn(&quot;&quot;) { acc, element -&gt; if (acc.isEmpty()) element.toString() else &quot;$acc, $element&quot; } + &quot;]&quot;} 例如我们之前写的 Modifier 链： 1Modifier.background(Color.Blue).size(40.dp).padding(10.dp) foldIn()：正向遍历 Modifier 链&nbsp;BackgroundElement -&gt; SizeElement -&gt; PaddingElement foldOut()：反向遍历 Modifier 链&nbsp;PaddingElement -&gt; SizeModifier -&gt; BackgroundElement foldIn() 解析 你应该也发现了，CombinedModifier 本身就是 Modifier 接口的实现类，它内部的 foldIn、foldOut 都是覆写了其父接口 Modifier 的内部方法，所以我们可以先来看看 Modifier 的 foldIn（因为它更简单）： 123interface Modifier { fun &lt;R&gt; foldIn(initial: R, operation: (R, Element) -&gt; R): R} 让我们分析一下这个 foldIn 函数： fun &lt;R&gt;：这是一个泛型函数，类型参数 R 表示结果的类型。 initial: R：作为累积操作的初始值，foldIn 从这个值开始，并在每次操作中更新它。 operation: (R, Element) -&gt; R：这是一个 lambda 表达式参数，它接受当前的累积值和修饰符链中的当前元素 Element，然后返回新的累积值。这个 lambda 表达式会被应用于修饰符链中的每一个元素。 举个例子，比如说我们希望统计 Modifier 链中 Modifier 的数量： 123456789val modifier = Modifier .background(Color.Blue) .size(40.dp) .padding(10.dp)val result = modifier.foldIn&lt;Int&gt;(0) { currentIndex, element -&gt; println(&quot;@@@ index: $currentIndex , element :$element&quot;) currentIndex + 1}println(&quot;@@@ result = $result&quot;) 看不懂？那我们直接看 Log： 1234@@@ index: 0 , element :androidx.compose.foundation.BackgroundElement@52227b59@@@ index: 1 , element :androidx.compose.foundation.layout.SizeElement@780004cf@@@ index: 2 , element :androidx.compose.foundation.layout.PaddingElement@b80004cf@@@ result = 3 看完最简单的 foldIn 函数，我们再来看 CombinedModifier 的 foldIn 函数： 123456// Modifier 接口的 foldIn 函数fun &lt;R&gt; foldIn(initial: R, operation: (R, Element) -&gt; R): R// Combinedmodifier 覆写的 foldIn 函数override fun &lt;R&gt; foldIn(initial: R, operation: (R, Modifier.Element) -&gt; R): R = inner.foldIn(outer.foldIn(initial, operation), operation) 看不懂是么？不急，你先来想想 Modifier 链条经过 CombinedModifier 转换后，是不是下面这个样子： 123456789101112131415161718192021222324252627Modifier.background(Color.Blue).size(40.dp).padding(10.dp)// 分步骤拆解1. Modifier.background(Color.Blue) ==&gt; 等同于 Modifier.then(Modifier.background()) ==&gt; Modifier.background()2. Modifier.background(Color.Blue).size(40.dp) ==&gt; 等同于 Modifier.background().then(Modifier.size()) ==&gt; 等同于 CombinedModifier [ outer: Modifier.background(), inner: Modifier.size() ]3. Modifier.background(Color.Blue).size(40.dp).padding(10.dp) ==&gt; 等同于 Modifier.background().then(Modifier.size()).then(Modifier.padding()) ==&gt; 等同于 CombinedModifier [ outer: CombinedModifier [ outer: Modifier.background(), inner: Modifier.size() ], inner: Modifier.padding() ] 再看个示例图，可能会更直观点： 现在再看 CombinedModifier 的 foldIn 函数： 12override fun &lt;R&gt; foldIn(initial: R, operation: (R, Modifier.Element) -&gt; R): R = inner.foldIn(outer.foldIn(initial, operation), operation) 在这个 foldIn 实现中，可以看到处理修饰符链的过程是递归的和分层的。让我们逐步解析这个函数： initial: R：是累积操作的初始值。 operation: (R, Modifier.Element) -&gt; R：是一个应用于每一个 Modifier.Element 的高阶函数，它接受两个参数：当前的累积值和 Modifier 的一个元素，并返回新的累积值。 inner.foldIn(outer.foldIn(initial, operation), operation)：将上一步的结果作为它的初始值，并在 inner 修改器链上执行相同的 operation 函数。 感觉好复杂啊，没关系不慌，看图： 到这里我们再来回顾下刚才统计 Modifier 数量的例子： 123456789val modifier = Modifier .background(Color.Blue) .size(40.dp) .padding(10.dp)val result = modifier.foldIn&lt;Int&gt;(0) { currentIndex, element -&gt; println(&quot;@@@ index: $currentIndex , element :$element&quot;) currentIndex + 1}println(&quot;@@@ result = $result&quot;) Log 如下： 1234@@@ index: 0 , element :androidx.compose.foundation.BackgroundElement@52227b59@@@ index: 1 , element :androidx.compose.foundation.layout.SizeElement@780004cf@@@ index: 2 , element :androidx.compose.foundation.layout.PaddingElement@b80004cf@@@ result = 3 现在是不是就能毫无压力的看明白了？再来一张图： foldOut() 解析 与 foldIn() 相反， 我们就不再单独展开分析它的参数了，还是以前面统计 Modifier 个数的例子看下 Log 输出： 1234567891011val modifier = Modifier .background(Color.Blue) .size(40.dp) .padding(10.dp)val result = modifier.foldOut&lt;Int&gt;(0) { element, currentIndex -&gt; println(&quot;@@@ index: $currentIndex , element :$element&quot;) currentIndex + 1}println(&quot;@@@ result = $result&quot;) 看下 Log： 1234@@@ index: 0 , element :androidx.compose.foundation.layout.PaddingElement@b80004cf@@@ index: 1 , element :element :androidx.compose.foundation.layout.SizeElement@780004cf@@@ index: 2 , element :element :androidx.compose.foundation.BackgroundElement@52227b59@@@ result = 3 是不是反过来的？另外注意 lambda 表达式内部的参数位置与 foldIn() 是反着来的，其它没有任何区别。 Modifier.Element 在 Modifier 整个体系里面，有很多 Modifier 接口的子接口和实现类，除了我们之前提过的 companion object 伴生对象和 CombinedModifier 类之外，其他所有的 Modifier，不管是接口还是实现类，全部都直接或者间接的继承了 Modifier 的另外一个子接口：Element。 比如我们前面遇到的 Background 背后的 BackgroundElement： 123456789private class BackgroundElement( private val color: Color = Color.Unspecified, private val brush: Brush? = null, private val alpha: Float, private val shape: Shape, private val inspectorInfo: InspectorInfo.() -&gt; Unit) : ModifierNodeElement&lt;BackgroundNode&gt;() {abstract class ModifierNodeElement&lt;N : Modifier.Node&gt; : Modifier.Element ... 又比如 SizeModifier： 12345678910private class SizeElement( private val minWidth: Dp = Dp.Unspecified, private val minHeight: Dp = Dp.Unspecified, private val maxWidth: Dp = Dp.Unspecified, private val maxHeight: Dp = Dp.Unspecified, private val enforceIncoming: Boolean, private val inspectorInfo: InspectorInfo.() -&gt; Unit) : ModifierNodeElement&lt;SizeNode&gt;() {abstract class ModifierNodeElement&lt;N : Modifier.Node&gt; : Modifier.Element ... 又比如 PaddingModifier： 12345678910private class PaddingElement( var start: Dp = 0.dp, var top: Dp = 0.dp, var end: Dp = 0.dp, var bottom: Dp = 0.dp, var rtlAware: Boolean, val inspectorInfo: InspectorInfo.() -&gt; Unit) : ModifierNodeElement&lt;PaddingNode&gt;() {abstract class ModifierNodeElement&lt;N : Modifier.Node&gt; : Modifier.Element ... 你会发现它们的根统统都是 Modifier.Element 这个接口。 像这类直接子接口或子类还有哪些呢，如图所示，这些接口和子类基本涵盖了 Modifier 所提供的所有能力。","link":"/2025/08/01/compose/Compose%20--%20Modifier%20--%2001.%20%E8%A7%A3%E6%9E%90%20Modifier%20&%20CombinedModifier/"},{"title":"解析 Modifier.layout()","text":"其实原理性分析的文章，真的很难讲的通俗易懂，讲的简单浅显没必要写，讲的繁琐难懂往往大家也不乐意看，所以怎么找个好的角度慢慢钻进去尤为重要，比如：Begin simple code！ 基于 androidx.compose.runtime:runtime:1.7.1 版本 Simple Code 一个 Text()先来看一段最简单的代码示例： 123456789101112class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.background(Color.Green)) { Text(&quot;Hi Compose&quot;) } } } }} 这段代码很简单，效果图如下： 接下来基于这个 Demo，我们会慢慢引入本篇文章的主角。 Modifier.layout()在 Compose 中 Modifier.layout() 是一种「布局修饰符」：⤵︎它会包裹一个布局节点：LayoutNode（什么是 LayoutNode，下面会讲），⤵︎通常用作对目标组件「进行测量」和「位置摆放」的。 讲的更直白一点就是：⤵︎你可以用 Modifier.layout() 来「自定义目标组件的测量过程」以及「决定目标组件怎么摆放」。 我们先来看看在代码中怎么使用，通常会像下面这样写： 1234567891011121314class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.background(Color.Green)) { Text(&quot;Hi Compose&quot;, Modifier.layout { measurable, constraints -&gt; } ) } } } }} 就这么简单，Text 就是目标组件，我们给它加了一个 Modifier.layout()，没有添加任何其他代码逻辑， { measurable, constraints -&gt; } 是自动生成的， 此时你会发现在 Android Studio IDLE 中，这样写是会标红的： 正常来说，我这里什么也不填不就相当于对 Text() 不做任何修饰吗？但很明显这样是不行的，代码已经报错了！ 接下来我们一起尝试解决这个报错！ 首先我们发现当使用 Modifier.layout{} 修饰符时，传入的回调 lambda 包含了两个参数： measurable ：用于子元素的测量和位置放置； constraints ：用于约束子元素 width 和 height 的最大值和最小值。 我们定位到 Modifier.layout() 的源码： 12345📄 androidx.compose.ui.layout --&gt; LayoutModifier.ktfun Modifier.layout( measure: MeasureScope.(Measurable, Constraints) -&gt; MeasureResult) = this then LayoutElement(measure) 发现没？measurable 对应的是 Measurable： 12345678910📄 androidx.compose.ui.layout --&gt; Measurable.ktinterface Measurable : IntrinsicMeasurable { /** * Measures the layout with [constraints], returning a [Placeable] layout that has its new * size. A [Measurable] can only be measured once inside a layout pass. */ // 返回一个 Placeable，它里面包含目标组件的宽、高等信息 fun measure(constraints: Constraints): Placeable} Measurable 是一个接口，内部仅有一个 measure() 方法。 所以现在可以开始修改刚才的报错了： 1234567891011121314151617class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.background(Color.Green)) { Text(&quot;Hi Compose&quot;, Modifier.layout { measurable, constraints -&gt; // 用一个变量保存返回的 Placeable 对象 val placeable = measurable.measure(constraints) } ) } } } }} 现在代码仍然是标红报错的，原因在于：我们只处理了 measurable，它返回的是 Placeable，而 Modifier.layout() 需要返回的类型是 MeasureResult： 123fun Modifier.layout( measure: MeasureScope.(Measurable, Constraints) -&gt; MeasureResult // 需要返回 MeasureResult) = this then LayoutModifierElement(measure) 所以 MeasureResult 又是什么？ 12345678📄 androidx.compose.ui.layout --&gt; MeasureResult.ktinterface MeasureResult { val width: Int val height: Int val alignmentLines: Map&lt;AlignmentLine, Int&gt; fun placeChildren()} MeasureResult 也是一个接口，它里面也有 width 和 height，继续修复刚才的报错： 1234567891011121314151617181920212223242526class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Text(&quot;ComposeTest&quot;, Modifier.layout { measurable, constraints -&gt; val placeable = measurable.measure(constraints) object : MeasureResult { override val alignmentLines: Map&lt;AlignmentLine, Int&gt; get() = TODO(&quot;Not yet implemented&quot;) override val height: Int get() = TODO(&quot;Not yet implemented&quot;) override val width: Int get() = TODO(&quot;Not yet implemented&quot;) override fun placeChildren() { TODO(&quot;Not yet implemented&quot;) } } } ) } } }} 既然 Modifier.layout() 需要一个 MeasureResult 返回对象，那我们就在内部给它创建一个 MeasureResult 对象，此时 IDLE 就不会再报错了。 当然我们还需要做一个工作，那就是把 placeable 的宽高传进 MeasureResult 内部，所以最终的代码修改如下： 1234567891011121314151617181920212223242526272829303132class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.background(Color.Green)) { Text(&quot;Hi Compose&quot;, Modifier.layout { measurable, constraints -&gt; val placeable = measurable.measure(constraints) object : MeasureResult { // 测量基准线，暂时不用关心 override val alignmentLines: Map&lt;AlignmentLine, Int&gt; get() = TODO(&quot;Not yet implemented&quot;) // 高：placeable.height override val height: Int get() = placeable.height // 宽：placeable.width override val width: Int get() = placeable.width // 摆放内部组件，暂时不用关心 override fun placeChildren() { TODO(&quot;Not yet implemented&quot;) } } } ) } } } }} 至此报错就修复了，上面的代码演示了对 Text() 添加 Modifier.layout() 进行修饰（当然上面的做法等同于啥也没做）。 但这段代码有个缺陷：如果每次通过 Modifier.layout() 对组件修饰，都得像上面这样写一堆代码，那还不得疯？ layout() 函数其实在实际开发中我们并不会这么写，而是使用 Compose 提供给我们的 layout() 函数： 1234567891011121314151617181920212223242526272829303132class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.background(Color.Green)) { Text(&quot;Hi Compose&quot;, Modifier.layout { measurable, constraints -&gt; val placeable = measurable.measure(constraints) /*object : MeasureResult { override val alignmentLines: Map&lt;AlignmentLine, Int&gt; get() = TODO(&quot;Not yet implemented&quot;) override val height: Int get() = TODO(&quot;Not yet implemented&quot;) override val width: Int get() = TODO(&quot;Not yet implemented&quot;) override fun placeChildren() { TODO(&quot;Not yet implemented&quot;) } }*/ layout() { } } ) } } } }} 我们来看下 layout() 源码： 12345678910111213141516171819202122232425262728293031323334353637383940📄 androidx.compose.ui.layout --&gt; MeasureScope.ktinterface MeasureScope : IntrinsicMeasureScope { fun layout( width: Int, height: Int, alignmentLines: Map&lt;AlignmentLine, Int&gt; = emptyMap(), placementBlock: Placeable.PlacementScope.() -&gt; Unit ) = layout(width, height, alignmentLines, null, placementBlock) fun layout( width: Int, height: Int, alignmentLines: Map&lt;AlignmentLine, Int&gt; = emptyMap(), rulers: (RulerScope.() -&gt; Unit)? = null, placementBlock: Placeable.PlacementScope.() -&gt; Unit ): MeasureResult { checkMeasuredSize(width, height) return object : MeasureResult { override val width = width override val height = height override val alignmentLines = alignmentLines override val rulers = rulers override fun placeChildren() { // This isn't called from anywhere inside the compose framework. This might // be called by tests or external frameworks. if (this@MeasureScope is LookaheadCapablePlaceable) { placementScope.placementBlock() } else { SimplePlacementScope( width, layoutDirection ).placementBlock() } } } }} 很明显 layout() 函数帮我们创建好了 MeasureResult 对象，同时它还帮我们干了另外两件没做的事： 给 alignmentLines 设定了默认值； 实现了 placeChildren()。 所以，我们现在只需要补全 layout() 函数剩余的两个参数：width 和 height。 12345678910111213141516171819class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.background(Color.Green)) { Text(&quot;Hi Compose&quot;, Modifier.layout { measurable, constraints -&gt; val placeable = measurable.measure(constraints) layout(placeable.width, placeable.height) { } } ) } } } }} 这样写代码是不是瞬间感觉清爽了很多？但工作到这边还没有结束，layout() 函数还有第四个参数，是一个 Lambda 表达式，主要工作是处理被修饰组件的摆放规则，比如偏移量。 12345678fun layout( width: Int, height: Int, alignmentLines: Map&lt;AlignmentLine, Int&gt; = emptyMap(), placementBlock: Placeable.PlacementScope.() -&gt; Unit // Lambda 表达式) = object : MeasureResult { ... ...} 我们继续完善： 1234567891011121314151617181920class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.background(Color.Green)) { Text(&quot;Hi Compose&quot;, Modifier.layout { measurable, constraints -&gt; val placeable = measurable.measure(constraints) layout(placeable.width, placeable.height) { // 不做任何偏移 placeable.placeRelative(0, 0) } } ) } } } }} 现在所有工作（测量 + 摆放）都已完成，运行看下效果： 可以看出来，没有任何变化，因为我们虽然用 Modifier.layout() 对 Text 做修饰，但并没有对它做任何尺寸修改和位置偏移。 那如果我现在想修改 Text() 的尺寸，该怎么做？ 12345678910111213141516171819class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.background(Color.Green)) { Text(&quot;Hi Compose&quot;, Modifier.layout { measurable, constraints -&gt; val placeable = measurable.measure(constraints) val size = min(placeable.width, placeable.height) layout(size, size) { placeable.placeRelative(0, 0) } }) } } } }} 我们定义了一个 size 变量，通过 min() 函数获取宽高最小值，然后重新传入 layout() 里面，这样就会获得一个正方形的效果。 尺寸修改确实生效了，接下来再增加一个偏移： 12345678910111213141516171819class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.background(Color.Green)) { Text(&quot;Hi Compose&quot;, Modifier.layout { measurable, constraints -&gt; val placeable = measurable.measure(constraints) val size = min(placeable.width, placeable.height) layout(size, size) { placeable.placeRelative(30, 0) } }) } } } }} 看下效果： 另外有个细节需要说明下，除了使用 placeRelative 对组件偏移外，也可以使用 place 进行偏移操作，两者的区别就是 placeRelative 会自适应 RTL 布局。 讲到这里，Modifier.layout() 修饰符和 layout() 函数的用法你应该都清楚了，但还没结束，前面我们一直忽略了一个参数：constraints，它是什么？ measurable ：用于子元素的测量和位置放置； constraints ：用于约束子元素 width 和 height 的最大值和最小值。 前面的例子并没有对 constraints 做任何修改，在实际开发过程中，我们往往需要通过 constraints 对组件进行限制。 比如我想对 Text() 组件进行一个限制，类似 padding 的效果，给它加一个 10dp 的最大宽高的限制（最大宽高缩减 10dp）。 12345678910111213141516171819202122class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.background(Color.Green)) { Text(&quot;Hi Compose&quot;, Modifier.layout { measurable, constraints -&gt; val paddingPx = 10.dp.roundToPx() val placeable = measurable.measure(constraints.copy( maxWidth = constraints.maxWidth - paddingPx * 2, maxHeight = constraints.maxHeight - paddingPx * 2 )) layout(placeable.width + paddingPx * 2, placeable.height + paddingPx * 2) { placeable.placeRelative(paddingPx, paddingPx) } }) } } } }} 看下效果： 很明显，我们实现的效果跟 Modifier.padding(10.dp) 的效果是一样的，如果你去看看 Modifier.padding 的源码，就会发现它的内部原理跟我们例子是一样的。 1234567@Stablefun Modifier.padding( horizontal: Dp = 0.dp, vertical: Dp = 0.dp) = this then PaddingElement( ... ...) 12345678private class PaddingElement( var start: Dp = 0.dp, var top: Dp = 0.dp, var end: Dp = 0.dp, var bottom: Dp = 0.dp, var rtlAware: Boolean, val inspectorInfo: InspectorInfo.() -&gt; Unit) : ModifierNodeElement&lt;PaddingNode&gt;() { 1234567891011121314151617181920212223242526272829private class PaddingNode( var start: Dp = 0.dp, var top: Dp = 0.dp, var end: Dp = 0.dp, var bottom: Dp = 0.dp, var rtlAware: Boolean) : LayoutModifierNode, Modifier.Node() { override fun MeasureScope.measure( measurable: Measurable, constraints: Constraints ): MeasureResult { val horizontal = start.roundToPx() + end.roundToPx() val vertical = top.roundToPx() + bottom.roundToPx() val placeable = measurable.measure(constraints.offset(-horizontal, -vertical)) val width = constraints.constrainWidth(placeable.width + horizontal) val height = constraints.constrainHeight(placeable.height + vertical) return layout(width, height) { if (rtlAware) { placeable.placeRelative(start.roundToPx(), top.roundToPx()) } else { placeable.place(start.roundToPx(), top.roundToPx()) } } }} LayoutNode 浅析 通过前面的例子，我们可以看出： 不论是使用 Modifier.layout() 修饰符还是使用 Compose 提供给我们的现成的修饰符，比如：Modifier.padding() / Modifier.size()，它们都会对被修饰组件产生精细影响（组件大小、位置偏移）。 但到目前为止，我们仅仅是从 UI 效果上看到 Modifier.layout() 会影响被修饰组件，但源码底层是如何产生影响的呢？ 这才是我们这篇文章的核心价值！ 所以，最硬核的原理部分来了！ 我们就拿常用的 Modifier.padding() 分析，来看下它的源码 123456789101112131415161718192021222324252627282930313233📄 androidx.compose.foundation.layout --&gt; Padding.kt@Stablefun Modifier.padding( start: Dp = 0.dp, top: Dp = 0.dp, end: Dp = 0.dp, bottom: Dp = 0.dp) = this then PaddingElement( start = start, top = top, end = end, bottom = bottom, rtlAware = true, inspectorInfo = { name = &quot;padding&quot; properties[&quot;start&quot;] = start properties[&quot;top&quot;] = top properties[&quot;end&quot;] = end properties[&quot;bottom&quot;] = bottom })private class PaddingElement( var start: Dp = 0.dp, var top: Dp = 0.dp, var end: Dp = 0.dp, var bottom: Dp = 0.dp, var rtlAware: Boolean, val inspectorInfo: InspectorInfo.() -&gt; Unit) : ModifierNodeElement&lt;PaddingNode&gt;() {abstract class ModifierNodeElement&lt;N : Modifier.Node&gt; : Modifier.Element, InspectableValue { 这里有问题！！！！！！！！！！！！！ 层级关系非常清晰：Modifier.padding() 调用一个 PaddingElement 对象，而 PaddingElement 实现了 ModifierNodeElement 类（这是个范型类，其中包含了 PaddingNode），ModifierNodeElement 又继承了 Modifier.Element 接口。 这个 LayoutModifier 会被 Compose 用于修改测量和布局过程，从而最终影响到界面元素的位置和尺寸。 所以我们的重点就是要研究 LayoutModifier 是如何影响组件的！ 但是！在分析 LayoutModifier 原理之前，有一个核心知识点是必须要提前了解的。 这段代码我们再熟悉不过了吧： 123456789101112class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.background(Color.Green)) { Text(&quot;Hi Compose&quot;) } } } }} Box 、Text 这些函数在实际运行的时候，其实并不是这些函数直接存在于内存里面，而是 Compose 利用这些函数创造出的一些对象存在于内存里面，这个对象就是：LayoutNode，它才是最底层的那个节点，进行实际的「 测量、布局、绘制、触摸反馈 」等工作，你可以查看 【Compose 是如何将数据转换成 UI 的？】这篇文章，了解转换的思维模型！ 我们既然想知道 LayoutModifier 是如何精细影响 Text() 组件，那就得先研究明白 Text() 自己的测量、布局、绘制的原理，因为 LayoutModifier 是包着这个 Text() 的。 在 LayoutNode 中，测量和布局是由 remeasure() 函数和 replace() 两个函数处理。 123456📄 androidx.compose.ui.node --&gt; LayoutNode.ktinternal class LayoutNode(..) { internal fun replace() // 布局 internal fun remeasure() // 测量} remeasure()我们先来分析 remeasure() 函数： 12345678910111213141516171819📄 androidx.compose.ui.node --&gt; LayoutNode.ktinternal class LayoutNode(..) { internal fun remeasure( constraints: Constraints? = layoutDelegate.lastConstraints ): Boolean { return if (constraints != null) { if (intrinsicsUsageByParent == UsageByParent.NotUsed) { clearSubtreeIntrinsicsUsage() } // 测量工作交给 LayoutNodeLayoutDelegate 的内部类 MeasurePassDelegate 处理 measurePassDelegate.remeasure(constraints) } else { false } }} LayoutNode 内部要处理的事情非常多，它把测量的工作交给了 MeasurePassDelegate 来处理。 123456789101112131415161718192021222324📄 androidx.compose.ui.node --&gt; LayoutNodeLayoutDelegate.ktinternal class LayoutNodeLayoutDelegate( private val layoutNode: LayoutNode) { inner class MeasurePassDelegate : Measurable, Placeable(), AlignmentLinesOwner, MotionReferencePlacementDelegate { fun remeasure(constraints: Constraints): Boolean { ... if (layoutNode.measurePending || measurementConstraints != constraints) { ... performMeasure(constraints) // 关键代码 ... } else { ... } return false } }} 这段代码很长，但我们只需要关注一行关键代码：performMeasure(constraints)。 1234567891011121314151617181920212223📄 androidx.compose.ui.node --&gt; LayoutNodeLayoutDelegate.ktinternal class LayoutNodeLayoutDelegate( private val layoutNode: LayoutNode) { private var performMeasureConstraints = Constraints() private val performMeasureBlock: () -&gt; Unit = { outerCoordinator.measure(performMeasureConstraints) } private fun performMeasure(constraints: Constraints) { ... layoutNode.requireOwner().snapshotObserver.observeMeasureSnapshotReads( layoutNode, affectsLookahead = false, performMeasureBlock // 关键代码 ) ... }} 我们仍然只需要关注：outerCoordinator.measure(performMeasureConstraints)，它是做实际测量工作的。 继续跟踪： 123456789📄 androidx.compose.ui.layout --&gt; Measurable.ktinterface Measurable : IntrinsicMeasurable { /** * Measures the layout with [constraints], returning a [Placeable] layout that has its new * size. A [Measurable] can only be measured once inside a layout pass. */ fun measure(constraints: Constraints): Placeable} What ？？？怎么是个接口啊，没有任何处理逻辑啊！！！ 转念一想，既然是个接口，那肯定有其他地方实现了这个方法，我们可以搜一下哪些地方实现了。 有 9 个地方实现了，但哪一个才是我们需要的呢？别慌，我带你找一下。 我们往回退，找找刚才哪里调用 measure() 方法的？ 1234567891011121314151617181920📄 androidx.compose.ui.node --&gt; LayoutNodeLayoutDelegate.ktinternal class LayoutNodeLayoutDelegate( private val layoutNode: LayoutNode) { /** * 2. outerCoordinator 由传进来的 layoutNode 参数决定，那么我们得找找 layoutNode 是哪里传进来的 * 这里记住： * a. 接下来我们先找到哪里传入了 layoutNode * b. 找到后我们再看 layoutNode.nodes.outerCoordinator 是什么？ */ val outerCoordinator: NodeCoordinator get() = layoutNode.nodes.outerCoordinator private val performMeasureBlock: () -&gt; Unit = { // 1. 这里调用了 measure()，那么 outerCoordinator 是什么？ outerCoordinator.measure(performMeasureConstraints) }} 继续回退到上一层： 1234567891011121314151617181920212223📄 androidx.compose.ui.node --&gt; LayoutNodeLayoutDelegate.ktinternal class LayoutNodeLayoutDelegate( private val layoutNode: LayoutNode) { inner class MeasurePassDelegate : Measurable, Placeable(), AlignmentLinesOwner { // 2. 我们继续回退 fun remeasure(constraints: Constraints): Boolean { ... if (layoutNode.measurePending || measurementConstraints != constraints) { ... // 1. 没有地方传入 layoutNode 啊 performMeasure(constraints) ... } return false } }} 继续回退到上一层： 12345678910111213141516171819202122232425262728293031323334353637📄 androidx.compose.ui.node --&gt; LayoutNode.ktinternal class LayoutNode(..) { // 2. 通过 layoutDelegate 获取 measurePassDelegate，那 layoutDelegate 是什么？ internal val measurePassDelegate get() = layoutDelegate.measurePassDelegate ... // 4. 来来来，nodes 在这里，NodeChain 又是什么？ internal val nodes = NodeChain(this) /** * 3. LayoutNodeLayoutDelegate(this) 看到这行代码你有没有想起来什么？ * 这个 this 不就是我们要找的那个 layoutNode 参数嘛！ * 现在我们再看下刚刚用到这个参数的地方： * * val outerCoordinator: NodeCoordinator * get() = layoutNode.nodes.outerCoordinator * * 还记得吧？现在 layoutNode 找到了，接下来看看 nodes 是什么？ */ internal val layoutDelegate = LayoutNodeLayoutDelegate(this) internal fun remeasure( constraints: Constraints? = layoutDelegate.lastConstraints ): Boolean { return if (constraints != null) { ... // 1. 还是没有地方传入 layoutNode 啊，别急，我们看看 measurePassDelegate 是什么？ measurePassDelegate.remeasure(constraints) } else { false } }} NodeChain我们再来看看 NodeChain 是什么？ 123456789101112131415161718192021📄 androidx.compose.ui.node --&gt; NodeChain.ktinternal class NodeChain(val layoutNode: LayoutNode) { /** * 2. 再看这里，而 innerCoordinator 又是 InnerNodeCoordinator！ */ internal val innerCoordinator = InnerNodeCoordinator(layoutNode) /** * 不忘初心，再次搬出代码： * * val outerCoordinator: NodeCoordinator * get() = layoutNode.nodes.outerCoordinator * * 1. 哦，原来如此： * layoutNode.nodes.outerCoordinator 是 innerCoordinator */ internal var outerCoordinator: NodeCoordinator = innerCoordinator private set ... ...} 代码跟踪到这里就真相显现了，到底是哪个实现类处理了 measure() 方法，你现在清楚了吧？再来看下刚刚的截图： 所以接下来我们就看看 InnerNodeCoordinator 是如何负责具体测量的： 123456789101112131415161718192021222324252627282930📄 androidx.compose.ui.node --&gt; InnerNodeCoordinator.ktinternal class InnerNodeCoordinator( layoutNode: LayoutNode) : NodeCoordinator(layoutNode) { override fun measure(constraints: Constraints): Placeable { @Suppress(&quot;NAME_SHADOWING&quot;) val constraints = if (forceMeasureWithLookaheadConstraints) { lookaheadDelegate!!.constraints } else { constraints } return performingMeasure(constraints) { // before rerunning the user's measure block reset previous measuredByParent for children layoutNode.forEachChild { it.measurePassDelegate.measuredByParent = LayoutNode.UsageByParent.NotUsed } // 2. 返回一个 MeasureResult 对象给 replace() 去布局 measureResult = with(layoutNode.measurePolicy) { // 1. 最核心处：这边就是最底层开始测量的工作了 measure(layoutNode.childMeasurables, constraints) } onMeasured() this } }} 分析到这里，关于组件自身的测量和布局流程就跑通了： 我们在代码中所写的 Box、Text 等组件内部会有自己设定的测量数据，他们在代码实际运行过程中会被 Comopse 转换成 LayoutNode 节点（包含所有组件自身的测量数据），然后一层层往下传，最终传到 InnerNodeCoordinator，由它进行最底层的测量工作，测量完成后会返回一个 MeasureResult 对象再交给 replace() 函数完成布局工作。 所以，Do you understand? LayoutModifer 的工作原理 前面我们已经了解了组件自身的测量和布局原理，现在就可以开始分析 LayoutModifer 是如何影响组件的测量和布局了。 就像我们前面说的那样，所有组件最终都会被转换为一个 LayoutNode，这个 LayoutNode 包含了所有的测量数据，那同样它也会包含你对组件设定的 Modifier，所以最终经过一些列转换，也会传到 LayoutNode 里面，而 LayoutNode 里面也有一个 modifier 变量，存储的就是修饰 Composable 函数的 Modifier。 LayoutNode.Modifer现在我们来看看具体的代码逻辑： 123456789101112131415161718192021222324252627// 📄 androidx.compose.ui.node --&gt; LayoutNode.ktinternal class LayoutNode(..) { override var modifier: Modifier get() = _modifier // 如果有新值变化 set(value) { ... if (isAttached) { applyModifier(value) } else { pendingModifier = value } } private fun applyModifier(modifier: Modifier) { _modifier = modifier nodes.updateFrom(modifier) // 关键代码 layoutDelegate.updateParentData() if (lookaheadRoot == null &amp;&amp; nodes.has(Nodes.ApproachMeasure)) { lookaheadRoot = this } }} 这里的 nodes 应该不陌生了吧？前一节我们已经知道了它是 NodeChain 对象。 1internal val nodes = NodeChain(this) 但是 NodeChain 是什么？ 其实它就是一个链表，而且是个「双向链表」 1234567891011📄 androidx.compose.ui.node --&gt; NodeChain.ktinternal class NodeChain(val layoutNode: LayoutNode) { internal val innerCoordinator = InnerNodeCoordinator(layoutNode) internal var outerCoordinator: NodeCoordinator = innerCoordinator private set internal val tail: Modifier.Node = innerCoordinator.tail internal var head: Modifier.Node = tail private set ...} 1. 头、尾节点都是 Modifier.Node 类型！ 2. 其中的 NodeCoordinator 是用来辅助 Node 节点处理测量和布局的，其中包含 measure 和 placeAt 的函数逻辑。 3. NodeChain 链表上的每一个 Node 都会对应的绑定一个 NodeCoordinator 对象来辅助处理。（不理解没关系，接着往下看！） updateFrom()接下来看看 updateFrom 的具体工作，它主要负责 NodeChain 链表的「更新」，每当有 Modifier 对象被设置到 LayoutNode 上面，都会调用 updateFrom 函数进行更新对应的 NodeChain。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465📄 androidx.compose.ui.node --&gt; NodeChain.ktinternal class NodeChain(val layoutNode: LayoutNode) { // 负责最内层测量的 NodeCoordinator internal val innerCoordinator = InnerNodeCoordinator(layoutNode) // 负责外层测量的 NodeCoordinator，初始值是 InnerNodeCoordinator internal var outerCoordinator: NodeCoordinator = innerCoordinator private set // 双向链表的尾节点 internal val tail: Modifier.Node = innerCoordinator.tail // 双向链表的头节点 internal var head: Modifier.Node = tail private set ... internal fun updateFrom(m: Modifier) { var coordinatorSyncNeeded = false val paddedHead = padChain() var before = current val beforeSize = before?.size ?: 0 /** * 📝 核心代码 1: * fillVector 会将 Modifier 展开铺平到一个数组， * 后面的代码就可以用这个数组遍历 */ val after = m.fillVector(buffer ?: mutableVectorOf()) var i = 0 // 检查更新差异 if (after.size == beforeSize) { ... // 这段代码不用看，只要加了 Modifier.xx 默认不会走到这边 } else if (layoutNode.applyingModifierOnAttach &amp;&amp; beforeSize == 0) { // 第一次组装 Modifier.Node 双向链表 coordinatorSyncNeeded = true var node = paddedHead while (i &lt; after.size) { val next = after[i] val parent = node /** * 📝 核心代码 2: 组装双向链表的具体逻辑 */ node = createAndInsertNodeAsChild(next, parent) logger?.nodeInserted(0, i, next, parent, node) i++ } syncAggregateChildKindSet() } else if (after.size == 0) { // 删除所有 modifier ... } else { ... } current = after buffer = before?.also { it.clear() } /** * 📝 核心代码 3: 更新头节点 */ head = trimChain(paddedHead) if (coordinatorSyncNeeded) { /** * 📝 核心代码 4: 关联 Modifier.Node 和 NodeCoordinator */ syncCoordinators() } }} 接下来跟着我深入分析每一行核心代码！希望你能沉下心看下去，包教包会！ 📝 分解 Modifier先来看第一个核心代码： 1val after = m.fillVector(buffer ?: mutableVectorOf()) m 就是你的 Modifier 链，这里的 buffer 默认为 null，mutableVectorOf() 其实跟 buffer 一样都是一个可变列表，只是容量不同而已，你只要知道它就是一个列表，用来装分解后的单个 Modifier 用的就行了。 接着我们开始分析 fillVector 函数： 123456789101112131415161718192021222324252627282930313233343536📄 androidx.compose.ui.node --&gt; NodeChain.ktprivate fun Modifier.fillVector( result: MutableVector&lt;Modifier.Element&gt;): MutableVector&lt;Modifier.Element&gt; { val capacity = result.size.coerceAtLeast(16) /** * 1. 创建一个元素为 Modifier 的可变列表，并在初始化后添加传进来的 Modifier， * 从 stack 名字就可以看出来，这里相当于创建了一个栈，并且容量为 16 */ val stack = MutableVector&lt;Modifier&gt;(capacity).also { it.add(this) } var predicate: ((Modifier.Element) -&gt; Boolean)? = null // 2. 只要栈不为空，一直循环 while (stack.isNotEmpty()) { // 3. 从栈中移除并获取最后一个元素，存到 next 变量中 when (val next = stack.removeAt(stack.size - 1)) { // 4. 如果 next 是 CombinedModifier 类型 is CombinedModifier -&gt; { stack.add(next.inner) // 把 inner 部分加入到 stack 中 stack.add(next.outer) // 把 outer 部分加入到 stack 中 } // 5. 如果 next 是 Modifier.Element 类型，则直接加到 result 中 is Modifier.Element -&gt; result.add(next) /** * 6. 如果 next 是 Modifier 的其他实现，可能我们不知道具体实现细节， * 把 it（可能是 Modifier.Element 的实例）加入到 result 中 */ else -&gt; next.all(predicate ?: { element: Modifier.Element -&gt; result.add(element) true }.also { predicate = it }) } } // 7. 在处理完所有的元素之后，返回 result，它包含了所有的 Modifier.Element return result} 这个函数其实就是创建了一个 Modifier 调用栈，以便可以迭代地处理一个可能嵌套的 Modifier 结构。栈的使用是为了在不使用递归的情况下扁平化修饰符的结构。 注意！从 1.3.0-beta01 版本开始，Compose 中不再使用 foldIn/foldOut 函数对 Modifier 进行遍历了，在 1.3.0-beta01 之前的版本 LayoutNode 源码中是通过 foldOut 遍历 + 头插法处理，而现在是通过 fillVector 函数处理达到类似的效果。 看的懂吗？是不是很懵？我们来个实际例子吧，比如传入的 Modifier 链如下： 1234567891011// 这是你写的代码Box(Modifier.padding(10.dp).size(20.dp))// 此时 Modifier 链为:modifierChain = Modifier.padding(10.dp).size(20.dp)// 实际的结构：CombinedModifier( PaddingElement // outer SizeElement // inner) 我们来看看 fillVector 是怎么处理它的： &nbsp;&nbsp;&nbsp;&nbsp;➡️ 1. 当调用 fillVector 函数时，初始状态是 modifierChain 放入了一个空的 stack 中。 &nbsp;&nbsp;&nbsp;&nbsp;➡️ 2. 此时 stack 不为空，开始循环： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;🔸 removeAt 从 stack 的末尾（最后加入的元素）移除 CombinedModifier（因为它是链中最后一个元素），并将其赋值给 next。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;🔸 next 是一个 CombinedModifier 实例，此时就把 inner 和 outer 分别加进 stack 中，这个时候 stack 里面就有了两个元素：[SizeElement, PaddingElement]。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;🔸 再次循环，这个时候再次开始 removeAt 从末尾取，先取到 PaddingElement，条件判断发现它是一个 Modifier.Element，那就把它加进 result 里面（result 也是一个可变列表）。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;🔸 继续循环，又取到了 SizeElement，发现它也是一个 Modifier.Element，那就直接加进 result 里面。 &nbsp;&nbsp;&nbsp;&nbsp;➡️ 3. 继续循环，啪～ stack 没东西了，循环结束，直接返回 result 结果：[PaddingElement, SizeElement]。 这段流程我给你画了张图： 📝 构建双向链表现在我们来分析第二段核心代码： 123456789101112131415// NodeChain.kt} else if (layoutNode.applyingModifierOnAttach &amp;&amp; beforeSize == 0) { // 第一次组装 Modifier.Node 双向链表 coordinatorSyncNeeded = true var node = paddedHead 🟡 1. node 初始值是什么？ while (i &lt; after.size) { 🟡 2. after 是什么？ val next = after[i] val parent = node // 📝 核心代码 2: 组装双向链表的具体逻辑 node = createAndInsertNodeAsChild(next, parent) logger?.nodeInserted(0, i, next, parent, node) i++ } syncAggregateChildKindSet()} 我们先来看 node，它是 paddedHead： 1val paddedHead = padChain() 来看下 padChain() 做了什么： 123456789101112// NodeChain.ktinternal val tail: Modifier.Node = innerCoordinator.tailinternal var head: Modifier.Node = tail private set private fun padChain(): Modifier.Node { checkPrecondition(head !== SentinelHead) { &quot;padChain called on already padded chain&quot; } val currentHead = head currentHead.parent = SentinelHead SentinelHead.child = currentHead return SentinelHead} 这个时候 head 默认是 tail，其实就是组件本身：Box。 SentinelHead 是什么？它最主要的作用就是作为一个哨子节点，简化链表操作用的，我们就可以把它理解为在 Box 这个 Modifier.Node 节点前面插入一个哨子节点，它们彼此构成一个双向链表。 after ，它就是先前 result 返回的结果，即：[PaddingElement, SizeElement]，所以 next 会轮流取到这两个 Modifier 进行进一步的操作。 接下来我们来分析 createAndInsertNodeAsParent 函数： 123456789101112131415161718// NodeChain.ktprivate fun createAndInsertNodeAsChild( element: Modifier.Element, parent: Modifier.Node,): Modifier.Node { // 1. 创建一个新的节点 val node = when (element) { // 2. 如果 element 是 ModifierNodeElement 的实例，它会调用 element 上的 create 方法， // 这个方法会返回一个新的 Modifier.Node is ModifierNodeElement&lt;*&gt; -&gt; element.create().also { it.kindSet = calculateNodeKindSetFromIncludingDelegates(it) } else -&gt; BackwardsCompatNode(element) } ... // 3. 插入到树中 return insertChild(node, parent)} 我们重点来看一下 when() 内部的操作： 首先取到的是 PaddingElement，它是 ModifierNodeElement 的实现类，所以满足条件，接着调用 create() 方法，会把 PaddingElement 包装成一个 Modifier.Node。 现在已经得到了一个 Modifier.Node，接着把它插入树中，我们来看下操作： 1234567891011121314// NodeChain.ktprivate fun insertChild(node: Modifier.Node, parent: Modifier.Node): Modifier.Node { // 1. parent 就是哨子节点，所以 theChild 就是 Box 对应的 Modifier.Node val theChild = parent.child if (theChild != null) { // 2. node 是传进来的 PaddingNode，将两个 Modifier.Node 建立双向链表关系 theChild.parent = node node.child = theChild } // 3. 再把哨子节点跟传进来的 PaddingNode 构建双向链表关系 parent.child = node node.parent = parent return node} 能理解吗？我也给你画了张图： 现在已经处理完了 PaddingElement，循环取值，拿出第二个 SizeElement，继续处理，流程我就不写了直接看图： 至此，第二部构建双向链表的工作就结束了，你发现没有，虽然先处理了 PaddingElement，后处理了 SizeElement，但实际上是把 SizeElement 插入到了 PaddingElement 内部，这其实就跟老版本的 foldIn 从尾部便利然后头插的方式一样，实现了同样的功能。 📝 更新头节点第二段核心代码已经构建好了双向链表，但如果你看过老版本的代码会发现，以前是没有 SentineHead 这个哨子节点的，目前的双向链表的头节点是 SentineHead，它并没有实际的功能上的用处，所以这就是第三步核心代码要做的事，我们来看看： 12345678910111213141516// NodeChain.ktprivate fun trimChain(paddedHead: Modifier.Node): Modifier.Node { checkPrecondition(paddedHead === SentinelHead) { &quot;trimChain called on already trimmed chain&quot; } // 1. 取 SentineHead 的子节点，有吗？有 -- 就是 PaddingNode val result = SentinelHead.child ?: tail // 2. 断开 SentineHead 与 PaddingNode 之间的链 result.parent = null SentinelHead.child = null SentinelHead.aggregateChildKindSet = 0.inv() SentinelHead.updateCoordinator(null) checkPrecondition(result !== SentinelHead) { &quot;trimChain did not update the head&quot; } // 3. 返回链，此时链就完全是一个由组件自身的 Node 和 Modifier 的 Node 组成的双向链表了 return result} 代码很简单，就是把 SentineHead 从双向链表中断开去除，这样就是一个新的以 PaddingModifier 为表头的双向链表了。 📝 同步协调器我们前面提到过：NodeCoordinator 是用来辅助 Node 节点处理测量和布局的，其中包含 measure 和 placeAt 的函数逻辑。NodeChain 链表上的每一个 Node 都会对应的绑定一个 NodeCoordinator 对象来辅助处理。 现在 NodeChain 链表已经全部搞定了，那么接下来就要开始对链表上每一个 Modifier.Node 绑定一个 NodeCoordinator，现在我们来看看 syncCoordinator 函数是怎么做的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// NodeChain.ktprivate fun syncCoordinators() { var coordinator: NodeCoordinator = innerCoordinator // tail 就是链表的尾部节点，也就是组件自身的 Modifier.Node // 开始遍历，获取它的父节点，也就是 tail -&gt; SizeNode -&gt; PaddingNode var node: Modifier.Node? = tail.parent while (node != null) { // 判断 Modifier.Node 就是不是 LayoutModifierNode val layoutmod = node.asLayoutModifierNode() // 如果是 LayoutModifierNode if (layoutmod != null) { // 如果节点已有关联的 coordinator，则使用现有的协调器，同时判断此协调器所关联的节点是否变化了， // 如果有变化，则调用 onLayoutModifierNodeChanged() 方法 val next = if (node.coordinator != null) { val c = node.coordinator as LayoutModifierNodeCoordinator val prevNode = c.layoutModifierNode c.layoutModifierNode = layoutmod if (prevNode !== node) c.onLayoutModifierNodeChanged() c } else { // 如果节点没有关联的 coordinator，则创建一个 LayoutModifierNodeCoordinator， // 并通过 updateCoordinator 方法将这个新协调器和节点相关联 val c = LayoutModifierNodeCoordinator(layoutNode, node) node.updateCoordinator(c) c } // 不论是使用旧的还是新建的 coordinator，通过设置 wrappedBy 和 wrapped 属性， // 建立当前 coordinator 与下一个 coordinator 的包装关系， // 然后将 coordinator 变量更新为下一个 coordinator // 例如我们这边的例子：tail -&gt; SizeNode coordinator.wrappedBy = next // InnerCoordinator 被谁包裹？-- LayoutModifierNodeCoordinator next.wrapped = coordinator // LayoutModifierNodeCoordinator 包裹了谁？-- InnerCoordinator coordinator = next // 更新 coordinator，比如后面再跟 PaddingNode 建立包裹关系 } else { // 如果 node 不是布局修饰符节点，直接调用 updateCoordinator 方法来更新协调器， // 将 node 和 NodeCoordinator 挂接关联 // 比如： // Modifier.background().size() // 这里 Modifier.background() 转换后的 Node 对应的 NodeCoordinator // 为 SizeNode 对应的 NodeCoordinator node.updateCoordinator(coordinator) } // 在每次迭代结束时，将 node 变量更新为当前节点的父节点 node.parent，为下一次循环准备 // 也就是获取 SizeNode 的父节点 -- PaddingNode，继续处理 node = node.parent } coordinator.wrappedBy = layoutNode.parent?.innerCoordinator outerCoordinator = coordinator // 调整外层 NodeCoordinator} 看懂了吗？我又画了一张图： 现在让我们简单总结下 updateFrom() 的处理步骤： 在 Composable 编写的 Modifier 是层层嵌套的，首先需要将 Modifier 集合铺平到一个数组中； 如果 NodeChain 还没有组装过双向链表，遍历步骤一铺平的 Modifier 数组组装成双向链表，否则就对双向链表增量更新； 更新双向链表头节点； 将 Modifier 和所属的 NodeCoordinator 挂接关联。 现在去除代码分析部分，再来看一个整体思维模型图： 看到这里，所有的 Modifier 处理完了，接下来就可以开始测量了，你还记得第二节我们讲的组件自身测量的代码逻辑吗？我估计你看到这，应该已经全忘了，所以再看一下流程图吧： 看到没？是谁测量的？– outerCoordinator！ outerCoordinator 对象就是做实际测量工作的，所以开始测量的时候，从哪开始测？不用我说了吧？ measure()我们看下 LayoutModifierNodeCoordinator 是怎么做测量的： 1234567891011121314151617181920212223242526272829// LayoutModifierNodeCoordinator.ktinternal class LayoutModifierNodeCoordinator( layoutNode: LayoutNode, measureNode: LayoutModifierNode,) : NodeCoordinator(layoutNode) { override fun measure(constraints: Constraints): Placeable { @Suppress(&quot;NAME_SHADOWING&quot;) val constraints = if (forceMeasureWithLookaheadConstraints) { requireNotNull(lookaheadConstraints) { &quot;Lookahead constraints cannot be null in approach pass.&quot; } } else { constraints } performingMeasure(constraints) { measureResult = approachMeasureScope?.let { scope -&gt; ... ... // 1. 核心代码，with 包含了 LayoutModifierNode，提供了一个 LayoutModifierNode 的上下文 } ?: with(layoutModifierNode) { // 2. 这里的 wrappedNonNull 是什么？我们后面马上就说到 measure(wrappedNonNull, constraints) } this@LayoutModifierNodeCoordinator } onMeasured() return this }} measure() 的工作会跳转到哪里，是由 with() 决定的，它提供了 LayoutModifierNode 上下文，所以 measure() 跳转到了 LayoutModifierNode 里面。 12345678910// LayoutModifierNode.ktinterface LayoutModifierNode : Remeasurement, DelegatableNode { fun MeasureScope.measure( measurable: Measurable, constraints: Constraints ): MeasureResult ... ...} LayoutModifierNode 只是一个接口，所以具体的测量实现在哪？ 这里我们要分两种场景来看： 1. 我们首先来看最简单的一种情况：Modifier.layout() 比如我们文章前面写过的一个例子： 1234567891011121314151617181920212223class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.background(Color.Green)) { Text(&quot;Hi Compose&quot;, // here，熟悉吗？ Modifier.layout { measurable, constraints -&gt; val paddingPx = 10.dp.roundToPx() val placeable = measurable.measure(constraints.copy( maxWidth = constraints.maxWidth - paddingPx * 2, maxHeight = constraints.maxHeight - paddingPx * 2 )) layout(placeable.width + paddingPx * 2, placeable.height + paddingPx * 2) { placeable.placeRelative(paddingPx, paddingPx) } }) } } } }} 点进 Modifier.layout {} 看源码： 1234567891011// LayoutModifier.ktfun Modifier.layout( measure: MeasureScope.(Measurable, Constraints) -&gt; MeasureResult) = this then LayoutElement(measure)private data class LayoutElement( val measure: MeasureScope.(Measurable, Constraints) -&gt; MeasureResult) : ModifierNodeElement&lt;LayoutModifierImpl&gt;() { override fun create() = LayoutModifierImpl(measure) ... ...} 再点击 LayoutModifierImpl 进去看看： 12345678910111213internal class LayoutModifierImpl( var measureBlock: MeasureScope.(Measurable, Constraints) -&gt; MeasureResult) : LayoutModifierNode, Modifier.Node() { // 看！！！是不是重写了 MeasureScope.measure 方法 ? 所以具体测量工作就在这里了。 override fun MeasureScope.measure( measurable: Measurable, constraints: Constraints ) = measureBlock(measurable, constraints) override fun toString(): String { return &quot;LayoutModifierImpl(measureBlock=$measureBlock)&quot; }} 这里 measure 直接调用了 measureBlock()，它是参数传进来的，往回退： 1234567891011// LayoutModifier.ktfun Modifier.layout( measure: MeasureScope.(Measurable, Constraints) -&gt; MeasureResult) = this then LayoutElement(measure)private data class LayoutElement( val measure: MeasureScope.(Measurable, Constraints) -&gt; MeasureResult) : ModifierNodeElement&lt;LayoutModifierImpl&gt;() { override fun create() = LayoutModifierImpl(measure) ... ...} measureBlock 又是 measure，而 measure 是啥？就是你主代码里面写在 Modifier.layout {} 里面的测量和布局逻辑，这就相当于实现了将内部的测量结果暴露给上层，让我们能修饰做二次测量处理。 2. 现在我们再来看第二种场景：Modifier.padding(10.dp).size(20.dp) 这个例子不用多说了吧，之前分析源码就是基于它，这个场景就要关联到我们刚刚提到的 wrappedNonNull 了。 1234567891011121314151617181920212223242526// LayoutModifierNodeCoordinator.ktinternal class LayoutModifierNodeCoordinator( layoutNode: LayoutNode, measureNode: LayoutModifierNode,) : NodeCoordinator(layoutNode) { // 2. wrapped 是 LayoutModifierNodeCoordinator 的内部 NodeCoordinator val wrappedNonNull: NodeCoordinator get() = wrapped!! override fun measure(constraints: Constraints): Placeable { performingMeasure(constraints) { with(layoutModifierNode) { measureResult = if (this is IntermediateLayoutModifierNode) { ... } else { // 1. 这里的 wrappedNonNull 是什么？ measure(wrappedNonNull, constraints) } this@LayoutModifierNodeCoordinator } } onMeasured() return this }} 注释写的很清楚：wrapped 是最外层 LayoutModifierNodeCoordinator 的内部 NodeCoordinator，是谁？ 所以你能看出什么门道吗？流程很清晰：测量过程中会从外往里执行每一个 NodeCoordinator 的 measure 方法，直到触底遇到组件自身的 InnerNodeCoordinator，它负责自身的测量。 流程如下： 我们要给 Box 增加 10dp 的 padding，但此时还不知道组件本身大小，所以就需要先测量内部，会先去找 10dp 套着的内部； 现在内部要设定 20dp 的 size，但仍然不知道组件本身大小，需要先测量内部，继续往下找它的内部； 找到了具体组件 Box，它是 InnerNodeCoordinator，InnerNodeCoordinator 已经没有内部了，所以 Box 按照自己的测量方式去测量拿到测量结果； InnerNodeCoordinator 测量出结果后，往上传给要设定 size 的 LayoutModifierNode，在测量结果上设定 20dp 的 size 后返回测量结果； 拿到设定 20dp size 的测量结果后，再往上传给要加 padding 的 LayoutModifierNode，在测量结果上再添加 10dp 的 padding，LayoutNode 拿到最终的测量结果。","link":"/2025/08/10/compose/Compose%20--%20Modifier%20--%2003.%20%E8%A7%A3%E6%9E%90%20Modifier.layout()/"},{"title":"聊聊 mutableStateListOf","text":"讲任何一个新的主题或者知识点，习惯性的从 Demo 开始，比如： 1234567891011class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var name by mutableStateOf(&quot;Hi, Compose&quot;) setContent { Text(name) } }} 这段代码已经熟的不能再熟了吧？ 如果我们用 by mutableStateOf 初始化一个变量，那 name 就会变成一个被 Compose「自动订阅」的变量。 我们之前文章的例子，都是用 by mutableStateOf 包了一个 String，如果换成别的类型，行不行？ 1234fun &lt;T&gt; mutableStateOf( value: T, // 泛型参数 policy: SnapshotMutationPolicy&lt;T&gt; = structuralEqualityPolicy()): MutableState&lt;T&gt; = createSnapshotMutableState(value, policy) 例如：Int 类型 12345678910111213141516class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var num by mutableStateOf(1) setContent { Text( text = &quot;当前数值：$num&quot;, Modifier.clickable { num++ } ) } }} 代码不做解释了，直接看效果： 例如：List 类型 123// num 类型：MutableList&lt;Int&gt;// mutableStateOf 类型：MutableState&lt;MutableList&lt;Int&gt;&gt;var nums by mutableStateOf(mutableListOf(1, 2, 3)) 我们在代码里面用起来： 123456789101112131415class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var nums by mutableStateOf(mutableListOf(1, 2, 3)) setContent { Column { for (num in nums) { Text(&quot;第 $num 块文字&quot;) } } } }} 运行： 现在我们稍微改下代码： 1234567891011121314151617181920class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var nums by mutableStateOf(mutableListOf(1, 2, 3)) setContent { Column { Button(onClick = { nums.add(nums.last() + 1) }) { Text(&quot;List 加 1&quot;) } for (num in nums) { Text(&quot;第 $num 块文字&quot;) } } } }} 代码很简单：我们添加了一个 Button，每次点击后，nums 会添加一个值，比最有一个值大 1。 运行： Button 疯狂点击，但是没生效！为什么？ 我们先来思考一个问题，mutableStateOf 原理是什么？我们回忆一下： mutableStateOf 之所以可以对变量进行订阅和刷新，主要是因为内部的 get() 和 set() 方法加了钩子，或者说它的 set() 方法是赋值！是改变了变量的指向，它是直接把对象给替换了，但在我们这个代码里面 nums 仅仅是改变了它内部的状态！ 所以，它不会触发 setValue() 的调用，从而不会触发自动刷新的操作。 为了验证是不是因为没有重组，我们可以改下代码： 12345678910111213141516171819202122class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var nums by mutableStateOf(mutableListOf(1, 2, 3)) var refresh by mutableStateOf(&quot;强制刷新&quot;) setContent { Column { Text(refresh, Modifier.clickable { refresh = &quot;刷新完成&quot;}) Button(onClick = { nums.add(nums.last() + 1) }) { Text(&quot;List 加 1&quot;) } for (num in nums) { Text(&quot;第 $num 块文字&quot;) } } } }} 我们添加了一个 Text() 组件，改变 refresh 的值，那么理论上它就会带着「整个重组作用域内」的组件全部「刷新」，包括 List。 运行： 成功刷新了 List ！ 现在我们就很清楚了，mutableStateOf 没法对 List 类型的对象实现类似 String、Int 的自动订阅及刷新，那有没有解决办法？ 上面我们说过了，问题的根本原因是 List 只是内部的变化，而不是它自己本身对象的变化，那我们在内部操作完后直接把 List 重新给换了不就行了？试试： 1234567891011121314151617181920212223class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var nums by mutableStateOf(mutableListOf(1, 2, 3)) setContent { Column { Button(onClick = { // nums 重新赋值 nums = nums.toMutableList().apply { add(nums.last() + 1) } }) { Text(&quot;List 加 1&quot;) } for (num in nums) { Text(&quot;第 $num 块文字&quot;) } } } }} 运行： 成功刷新了 List ！ 但这样写就会显得很奇怪：既然对于 String、Int 这些类型，Compose 提供了 mutableStateOf，难道对于 List 这种这么常用的类型，就没有一个 mutable*** 的函数给我们用？ 那必须有！它就是 mutableStateListOf！它可以观测到内部 List 的数据变化！ 我们可以像下面这样申明： 12345678910var nums by mutableStateListOf(mutableListOf(1, 2, 3)) // 有红线标注，写法错误// mutableStateListOf 是内部元素被观测，而不是它本身被观测，所以我们要把 `by` 换成 `=`var nums = mutableStateListOf(mutableListOf(1, 2, 3))// `var` 也可以换成 `val`val nums = mutableStateListOf(mutableListOf(1, 2, 3))// mutableStateListOf 本身就代表一个可观测的 List，所以 mutableListOf 也可以去除val nums = mutableStateListOf(1, 2, 3) // 这就是最终的写法 这个时候我们就可以优化下代码了： 1234567891011121314151617181920class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val nums = mutableStateListOf(1, 2, 3) setContent { Column { Button(onClick = { nums.add(nums.last() + 1) }) { Text(&quot;List 加 1&quot;) } for (num in nums) { Text(&quot;第 $num 块文字&quot;) } } } }} 运行： 提到 List，我们就会想到 Map，同样 Map 也提供了一个 mutableStateMapOf！它也可以观测到内部 Map 的数据变化！ 12345678910111213141516171819class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val maps = mutableStateMapOf(1 to &quot;One&quot;, 2 to &quot;Two&quot;) setContent { Column { Button(onClick = { maps[3] = &quot;Three&quot; }) { Text(&quot;Maps 加 1&quot;) } for ((key, value) in maps) { Text(&quot;$key 对应 value: $value&quot;) } } } }} 运行：","link":"/2025/06/18/compose/Compose%20--%20%E7%8A%B6%E6%80%81%E8%AE%A2%E9%98%85%20&%20%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%20--%2004.%20mutableStateListOf/"},{"title":"你真的了解 Compose 的重组吗？","text":"重组先考虑一个问题，什么时候会「重组」？ 123val name by remember { mutableStateOf(&quot;Hi Compose&quot;)}val nums = mutableStateListOf(1, 2, 3)val maps = mutableStateMapOf(1 to &quot;One&quot;, 2 to &quot;Two&quot;) 通过之前的几篇文章，你应该对这三行代码不陌生，当用 mutableState*Of 申明一个变量的时候，在可组合项中，「如果变量变化了，就会触发重组」。 比如下面代码： 12345678910111213class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var name by mutableStateOf(&quot;Hi, Compose&quot;) setContent { Column { Text(name, Modifier.clickable { name = &quot;Hi, Kotlin&quot; }) } } }} 我们知道：Text(name) 被重组了，但是并不是仅仅是 Text(name) 被重组，而是整个 Lambda 表达式 被重组，我们之前说过，这就是「重组作用域（Recompose scope）」！。 那么我修改成如下代码，思考一个问题： 我们先看一个好玩的东西，查看 Column 函数： 1234567891011121314@Composableinline fun Column( modifier: Modifier = Modifier, verticalArrangement: Arrangement.Vertical = Arrangement.Top, horizontalAlignment: Alignment.Horizontal = Alignment.Start, content: @Composable ColumnScope.() -&gt; Unit) { val measurePolicy = columnMeasurePolicy(verticalArrangement, horizontalAlignment) Layout( content = { ColumnScopeInstance.content() }, measurePolicy = measurePolicy, modifier = modifier )} Column 是个 inline 函数（内联函数），这就意味着在实际编译之前，这个函数的调用会被替换成内部实际的代码。 比如会是下面这个样子： 12345678910111213141516class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var name by mutableStateOf(&quot;Hi, Compose&quot;) setContent { // Column { // 替换为 Layout( Text(name, Modifier.clickable { name = &quot;Hi, Kotlin&quot; }) ) // } } }} 再来看下 Layout()： 1234567891011@Composable inline fun Layout( content: @Composable @UiComposable () -&gt; Unit, modifier: Modifier = Modifier, measurePolicy: MeasurePolicy) { ... ReusableComposeNode&lt;ComposeUiNode, Applier&lt;Any&gt;&gt;( ... content = content )} Layout()也是个 inline 函数，那么代码又会变成这样： 123456789101112131415161718class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var name by mutableStateOf(&quot;Hi, Compose&quot;) setContent { // Column { // Layout( // 替换为 ReusableComposeNode( Text(name, Modifier.clickable { name = &quot;Hi, Kotlin&quot; }) ) // ) // } } }} 再来看下 ReusableComposeNode： 1234567891011@Composable @ExplicitGroupsComposableinline fun &lt;T, reified E : Applier&lt;*&gt;&gt; ReusableComposeNode( noinline factory: () -&gt; T, update: @DisallowComposableCalls Updater&lt;T&gt;.() -&gt; Unit, noinline skippableUpdate: @Composable SkippableUpdater&lt;T&gt;.() -&gt; Unit, content: @Composable () -&gt; Unit) { ... content() ...} 又是 inline 函数，而且你看它内部干了什么？- - 直接调用了 content()！ 所以最终代码在编译前其实会把 Column {} 给拿掉，就跟下面一样： 123456789101112131415161718class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var name by mutableStateOf(&quot;Hi, Compose&quot;) setContent { // Column { // Layout( // 替换为 // ReusableComposeNode( Text(name, Modifier.clickable { name = &quot;Hi, Kotlin&quot; }) // ) // ) // } } }} 那么这就意味着： 1234567891011121314151617class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var name by mutableStateOf(&quot;Hi, Compose&quot;) setContent { // 组件 1，这个地方会因为 name 的改变而一起重新调用 Column { // 组件 2，这个地方会因为 name 的改变而一起重新调用 Text(name, Modifier.clickable { name = &quot;Hi, Kotlin&quot; }) // 组件 3，这个地方会因为 name 的改变而一起重新调用 } // 组件4，这个地方会因为 name 的改变而一起重新调用 } }} 为了验证，我们测试下： 1234567891011121314151617class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var name by mutableStateOf(&quot;Hi, Compose&quot;) setContent { println(&quot;Recompose 范围测试 1&quot;) Column { println(&quot;Recompose 范围测试 2&quot;) Text(name, Modifier.clickable { name = &quot;Hi, Kotlin&quot; }) println(&quot;Recompose 范围测试 3&quot;) } println(&quot;Recompose 范围测试 4&quot;) } }} 运行： 这个 Log 没有任何问题，现在我们点击： Log 已经验证了我们刚才的结论，那这就涉及到了一个问题：性能风险！ 比如下面的代码有可能出现在你的代码中： 123456789101112131415161718192021222324class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var name by mutableStateOf(&quot;Hi, Compose&quot;) setContent { println(&quot;Recompose 范围测试 1&quot;) Column { println(&quot;Recompose 范围测试 2&quot;) Text(name, Modifier.clickable { name = &quot;Hi, Kotlin&quot; }) println(&quot;Recompose 范围测试 3&quot;) } NBFunction() println(&quot;Recompose 范围测试 4&quot;) } }}@Composablefun NBFunction() { println(&quot;Recompose 范围测试：我干了很多消耗性能的事～～～&quot;) // 这里面干了很多 NB 的事，逻辑量特别大} 你写了一个很牛逼的 Composable 函数，里面干了很多复杂的事，特别消耗性能，那么每次随着 name 的更改，NBFunction() 都会被执行一遍，就会存在巨大的性能消耗！ 你要不信，我们运行一下，看下 Log： … 额，好尴尬…，点击 name 后，NBFunction() 竟然没有再次执行？但其他 Log 仍然执行了啊！ 难道 NBFunction() 没有被调用？ 其实 NBFunction() 被调用了，只不过进入 NBFunction() 内部后，内部的代码没有被执行！ 都进来了，你跟我说内部代码不执行？ 且听我给你解释～ 其实这是因为：在 Compose 的编译过程中，编译器插件会做干预，这个干预过程会修改我们的 Compose 函数，比如说它会给函数内部的代码加上一些条件判断，判断这个函数的参数跟上一次函数被调用的时候传入的参数有没有改变，如果没有改变，就直接跳过这个函数的内部代码的执行，这是 Compose 的优化。 而你看 NBFunction() 这个函数有参数吗？- - 没有，所以它内部代码永远不会执行，所以 Log 肯定不会打印出来。 那我们加个参数测试一下： 12345678910111213141516171819202122232425class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var name by mutableStateOf(&quot;Hi, Compose&quot;) setContent { println(&quot;Recompose 范围测试 1&quot;) Column { println(&quot;Recompose 范围测试 2&quot;) Text(name, Modifier.clickable { name = &quot;Hi, Kotlin&quot; }) println(&quot;Recompose 范围测试 3&quot;) NBFunction(name) } println(&quot;Recompose 范围测试 4&quot;) } }}@Composablefun NBFunction(name: String) { println(&quot;Recompose 范围测试：我干了很多消耗性能的事～～～&quot;) // 这里面干了很多 NB 的事，逻辑量特别大 Text(&quot;$name&quot;)} 我们给 NBFunction 加个参数，那么随着 name 的改变，看看它会不会被执行： 结果显而易见了！Compose 重组过程中会判断 NBFunction() 的参数 String 是否变化。 那么如果我的参数是一个对象呢？ 比如我传入的是： 1data class User(val name: String) Compose 在重组过程中，依然会对对象类型的参数做判断，不过它的判断规则是 Kotlin 中的 ==，等同于 Java 的 equals，是结构性相等判断。 现在我们修改下代码： 12345678910111213141516171819202122232425262728293031class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var name by mutableStateOf(&quot;Hi, Compose&quot;) var user = User(&quot;marco&quot;) // User 对象 setContent { println(&quot;Recompose 范围测试 1&quot;) Column { println(&quot;Recompose 范围测试 2&quot;) Text(name, Modifier.clickable { name = &quot;Hi, Kotlin&quot; user = User(&quot;marco&quot;) // 点击后，新的 User 对象 }) println(&quot;Recompose 范围测试 3&quot;) NBFunction(user) } println(&quot;Recompose 范围测试 4&quot;) } }}@Composablefun NBFunction(user: User) { println(&quot;Recompose 范围测试：我干了很多消耗性能的事～～～&quot;) // 这里面干了很多 NB 的事，逻辑量特别大 Text(&quot;${user.name}&quot;)}data class User(val name: String) 代码很简单，我们通过 Log 验证下： 我们再改下代码，把 User 换成一个新的内容： 123456var user = User(&quot;marco&quot;)Text(name, Modifier.clickable { name = &quot;Hi, Kotlin&quot; user = User(&quot;marco_2&quot;)}) 再看下 Log： 确实如我们前面预想一样，Compose 重组过程中同样会对 NBFunction() 的「对象参数」也做判断，是结构性相等判断。 @Stable接下来看个有趣的东西，我们再来改一下代码： 123456789101112131415var user = User(&quot;marco&quot;)Text(name, Modifier.clickable { name = &quot;Hi, Kotlin&quot; user = User(&quot;marco&quot;). // user 改回来，都是 marco 内容})==&gt; 此时肯定是会判断相等，不会执行 NBFunction() 内部的代码// 注意了：==&gt; 接下来我们只改一下关键字：data class User(val name: String)// val --&gt; vardata class User(var name: String) 仅仅把 val 改成 var，运行看 Log： Why ???? val 就会跳过 NBFunction() 内部代码，而 var 就不会跳过 NBFunction() 内部代码！ 其实，这是因为 Compose 的本身机制设定： 12data class User(val name: String) // Compose 会认为这是一个可靠的类data class User(var name: String) // Compose 会认为这是一个不可靠的类 对于不可靠的类，我就不管你了，直接进！这也是出于对界面正确性的考虑。 比如我们修改下代码： 与性能相比，准确性才是最终要的，所以就会无条件的进入 NBFunction() 函数再执行一遍。 那如果假设我们可以保证不会出现以上情况，保证 User 对象永远相等，希望 Composable 插件也可以跳过内部执行，提升性能，如何做呢？ 用 @Stable 注解，它是一个稳定性注解，告诉 Compose 编译器插件，这个类是可靠的。这样 Compose 重组过程中就会跳过 NBFunction() 内部代码。 12@Stabledata class User(var name: String) 运行看下 Log： 除了 @Stable 可以认定可靠以外，还有一种方式可以告诉 Compose 是可靠的： 123class User(name: String) { var name by mutableStateOf(name) // 这是一种更通用的写法}","link":"/2025/06/22/compose/Compose%20--%20%E7%8A%B6%E6%80%81%E8%AE%A2%E9%98%85%20&%20%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%20--%2005.%20%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E9%87%8D%E7%BB%84%E5%90%97%EF%BC%9F/"},{"title":"细说 remember 和重组作用域","text":"基于 androidx.compose.runtime:runtime:1.7.1 版本 阅读本篇文章之前，建议先看看【 解析 mutableStateOf 源码 】 一文，因为两篇文章是上下篇的关系，看完上篇，可以更好的串联知识点。 Simple Code 话不多说，还是老样子，从 Demo 一步步引出我们的核心知识点。 1234567891011121314151617class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) var name by mutableStateOf(&quot;Compose&quot;) setContent { Text(name) // 延时更新 Text 内容 LaunchedEffect(true) { delay(3000) name = &quot;Kotlin&quot; } } }} 一段很简单的代码示例，3s 后文字从 Compose 变为 kotlin，执行看下效果： 现在我们改下代码： 1234567891011121314151617class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { // 从外面挪到里面来... var name by mutableStateOf(&quot;Compose&quot;) Text(name) // 延时更新 Text 内容 LaunchedEffect(true) { delay(3000) name = &quot;Kotlin&quot; } } }} 执行看下效果： 奇怪的事情发生了，3s 后文字没有刷新！ 重组作用域 问题出在哪？ 首先我们回顾下 Compose 是怎么「刷新界面」的？比如上面的例子，当 name 重新赋值后，读取它的地方会被标记为「失效」，然后「重组刷新」。 关键知识点 在 Compose 中「重组刷新」并不是单纯的刷新 Text(name) 这一行，而是会把包含 Text(name) 的代码块给包起来，刷新的是「整个代码块」，或者说重组「整个代码块」！ 就像下面这个样子： 这段蓝色背景的代码块会被重新执行一遍，这个蓝色区域就是所谓的：重组作用域（Recompose scope）！ 所以导致没有刷新的根本原因就是： 不仅仅 Text(name) 会被重新执行，var name by mutableStateOf(&quot;Compose&quot;) 也会执行！导致 name 又被重新初始化了。 remember那怎么解决？不知道你发现没有，其实开发工具已经提示我们了： mutableStateOf 是标红的，并且错误提示：Creating a state object during composition without using remember. 意思就是：你在组合过程里面创建了 StateObject 对象，但是没有用 remember。 那怎么使用？很简单，只需要套一层 remember，代码如下： 123456789101112131415class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { var name by remember { mutableStateOf(&quot;Compose&quot;) } Text(name) LaunchedEffect(true) { delay(3000) name = &quot;Kotlin&quot; } } }} 加了 remember 后，在第一次执行的时候，会执行 Lambda 表达式，也就是执行 mutableStateOf(&quot;Compose&quot;)，并且 remember 会保存结果（StateObject），再次调用的时候会直接返回保存的老对象（StateObject），而不是再次执行 Lambda 表达式里面的代码，相当于充当了「缓存」的功能。 我们执行下修改后的代码： 文字更新了！remember 起到了缓存的作用，就是为了防止多次初始化变量而导致程序不可控！ 所以有个原则 在 Compose 里面你只要用了 mutableStateOf，那么能加 remember 我们就加 remember。 另外我们需要注意 remember 是可以带参数的：可以「一个」或者「多个」参数。 1234567891011121314151617181920212223242526272829📄 androidx.compose.runtime -&gt; Composables.kt/** * Remember the value returned by [calculation] if [key1] is equal to the previous composition, * otherwise produce and remember a new value by calling [calculation]. */@Composableinline fun &lt;T&gt; remember( key1: Any?, calculation: @DisallowComposableCalls () -&gt; T): T { return currentComposer.cache(currentComposer.changed(key1), calculation)}/** * Remember the value returned by [calculation] if [key1] and [key2] are equal to the previous * composition, otherwise produce and remember a new value by calling [calculation]. */@Composableinline fun &lt;T&gt; remember( key1: Any?, key2: Any?, calculation: @DisallowComposableCalls () -&gt; T): T { return currentComposer.cache( currentComposer.changed(key1) or currentComposer.changed(key2), calculation )} 有什么用，举个例子说明，比如我们自定义了一个 Composable 函数： 12345@Composablefun showCharCount(value: String) { val length = value.length Text(&quot;字符串长度：$length&quot;)} 很简单，一个显示字符串长度的函数。 现在我们来假设一个场景： 传入进来的字符串特别长； 并且 showCharCount 反复被调用了很多次； 那么 value.length 每次都被调用，就显得有点笨重了，所以我们可以给它加上一个 remember： 1234567@Composablefun showCharCount(value: String) { val length = remember { value.length } Text(&quot;字符串长度：$length&quot;)} 但此时就会出现一个问题： 12345678910@Composablefun showCharCount(value: String) { // 第一次传进来：abcd // 第二次传进来：abcdefg // 第三次传进来：abcdefghijklmn val length = remember { value.length } Text(&quot;字符串长度：$length&quot;)} 字符串长度永远都是：4，因为 value.length 不会被执行，那怎么办： 12345678910@Composablefun showCharCount(value: String) { // 第一次传进来：abcd // 第二次传进来：abcdefg // 第三次传进来：abcdefghijklmn val length = remember(value) { value.length } Text(&quot;字符串长度：$length&quot;)} 我们给 remember 加了一个参数：value，只要这个 key 变化了，那么就会重新执行 Lambda 表达式，这就是带参数的 remember 的用法。","link":"/2025/06/07/compose/Compose%20--%20%E7%8A%B6%E6%80%81%E8%AE%A2%E9%98%85%20&%20%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%20--%2002.%20remember%20%E5%92%8C%E9%87%8D%E7%BB%84%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"title":"解析 DrawModifier","text":"“Jetpack Compose - - Modifier 原理系列文章 “ &nbsp;&nbsp;&nbsp;&nbsp;📑 《 深度解析 Compose 的 Modifier 原理 - - Modifier、CombinedModifier 》 &nbsp;&nbsp;&nbsp;&nbsp;📑 《 深度解析 Compose 的 Modifier 原理 - - Modifier.composed()、ComposedModifier 》 &nbsp;&nbsp;&nbsp;&nbsp;📑 《 深度解析 Compose 的 Modifier 原理 - - Modifier.layout()、LayoutModifier 》 &nbsp;&nbsp;&nbsp;&nbsp;📑 《 深度解析 Compose 的 Modifier 原理 - - DrawModifier 》 &nbsp;&nbsp;&nbsp;&nbsp;📑 《 深度解析 Compose 的 Modifier 原理 - - PointerInputModifier 》 &nbsp;&nbsp;&nbsp;&nbsp;📑 《 深度解析 Compose 的 Modifier 原理 - - ParentDataModifier 》 在正式开始分析 DrawModifier 之前，建议你先看看 【LayoutModifier 和 Modifier.layout 用法及原理】这篇文章，毕竟它是作为 Modifier 原理解析的第一篇文章，对你了解整个 Modifier 架构还是很有帮助的，或者说它是最基础的一篇文章，如果不熟悉，后面的系列 Modifier 你可能会看的比较费劲… 一、话题引入 老样子，我们从 Demo 开始，首先我们看两个简单的场景： 1.1 问题场景 1一个绿色背景的 Text()： 123456789101112class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.background(Color.Green)) { Text(&quot;Hi Compose&quot;) } } } }} 效果如下： ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/2f6fbfcdc180b9670cfce0abb8236bf4.png =500x) 如果我改动一下代码： 12345678910111213class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.background(Color.Green).size(120.dp)) { Text(&quot;Hi Compose&quot;) } } } }} 只是给 Box 加了一个尺寸： ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/14eca7bc86b124dccb8a26fb7e731a28.png =500x) 嗯，效果不错，那如果我再改一次呢？ 12345678910111213class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.background(Color.Green).size(120.dp).background(Color.Red)) { Text(&quot;Hi Compose&quot;) } } } }} 又加了一个 background，看下效果： ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/da9a778662bd7af48e1d253c5f9edb8f.png =500x) 思考一个问题：为什么此时的 Box 是红色，而不是绿色？ 如果你看了 LayoutModifier 的原理解析，这边就会产生一个困惑：Modifier 不是从右边开始，依次往左遍历，最终应该是绿色背景，而不应该是红色背景啊？ 所以，问题出在哪？我们不妨先简单看下 Modifier.background() 源码： 1234567891011fun Modifier.background( color: Color, shape: Shape = RectangleShape): Modifier { val alpha = 1.0f // for solid colors return this.then( BackgroundElement( ... ) )} 它又调用了 BackgroundElement： 123private class BackgroundElement( ...) : ModifierNodeElement&lt;BackgroundNode&gt;() { 看过之前 LayoutModifier 解析的文章的话，这边你应该不会陌生了吧？BackgroundElement 会转换成一个 BackgroundNode 对象，它是实际的链表节点。 123private class BackgroundNode( ...) : DrawModifierNode, Modifier.Node() { 它是一个 DrawModifierNode，所以是 DrawModifierNode 影响了背景的绘制？ 1.2 问题场景 2在之前我们分析 LayoutModifier 文章中提到过：如果我们需要自己创建一个 LayoutModifier，可以通过 Modifier.layout()，同样的如果我们要创建一个 DrawModifier，可以通过 Modifier.drawWithContent()，比如： 12345678910111213class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.background(Color.Green).size(120.dp).drawWithContent { }) { Text(&quot;Hi Compose&quot;) } } } }} 看下效果： ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/9f3a175fff1af88c1f664b79614393de.png =500x) ？？？不对啊，Text() 哪去了？我现在再来修改下代码： 12345678910111213class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.background(Color.Green).size(120.dp).drawWithContent { drawContent() }) { Text(&quot;Hi Compose&quot;) } } } }} 仅仅是在 drawWithContent 里面加了一个 drawContent()，再看下效果： ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/12aed22080dd8c7f7e7c25cc200a1ad4.png =500x) Text() 又出来了，为什么？为什么要加 drawContent()， drawContent() 又是什么？难道它负责绘制 Text()？ 接下来，我们就带着这两个问题正式进入这篇文章的主题！ 二、DrawModifierNode 查看 Modifier.background() 和 Modifier.drawWithContent() 的源码，发现它们背后的 BackgroundElement 和 DrawWithContentElement 都继承自 ModifierNodeElement&lt;N : Modifier.Node&gt;。 1234567891011121314151617181920212223242526272829303132&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Modifier.background() &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;fun Modifier.background(...): Modifier { val alpha = 1.0f // for solid colors return this.then( BackgroundElement( ... ) )}private class BackgroundElement( ...) : ModifierNodeElement&lt;BackgroundNode&gt;()private class BackgroundNode( ...) : DrawModifierNode, Modifier.Node()&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Modifier.drawWithContent() &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;fun Modifier.drawWithContent( onDraw: ContentDrawScope.() -&gt; Unit): Modifier = this then DrawWithContentElement(onDraw)private data class DrawWithContentElement( val onDraw: ContentDrawScope.() -&gt; Unit) : ModifierNodeElement&lt;DrawWithContentModifier&gt;()private class DrawWithContentModifier( var onDraw: ContentDrawScope.() -&gt; Unit) : Modifier.Node(), DrawModifierNode { ....} 而且泛型类型 BackgroundNode 和 DrawWithContentModifier 都实现了 DrawModifierNode 接口。 画了个图，看着更直观： 这个 DrawModifierNode 接口就是 Draw 修饰符的核心，它定义了 Draw 修饰符的核心逻辑。 123456789101112/** * A [Modifier.Node] that draws into the space of the layout. * * This is the [androidx.compose.ui.Modifier.Node] equivalent of * [androidx.compose.ui.draw.DrawModifier] * * @sample androidx.compose.ui.samples.DrawModifierNodeSample */interface DrawModifierNode : DelegatableNode { fun ContentDrawScope.draw() // draw 绘制方法 fun onMeasureResultChanged() {}} 那么，我们要探究 Draw 修饰符如何影响元素绘制过程，重点就是看元素的绘制在哪用到了 DrawModifierNode，或者更准确地说，DrawModifierNode 的 draw() 方法在何处被调用了。 三、 DrawModifierNode 对绘制的影响 现在我们已经很清楚 LayoutNode 是如何处理 DrawModifierNode 的了，接下来我们就看看 DrawModifierNode 是如何对绘制产生精细影响的。 在 LayoutNode 中，绘制是由 draw() 函数处理的。 1234567// LayoutNode.ktinternal class LayoutNode(...) : ... { internal val outerCoordinator: NodeCoordinator get() = nodes.outerCoordinator internal fun draw(canvas: Canvas) = outerCoordinator.draw(canvas)} 看过之前 LayoutModifierNode 解析的文章后，我们已经知道 outerCoordinator 是一个 NodeCoordinator。 3.1 NodeCoordinator.draw()现在我们来看看 NodeCoordinator 的 draw() 方法： 1234567891011121314151617181920// NodeCoordinator.ktinternal abstract class NodeCoordinator( override val layoutNode: LayoutNode,) : ... { fun draw(canvas: Canvas) { // layer: 是一个独立绘制的图层，它只是在一块额外的区域绘制而已，大多数时候是没有的 val layer = layer if (layer != null) { layer.drawLayer(canvas) } else { val x = position.x.toFloat() val y = position.y.toFloat() canvas.translate(x, y) drawContainedDrawModifiers(canvas) // 关键代码 canvas.translate(-x, -y) } }} 大多数情况下，我们并不需要考虑 layer 图层，所以这里可以当它为 null 处理。所以我们只需要关心 else 分支内部的逻辑，核心代码就一行：drawContainedDrawModifiers(canvas)。 3.2 drawContainedDrawModifiers()12345678910111213141516// NodeCoordinator.ktinternal abstract class NodeCoordinator( override val layoutNode: LayoutNode,) : ... { private fun drawContainedDrawModifiers(canvas: Canvas) { val head = head(Nodes.Draw) if (head == null) { performDraw(canvas) } else { val drawScope = layoutNode.mDrawScope drawScope.draw(canvas, size.toSize(), this, head) } } } 这段代码的逻辑很清晰，主要就是三步： 获取当前 NodeCoordinator 范围内的的第一个 Draw 修饰符 1val head = head(Nodes.Draw) 表头如果为空，也就是没有设置过 DrawModifier 123if (head == null) { performDraw(canvas)} 那么就会执行 performDraw()，我们来看看它做了什么： 123open fun performDraw(canvas: Canvas) { wrapped?.draw(canvas)} wrapped 是什么？ 1internal open val wrapped: LayoutNodeWrapper? get() = null 它就是当前的 LayoutNodeWrapper 对象，而 LayoutNodeWrapper 是一个抽象类。 注意： 我们现在分析的场景是没有设置 DrawModifier，那么实际代码可能是这样： 1Box(Modifier.padding(10.dp).size(120.dp)) 对应的内部 Modifier 的结构大概是这个样子： 123456789ModifiedLayoutNode[ LayoutModifier // padding(10.dp) + ModifiedLayoutNode[ LayoutModifier // size(120.dp) + innerLayoutNodeWrapper // Box() ]] ModifiedLayoutNode 本身就是一个 LayoutNodeWrapper 的子类，所以，你现在知道上面的 wrapped 是什么了吗？ 123456789ModifiedLayoutNode[ // wrapped LayoutModifier + ModifiedLayoutNode[ // wrapped LayoutModifier + innerLayoutNodeWrapper // wrapped ]] 再来看看 wrapped.draw() 干了什么： 123456789101112fun draw(canvas: Canvas) { val layer = layer if (layer != null) { layer.drawLayer(canvas) } else { val x = position.x.toFloat() val y = position.y.toFloat() canvas.translate(x, y) drawContainedDrawModifiers(canvas) canvas.translate(-x, -y) }} 又跳回 draw() 函数了，而你还记得 drawContainedDrawModifiers 是干嘛的吗？它的核心就是用来检查是否有 DrawModifier 的链表的表头，如果没有就一直往内部找： 123456789ModifiedLayoutNode[ LayoutModifier // padding(10.dp) --&gt; 没有设置 DrawModifier，就去找内部有没有设置 DrawModifier + ModifiedLayoutNode[ LayoutModifier // size(120.dp) --&gt; 没有设置 DrawModifier，就去找内部有没有设置 DrawModifier + innerLayoutNodeWrapper // Box() --&gt; 没有设置 DrawModifier，它没有内部了，就不找了 ]] 所以我们总结下：不管你设置了多少 Modifier.**，在绘制的时候，都会遍历一遍，只要没有 DrawModifier 就不会进行任何绘制动作。 表头不为空，有设置 DrawModifier 123else { head.draw(canvas)} 如果我们设置了 DrawModifier：比如 Modifier.background()，那么就会执行 head.draw()，我们再来看看它又做了什么： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// DrawEntity.ktfun draw(canvas: Canvas) { ... ... val drawScope = layoutNode.mDrawScope // 1. 核心代码，看看 drawScope.draw() 做了什么工作 drawScope.draw(canvas, size, layoutNodeWrapper, this) { with(drawScope) { with(modifier) { draw() } } }}// LayoutNodeDrawScope.ktinternal inline fun draw( canvas: Canvas, size: Size, layoutNodeWrapper: LayoutNodeWrapper, drawEntity: DrawEntity, block: DrawScope.() -&gt; Unit) { val previousDrawEntity = this.drawEntity this.drawEntity = drawEntity // 2. 核心代码 canvasDrawScope.draw( layoutNodeWrapper.measureScope, layoutNodeWrapper.measureScope.layoutDirection, canvas, size, block ) this.drawEntity = previousDrawEntity}// CanvasDrawScope.ktinline fun draw( density: Density, layoutDirection: LayoutDirection, canvas: Canvas, size: Size, block: DrawScope.() -&gt; Unit) { ... ... this.block() // 3. 核心代码 ... ...} 最终调用了 block()，这个 block 太熟了，它肯定是一个传进来的 Lambda 表达式，也就是： ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/6980d794c11d4de2db9540cf3ce46a45.png =700x) 所以我们的重点就转移到研究这段 lambda 表达式的工作内容了。 它里面也有一个 draw()，我们看看它做了啥： 123456// DrawModifier.kt@JvmDefaultWithCompatibilityinterface DrawModifier : Modifier.Element { fun ContentDrawScope.draw()} 咦？是 DrawModifier 接口的 draw() 方法，那肯定有某个这个接口的实现类实现了这个 draw() 方法，我们可以搜索下看看： 看到没，Background！ 所以我们现在可以来看下 Background 的内部的 draw() 逻辑： 123456789101112131415private class Background constructor( ... ...) : DrawModifier, InspectorValueInfo(inspectorInfo) { override fun ContentDrawScope.draw() { if (shape === RectangleShape) { // shortcut to avoid Outline calculation and allocation drawRect() } else { drawOutline() } drawContent() }} 细心的你是不是发现了 drawContent()？ 还记得我们文章开头第二个疑惑的问题吗？我们回顾一下代码： 12345678910111213class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.background(Color.Green).size(120.dp).drawWithContent { drawContent() }) { Text(&quot;Hi Compose&quot;) } } } }} 现在我们就可以来看看 drawWithContent 的内部代码： 1234567891011121314151617181920// DrawModifier.ktfun Modifier.drawWithContent( onDraw: ContentDrawScope.() -&gt; Unit): Modifier = this then DrawWithContentElement(onDraw)private data class DrawWithContentElement( val onDraw: ContentDrawScope.() -&gt; Unit) : ModifierNodeElement&lt;DrawWithContentModifier&gt;() { override fun create() = DrawWithContentModifier(onDraw) // 创建 DrawWithContentModifier ... ...}private class DrawWithContentModifier( var onDraw: ContentDrawScope.() -&gt; Unit) : Modifier.Node(), DrawModifierNode { override fun ContentDrawScope.draw() { onDraw() // 这不就类似于 block？ }} 所以实际上调用的是啥？ 也就是调用了 drawContent()。 所以不管是 Modifier.background() 还是你自己 drawWithContent()，都会/需要调用 drawContent() 函数。 所以，现在我们就可以重点研究下 drawContent() 到底是做了什么了！ 123456interface ContentDrawScope : DrawScope { /** * Causes child drawing operations to run during the `onPaint` lambda. */ fun drawContent()} 又是一个接口内部的方法，再搜一下哪个地方实现了 - - 全局只有一个地方实现了，如下： 12345678910111213141516171819internal class LayoutNodeDrawScope( private val canvasDrawScope: CanvasDrawScope = CanvasDrawScope()) : DrawScope by canvasDrawScope, ContentDrawScope { private var drawEntity: DrawEntity? = null override fun drawContent() { drawIntoCanvas { canvas -&gt; val drawEntity = drawEntity!! val nextDrawEntity = drawEntity.next if (nextDrawEntity != null) { nextDrawEntity.draw(canvas) } else { drawEntity.layoutNodeWrapper.performDraw(canvas) } } } ... ...} drawIntoCanvas 是什么？ 1inline fun DrawScope.drawIntoCanvas(block: (Canvas) -&gt; Unit) = block(drawContext.canvas) 又是一个 block，所以我们只关心 lambda 表达式内部的逻辑即可，分两步走： 如果 DrawModifier 链表的下一个节点为 null，说明只有一个 DrawModifier 链表头或没有更多 DrawModifier，这个时候就会让下一个 LayoutNodeWrapper 查找其内部有没有 DrawModifier。 比如： 1Box(Modifier.padding(10.dp).background(Color.Red).size(120.dp)) 对应的内部 Modifier 的结构大概是这个样子： 1234567891011ModifiedLayoutNode1( PaddingModifier, [null, null, null, null, null, null, null] ModifiedLayoutNode2( SizeModifier, [DrawModifier, null, null, null, null, null, null] // 现在 DrawModifier 是表头 innerLayoutNodeWrapper( [null, null, null, null, null, null, null] ) )) 现在针对这个场景，只有一个 DrawModifier，它是表头，并且它没有下一个节点了，那么就会执行： 1drawEntity.layoutNodeWrapper.performDraw(canvas) 具体处理流程如下： &nbsp;&nbsp;&nbsp;&nbsp;==&gt; ModifiedLayoutNode1 没有 DrawModifier，继续下一个节点 ModifiedLayoutNode2 查找有没有 DrawModifier； &nbsp;&nbsp;&nbsp;&nbsp;==&gt; ModifiedLayoutNode2 有 DrawModifier，DrawModifier.draw() 调用绘制，DrawModifier 链表没有下一个 DrawModifier，继续下一个节点 InnerNodeCoordinator 查找有没有 DrawModifier； &nbsp;&nbsp;&nbsp;&nbsp;==&gt; InnerNodeCoordinator 没有 DrawModifier，绘制结束 如果 DrawModifier 链表的下一个节点不为 null，说明还有 DrawModifier，从 DrawModifier 链表头开始遍历调用 DrawModifier 处理绘制。 比如： 1Box(Modifier.padding(10.dp).background(Color.Red).background(Color.Blue).size(120.dp)) 对应的内部 Modifier 的结构大概是这个样子： 1234567891011ModifiedLayoutNode1( PaddingModifier, [null, null, null, null, null, null, null] ModifiedLayoutNode2( SizeModifier, [DrawModifier2 -&gt; DrawModifier1, null, null, null, null, null, null] innerLayoutNodeWrapper( [null, null, null, null, null, null, null] ) )) 现在针对这个场景，表头有下一个节点了，那么就会执行： 1nextDrawEntity.draw(canvas) 跳转一下看看： 123456789101112fun draw(canvas: Canvas) { ... ... val drawScope = layoutNode.mDrawScope drawScope.draw(canvas, size, layoutNodeWrapper, this) { with(drawScope) { with(modifier) { draw() } } }} 这段代码熟悉吗？DrawModifier2 绘制完，调用 drawContent()，让 DrawModifier1 开始绘制。 drawContent() 是通知当前 DrawModifier 下一级的 LayoutNodeWrapper 的 DrawModifier 处理绘制。所以如果有一个 DrawModifier 没有调用 drawContent()，相当于链条断开不会通知内部的 DrawModifier 去绘制。","link":"/2025/08/16/compose/Compose%20--%20Modifier%20--%2004.%20%E8%A7%A3%E6%9E%90%20DrawModifier/"},{"title":"解析 ComposedModifier","text":"在正式开始分析这篇文章的主角之前，建议你先看看 【解析 Modifier &amp; CombinedModifier】 一文，作为 Modifier 原理系列的第一篇开山之作，它是一个根，必须掌握！ 我们直接进入主题，查看 ComposedModifier 源码： 123456📄 androidx.compose.ui.ComposedModifier.ktprivate open class ComposedModifier( inspectorInfo: InspectorInfo.() -&gt; Unit, val factory: @Composable Modifier.() -&gt; Modifier) : Modifier.Element, InspectorValueInfo(inspectorInfo) 细心的你会发现 ComposedModifier 是个私有函数，你是没有办法直接创建的。所以如果我们要创建一个 ComposedModifier，则需要使用 Modifier.composed() 扩展函数： 1234567891011class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Modifier.composed { } } } }} 这样，Modifier.composed() 扩展函数会帮我们创建出一个 ComposedModifier。 12345678📄 androidx.compose.ui.ComposedModifier.ktfun Modifier.composed( inspectorInfo: InspectorInfo.() -&gt; Unit = NoInspectorInfo, factory: @Composable Modifier.() -&gt; Modifier): Modifier = this.then(ComposedModifier(inspectorInfo, factory))==&gt; this.then() ... 熟悉吧？是不是得到了一个 ComposedModifier？ 看到这里，你应该会有疑问三连了： 🤔🤔 ComposedModifier 是个啥？ 🤔🤔 为什么要创建一个 ComposedModifier ？ 🤔🤔 什么时候又该创建一个 ComposedModifier ？ 带着这三个疑问，我们开始继续探讨 ComposedModifier 的精髓 … … 首先我直接告诉你 ComposedModifier 的作用：ComposedModifier 的作用是通过 factory 工厂函数在组合过程中执行 factory 创建出 Modifier 并使用。 这段定义看不懂没关系，跟着我的节奏来，比如看下面这段简单的代码示例： 1234567891011class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Modifier.padding(10.dp) } } }} 正常情况下这么写，当执行到 Modifier.padding() 的时候，会立即创建出一个 PaddingElement，这个你应该很清楚了。 现在我调整下代码： 1234567891011class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Modifier.composed { Modifier.padding(10.dp) } } } }} 这里我把 Modifier.padding() 给包进了 ComposedModifier 里面，那么当程序执行到这段代码的时候，你觉得 Modifier.padding() 还会立即执行吗？ 不着急回答这个问题，我们再回顾一遍 ComposedModifier 的定义：ComposedModifier 的作用是通过 factory 工厂函数在组合过程中执行 factory 创建出 Modifier 并使用。 这个时候我们可以拆分下定义了，主要就是两个核心： 组合过程中 执行 factory 创建出 Modifier 先来看下第二点，我们其实从刚刚 Modifier.composed 函数定义就能看出来了： 那么第一点：组合过程中，该如何理解？其实很好理解，你既然创建了 Modifier，肯定要用起来，那么我们就来看看在组合过程中 ComposedModifier 是如何发挥作用的。 我现在再来改下代码： 1234567891011class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Box(Modifier.composed { Modifier.padding(10.dp) }) } } }} 所以现在我们就来看看 Box() 内部是在哪里执行 factory 工厂函数的。 跳转到 Box()： 123456📄 androidx.compose.foundation.layout.Box.kt@Composablefun Box(modifier: Modifier) { Layout(measurePolicy = EmptyBoxMeasurePolicy, modifier = modifier)} 跳转到 Layout()： 12345678910111213141516171819202122📄 androidx.compose.ui.layout.Layout.kt@Composable@UiComposableinline fun Layout( modifier: Modifier = Modifier, measurePolicy: MeasurePolicy) { val compositeKeyHash = currentCompositeKeyHash val materialized = currentComposer.materialize(modifier) val localMap = currentComposer.currentCompositionLocalMap ReusableComposeNode&lt;ComposeUiNode, Applier&lt;Any&gt;&gt;( factory = ComposeUiNode.Constructor, update = { set(measurePolicy, SetMeasurePolicy) set(localMap, SetResolvedCompositionLocals) set(materialized, SetModifier) @OptIn(ExperimentalComposeUiApi::class) set(compositeKeyHash, SetCompositeKeyHash) }, )} 关注 materialize()： 12345678910📄 androidx.compose.ui.ComposedModifier.ktfun Composer.materialize(modifier: Modifier): Modifier { // A group is required here so the number of slot added to the caller's group // is unconditionally the same (in this case, none) as is now required by the runtime. startReplaceGroup(0x1a365f2c) // Random number for fake group key. Chosen by fair die roll. val result = materializeImpl(modifier) endReplaceGroup() return result} 继续跟踪 materializeImpl()： 1234567891011121314151617181920212223private fun Composer.materializeImpl(modifier: Modifier): Modifier { if (modifier.all { it !is ComposedModifier }) { return modifier } startReplaceableGroup(0x48ae8da7) val result = modifier.foldIn&lt;Modifier&gt;(Modifier) { acc, element -&gt; acc.then( if (element is ComposedModifier) { @Suppress(&quot;UNCHECKED_CAST&quot;) val factory = element.factory as Modifier.(Composer, Int) -&gt; Modifier val composedMod = factory(Modifier, this, 0) materializeImpl(composedMod) } else { element } ) } endReplaceableGroup() return result} 好熟悉呀，出现了 foldIn()！我们来解读一下这段代码： 这么一分解，现在你应该很清楚 ComposedModifer 的工厂函数在哪里调用了吧？ 但是问题又来了，这么费劲搞一个 ComposedModifier 有啥意义？ 12Box(Modifier.composed { Modifier.padding(10.dp) })Box(Modifier.padding(10.dp) // 我这么写不就行了？ 我们来看下 Modifier.composed 函数的说明： 注意几个关键词：1. stateful modifiers：有状态的 Modifier；2. reused：重用；3. element-specific state：状态独有。 该如何理解这几个词的意思呢？ 来看以下代码： 12345678910111213141516171819class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { // 写法 1 val modifier1 = Modifier.composed { Modifier.padding(10.dp) } Box(modifier1) Text(&quot;Compose&quot;, modifier1) // 写法 2 val modifier2 = Modifier.padding(10.dp) Box(modifier2) Text(&quot;Compose&quot;, modifier2) } } }} 请问：写法 1 和写法 2 有什么区别？ 我相信你经过上面 ComposedModifier 的解析流程，应该可以很清晰知道：写法 1 和写法 2 唯一的区别就在于，写法 1 的 Modifier.padding() 会延迟创建（由 ComposedModifier 的 factory 函数创建），它们两者的运行显示结果没有任何区别。 实际上 Modifier.composed() 不是用在案例写的这种场景下，而是用在有状态的 Modifier 的场景。 什么叫有状态的 Modifier？ 按上面的例子 10.dp 就是一个状态，不过因为在这里已经写死了数值所以 Modifier.padding() 是无状态的，进而 Modifier.composed() 也是无状态的。 现在我们来改下代码： 12345678910111213141516class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { val modifier = Modifier.composed { var padding by remember { mutableStateOf(10.dp) } Modifier.padding(padding) } Box(modifier) Text(&quot;Compose&quot;, modifier) } } }} 我们把 10.dp 提取出来，这样 Modifier.padding() 就是有状态的了。 现在 Modifier.padding() 就是有状态的，进而 Modifier.composed() 就是有状态的，现在我们再回顾下 Modifier.composed 函数注解： 1. stateful modifiers：有状态的 Modifier；2. reused：重用；3. element-specific state：状态独有 再结合这个例子： 12345678910111213141516class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { val modifier = Modifier.composed { var padding by remember { mutableStateOf(10.dp) } Modifier.padding(padding) // 1. stateful modifiers：有状态的 Modifier } Box(modifier) // 2. reused：重用 Text(&quot;Compose&quot;, modifier) // 2. reused：重用 } } }} 是不是满足了两条？那 “状态独有” 又是什么意思？该怎么验证呢？ 来，我们再改下代码： 1234567891011121314151617181920class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { val modifier = Modifier.composed { var padding by remember { mutableStateOf(10.dp) } Modifier .padding(padding) .clickable { padding = 0.dp } } Column { Box(Modifier.background(Color.Red) then modifier) Text(&quot;Compose&quot;, Modifier.background(Color.Blue) then modifier) } } } }} 这里我们对 Modifier 又加了一个点击操作：修改 padding 值为 0，看下运行效果： 发现什么没？Text() 组件点击后，padding 修改为 0，却没有影响到 Box 的 padding，这就是 Modifier 状态独有！ 那我们再试试不用 Modifier.composed() 函数包起来的场景，比如代码如下： 123456789101112131415161718class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { var padding by remember { mutableStateOf(10.dp) } val modifier = Modifier .padding(padding) .clickable { padding = 0.dp } Column { Box(Modifier.background(Color.Red) then modifier) Text(&quot;Compose&quot;, Modifier.background(Color.Blue) then modifier) } } } }} 这段代码不难理解吧？来看下效果： 发现没？它们共享了 padding，点击任何一个组件，都会影响到另外一个的 padding。 所以到这里，我们就可以总结下 Modifier.compose() 函数的作用了：它会创建一个带状态的 Modifier，这个 Modifier 可以重用，并且状态是独立的。 但是！但是！但是！细心的你应该又会有一个疑问：这有点 “废” 啊，我可以有更简单的写法啊，比如： 123456789101112131415161718class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { var padding1 by remember { mutableStateOf(10.dp) } val modifier1 = Modifier.padding(padding1).clickable { padding1 = 0.dp } var padding2 by remember { mutableStateOf(10.dp) } val modifier2 = Modifier.padding(padding2).clickable { padding2 = 0.dp } Column { Box(Modifier.background(Color.Red) then modifier1) Text(&quot;Compose&quot;, Modifier.background(Color.Blue) then modifier2) } } } }} 既然不想 Box() 和 Text() 的 padding 相互影响，那么分别给它们设置一个 Modifier 不就行了？何必要用 Modifier.composed() 这种花里胡哨，看上去更高端的方法呢？这段代码的逻辑看上去岂不是更清晰？ 实际上 Modifier.composed() 的使用场景是：当我们需要创建的 Modifier 需要给它添加一些内部状态，这时候我们需要使用 Modifier.composed() 来为它提供一个 Composable 的上下文环境，从而让我们可以使用 remember。 怎么理解这段话？你可以理解成：当我们需要自定义一个 Modifier 时，同时当 Modifier 内部需要用到 remember 时，就需要用到 ComposeModifier。 比如我们修改下前面的 Modifier.composed() 代码： 1234567891011121314151617181920212223class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { ComposeBlogTheme { Column { // 2. 给外部组件调用 Box(Modifier.background(Color.Red) then Modifier.paddingJumpModifier()) Text(&quot;Compose&quot;, Modifier.background(Color.Blue) then Modifier.paddingJumpModifier()) } } } }}// 1. 这里自定义了一个 Modifier.paddingJumpModifierfun Modifier.paddingJumpModifier() { var padding by remember { mutableStateOf(10.dp) } Modifier .padding(padding) .clickable { padding = 0.dp }} 如果你这么写会报错： 报错原因很简单，remember 是一个 Composable 函数，你必须要在 Composable 的上下文环境中才能调用。这时候我们就可以使用 Modifier.composed() 为它提供一个 Composable 的上下文环境，从而让我们可以使用 remember。 写法很简单： 123456fun Modifier.paddingJumpModifier() = composed { var padding by remember { mutableStateOf(10.dp) } Modifier .padding(padding) .clickable { padding = 0.dp }} 这样你的代码就不会报错了，并且所有调用 Modifier.paddingJumpModifier 的地方内部的 padding 状态也是独立的。 为什么 Modifier.composed() 函数内部就可以使用 remember ？ 1234fun Modifier.composed( inspectorInfo: InspectorInfo.() -&gt; Unit = NoInspectorInfo, factory: @Composable Modifier.() -&gt; Modifier // 看这里，它的工厂函数提供了 Composable 上下文环境): Modifier = this.then(ComposedModifier(inspectorInfo, factory)) 所以，factory 工厂函数提供了 Composable 上下文环境，我们就可以调用 remember。 除了可以调用 remember，我们也可以在 Modifier.compose() 内部开启协程： 123456789fun Modifier.paddingJumpModifier() = composed { var padding by remember { mutableStateOf(10.dp) } LaunchedEffect(Unit) { } Modifier .padding(padding) .clickable { padding = 0.dp }} 如果你不加 = composed，那么你调用 LaunchedEffect 就会报错，不信你试试。 最后总结一下 ComposedModifier 或 Modifier.composed()： 按照官方注释的说法，Modifier.composed() 能创建出带有状态的 Modifier，让这个 Modifier 在多处被重用； 有状态的 Modifier 就是被 remember 包着的变量和 Modifier 放在一起作为它的内部状态使用； 重用就是 Modifier.composed() 在每一个使用的地方都创建一个内部状态独立的 Modifier，而不会互相影响； Modifier.composed() 不仅能提供内部状态，在一些需要 Composable 上下文环境，例如 LaunchedEffect 或 CompositionLocal 等地方使用 Modifier，也可以使用它。","link":"/2025/08/03/compose/Compose%20--%20Modifier%20--%2002.%20%E8%A7%A3%E6%9E%90%20ComposedModifier/"},{"title":"深度解析 mutableStateOf 源码","text":"其实原理性分析的文章，真的很难讲的通俗易懂，讲的简单浅显没必要写，讲的繁琐难懂往往大家也不乐意看，所以怎么找个好的角度慢慢钻进去尤为重要，比如：Begin simple code！ Simple Code 正如我上面说的，直接讲原理太枯燥（你也会很懵），我喜欢从简单代码入手，带你一点点进入，现在开始。 先看一个最简单的代码示例： 1234567891011121314class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // 这种定义变量的方式随处可见了 val name = mutableStateOf(&quot;Compose&quot;) setContent { ComposeBlogTheme { Text(name.value) } } }} 我先来简单解读一下这段代码背后的原理： 当我们定义一个变量 name，用 「mutableStateOf」 包起来后：⤵︎它就变成了一个 MutableState 类型的对象（后面会分析源码）。 同时，我们取值的话必须要写 「name.value」，这样能才能取到变量值：”Compose”。⤵︎因为 name 不再是一个 String，而是 MutableState 对象，我们也可以把它叫做「State: 状态」。 此时，name 是一个「被订阅的状态」，「name.value」就是一个被订阅的值：⤵︎如果它发生变化，Text() 函数就会重新执行一遍，更新到最新的值。 现在我们修改下代码，3s 后改变 name.value 的值： 123456789101112131415161718class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val name = mutableStateOf(&quot;Compose&quot;) setContent { ComposeBlogTheme { Text(name.value) } LaunchedEffect(true) { delay(3000) // 3s 延迟 name.value = &quot;Kotlin&quot; // 修改 name.value } } }} 运行，效果如下： 现在关于 mutableStateOf 的用法你已经掌握了，但你会不会产生一个疑问？ name 被「自动订阅」了，它的值改变了就会让界面「重新刷新」，这背后的「状态订阅 &amp; 刷新机制」的原理是什么？ 如果你想深入了解，那么接着往下看。 状态订阅 &amp; 自动刷新 基于 androidx.compose.runtime:runtime:1.7.1 版本 硬核部分走起，查看 mutableStateOf() 源码： 1234fun &lt;T&gt; mutableStateOf( value: T, policy: SnapshotMutationPolicy&lt;T&gt; = structuralEqualityPolicy()): MutableState&lt;T&gt; = createSnapshotMutableState(value, policy) mutableStateOf() 返回的是一个 MutableState 对象，这个我们前面说过。 mutableStateOf() 又调用了另一个函数：createSnapshotMutableState()。 进入 createSnapshotMutableState() ： 1234internal actual fun &lt;T&gt; createSnapshotMutableState( value: T, policy: SnapshotMutationPolicy&lt;T&gt;): SnapshotMutableState&lt;T&gt; = ParcelableSnapshotMutableState(value, policy) 又调用了 ParcelableSnapshotMutableState() 函数： 1234567internal class ParcelableSnapshotMutableState&lt;T&gt;( value: T, policy: SnapshotMutationPolicy&lt;T&gt;) : SnapshotMutableStateImpl&lt;T&gt;(value, policy), Parcelable { // 这里内部的代码全部都是对 Parcelable 接口的实现，我们不用关心，不是核心内容 ... ...} 关键在 SnapshotMutableStateImpl，它里面才是最核心的逻辑： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788internal open class SnapshotMutableStateImpl&lt;T&gt;( value: T, override val policy: SnapshotMutationPolicy&lt;T&gt;) : StateObjectImpl, SnapshotMutableState&lt;T&gt; { @Suppress(&quot;UNCHECKED_CAST&quot;) override var value: T get() = next.readable(this).value set(value) = next.withCurrent { if (!policy.equivalent(it.value, value)) { next.overwritable(this, it) { this.value = value } } } private var next: StateStateRecord&lt;T&gt; = StateStateRecord(value).also { if (Snapshot.isInSnapshot) { it.next = StateStateRecord(value).also { next -&gt; next.snapshotId = Snapshot.PreexistingSnapshotId } } } override val firstStateRecord: StateRecord get() = next override fun prependStateRecord(value: StateRecord) { @Suppress(&quot;UNCHECKED_CAST&quot;) next = value as StateStateRecord&lt;T&gt; } @Suppress(&quot;UNCHECKED_CAST&quot;) override fun mergeRecords( previous: StateRecord, current: StateRecord, applied: StateRecord ): StateRecord? { val previousRecord = previous as StateStateRecord&lt;T&gt; val currentRecord = current as StateStateRecord&lt;T&gt; val appliedRecord = applied as StateStateRecord&lt;T&gt; return if (policy.equivalent(currentRecord.value, appliedRecord.value)) current else { val merged = policy.merge( previousRecord.value, currentRecord.value, appliedRecord.value ) if (merged != null) { appliedRecord.create().also { (it as StateStateRecord&lt;T&gt;).value = merged } } else { null } } } override fun toString(): String = next.withCurrent { &quot;MutableState(value=${it.value})@${hashCode()}&quot; } private class StateStateRecord&lt;T&gt;(myValue: T) : StateRecord() { override fun assign(value: StateRecord) { @Suppress(&quot;UNCHECKED_CAST&quot;) this.value = (value as StateStateRecord&lt;T&gt;).value } override fun create(): StateRecord = StateStateRecord(value) var value: T = myValue } /** * The componentN() operators allow state objects to be used with the property destructuring * syntax */ override operator fun component1(): T = value override operator fun component2(): (T) -&gt; Unit = { value = it } /** * A function used by the debugger to display the value of the current value of the mutable * state object without triggering read observers. */ @Suppress(&quot;unused&quot;) val debuggerDisplayValue: T @JvmName(&quot;getDebuggerDisplayValue&quot;) get() = next.withCurrent { it }.value} 好长啊～算了，不看了🙈… 如果你仍打算继续往下看，那接下来我会带你一步步探索其中的奥秘！ 先看开头部分： 12345678910111213141516171819202122232425internal open class SnapshotMutableStateImpl&lt;T&gt;( value: T, override val policy: SnapshotMutationPolicy&lt;T&gt;) : StateObjectImpl, SnapshotMutableState&lt;T&gt; { @Suppress(&quot;UNCHECKED_CAST&quot;) override var value: T get() = next.readable(this).value set(value) = next.withCurrent { if (!policy.equivalent(it.value, value)) { next.overwritable(this, it) { this.value = value } } } private var next: StateStateRecord&lt;T&gt; = StateStateRecord(value).also { if (Snapshot.isInSnapshot) { it.next = StateStateRecord(value).also { next -&gt; next.snapshotId = Snapshot.PreexistingSnapshotId } } } override val firstStateRecord: StateRecord get() = next ... ...} 一个 value 属性印入眼帘，这就是文章开头代码里面用到的 name.value。 value 有 get() 和 set() 函数，并且都有具体的实现。 📓 next 是个啥？ 无论是 get() 还是 set() 都有一个 next。 12get() = next.readable(this).valueset(value) = next.withCurrent {...} 它是个啥？我们得先搞明白这个！ 1234567private var next: StateStateRecord&lt;T&gt; = StateStateRecord(value).also { if (Snapshot.isInSnapshot) { it.next = StateStateRecord(value).also { next -&gt; next.snapshotId = Snapshot.PreexistingSnapshotId } }} 它的类型是 StateStateRecord，那 StateStateRecord 又是个啥？ 12345678910private class StateStateRecord&lt;T&gt;(myValue: T) : StateRecord() { override fun assign(value: StateRecord) { @Suppress(&quot;UNCHECKED_CAST&quot;) this.value = (value as StateStateRecord&lt;T&gt;).value } override fun create(): StateRecord = StateStateRecord(value) var value: T = myValue} StateStateRecord 又继承了 StateRecord，那 StateRecord 又是个啥呢？ 123456abstract class StateRecord { internal var snapshotId: Int = currentSnapshot().id // 记录快照 id internal var next: StateRecord? = null // 下一个状态记录的引用，状态记录存储在一个链表中 abstract fun assign(value: StateRecord) // 复制 StateRecord abstract fun create(): StateRecord // 创建一个新的记录相同的 StateRecord} 看不懂？没关系，到这里你只需要记住一点：StateRecord 是一个链表的数据结构即可，而 StateStateRecord 实现了它，并且将 value 进行了封装。 下面我们要讲别的了，先记住：StateRecord 是一个链表的数据结构！ 接着说，如果你仔细看代码的话，会发现 SnapshotMutableStateImpl 其实继承了两个接口： 123456internal open class SnapshotMutableStateImpl&lt;T&gt;( value: T, override val policy: SnapshotMutationPolicy&lt;T&gt;) : StateObjectImpl, SnapshotMutableState&lt;T&gt; { ... ...} 一个 StateObjectImpl、一个 SnapshotMutableState。 我们先来看下 SnapshotMutableState： 123456interface SnapshotMutableState&lt;T&gt; : MutableState&lt;T&gt; { /** * A policy to control how changes are handled in a mutable snapshot. */ val policy: SnapshotMutationPolicy&lt;T&gt;} SnapshotMutableState 继承了 MutableState，正好对应着我们文章开头说的，mutableStateOf() 返回的就是一个 MutableState，我们之前说是因为它实现了「订阅」从而可以「刷新」。 但！！！真正的原因并不是因为它！ 真正实现状态订阅机制的是另外一个接口：StateObjet 我们现在来看下 StateObjectImpl 干了什么事： 123internal abstract class StateObjectImpl internal constructor() : StateObject { ...} 实现了 StateObject 接口： 1234567891011121314interface StateObject { /** * The first state record in a linked list of state records. */ val firstStateRecord: StateRecord fun prependStateRecord(value: StateRecord) fun mergeRecords( previous: StateRecord, current: StateRecord, applied: StateRecord ): StateRecord? = null} 代码非常简单，但里面有一个 核心： 1val firstStateRecord: StateRecord 它是干嘛用的？我们去瞅瞅哪里用了它： 12345678910private var next: StateStateRecord&lt;T&gt; = StateStateRecord(value).also { if (Snapshot.isInSnapshot) { it.next = StateStateRecord(value).also { next -&gt; next.snapshotId = Snapshot.PreexistingSnapshotId } }} override val firstStateRecord: StateRecord get() = next 哦，原来 firstStateRecord 是用来记录 StateRecord 这个链表的 头节点 用的。 📓 get() 上面应该算是把 next 是什么讲清楚了吧？ 它就是 StateRecord，更准确的说就是 StateRecord 链表的头节点 下面我们开始扒扒 get() 的逻辑： 1get() = next.readable(this).value 进入 readable() ： 1234567891011fun &lt;T : StateRecord&gt; T.readable(state: StateObject): T { val snapshot = Snapshot.current // 第一件事 snapshot.readObserver?.invoke(state) // 第二件事 return readable(this, snapshot.id, snapshot.invalid) ?: sync { val syncSnapshot = Snapshot.current @Suppress(&quot;UNCHECKED_CAST&quot;) readable(state.firstStateRecord as T, syncSnapshot.id, syncSnapshot.invalid) ?: readError() }} 干了两件事，第一件事： 1snapshot.readObserver?.invoke(state) // 第一件事 readObserver 是一个读操作的观察者，这个操作是记录 StateObject 中的值被哪里调用了，比如开头的代码示例： 1234567891011121314151617181920class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val name = mutableStateOf(&quot;Compose&quot;) setContent { ComposeBlogTheme { // 这里调用了 name.value，就会执行到： // get() --&gt; readObserver() --&gt; 记录这里调用了 value 值 Text(name.value) } LaunchedEffect(true) { delay(3000) name.value = &quot;Kotlin&quot; } } }} 所以，我们可以把这个操作理解为它是一个订阅操作：订阅状态，记录 name.value 在哪里调用了。 第二件事： 12345return readable(this, snapshot.id, snapshot.invalid) ?: sync { val syncSnapshot = Snapshot.current @Suppress(&quot;UNCHECKED_CAST&quot;) readable(state.firstStateRecord as T, syncSnapshot.id, syncSnapshot.invalid) ?: readError()} 又调用了三参数的 readable()： 1234567891011121314151617private fun &lt;T : StateRecord&gt; readable(r: T, id: Int, invalid: SnapshotIdSet): T? { // The readable record is the valid record with the highest snapshotId var current: StateRecord? = r var candidate: StateRecord? = null while (current != null) { if (valid(current, id, invalid)) { candidate = if (candidate == null) current else if (candidate.snapshotId &lt; current.snapshotId) current else candidate } current = current.next } if (candidate != null) { @Suppress(&quot;UNCHECKED_CAST&quot;) return candidate as T } return null} 前边我们说过：StateRecord 是一个链表，而三参数里面的工作就是通过表头对象遍历列表来获取 最新的、有效的 StateRecord。 最终返回一个 最新的、有效的 StateRecord。（什么是最新的、有效的，这个可以不用关心，这跟要结合 Snapshot 快照系统说，你直接过滤即可，不影响我们原理的理解） 所以，整个 readable() 方法就干了两件事： 返回最新的、有效的 StateRecord 记录在哪里调用了 value 1get() = next.readable(this).value 最后还剩一个 value，这就很简单了，前面我们说过 StateStateRecord (StateRecord 的实现类) 会对 value 进行封装，而 StateRecord 只是一个链表，我们要想获取到值，就要再调用 value 获取内部被包着的值。 到这里 get() 就讲完了！ 📓 set() 现在来看 set() 的具体代码：（细节点注意：这边我把代码截图了，而不是纯代码段，你留意一下，下面会回归到这里） next 是啥不用说了吧，那 withCurrent 是什么？ 12inline fun &lt;T : StateRecord, R&gt; T.withCurrent(block: (r: T) -&gt; R): R = block(current(this)) 它只有一个参数 block，而 block 是一个函数类型的参数，它的工作很直接，直接调用这个函数类型的参数，也就是 withCurrent 后面跟着的 Lambda 表达式。 block 里面传入了一个 current 函数，它做了什么： 12345678internal fun &lt;T : StateRecord&gt; current(r: T) = Snapshot.current.let { snapshot -&gt; readable(r, snapshot.id, snapshot.invalid) ?: sync { Snapshot.current.let { syncSnapshot -&gt; readable(r, syncSnapshot.id, syncSnapshot.invalid) } } ?: readError() } 发现了什么？它调用了一个三参数的 readable()，你还记得三参数的 readable() 是做什么的吗？ ⇒ 获取 最新的、有效的 StateRecord。 这个时候你再看下我开头为啥对代码做了截图： 懂啥意思没？withCurrent 传入的 current 函数的返回值就对应着代码提示器提示的 it 对象（一个 StateStateRecord）。 接着看代码： 123456set(value) = next.withCurrent { // 判断新旧值 if (!policy.equivalent(it.value, value)) { next.overwritable(this, it) { this.value = value } }} if 判断里面会判断取到的 StateRecord 的值和新设置的值是否相同，没变直接结束，变了就进入下一步 overwritable()。 我们看看它做了什么： 123456789101112131415internal inline fun &lt;T : StateRecord, R&gt; T.overwritable( state: StateObject, candidate: T, block: T.() -&gt; R): R { var snapshot: Snapshot = snapshotInitializer return sync { // 第一件事 snapshot = Snapshot.current // 第二件事 this.overwritableRecord(state, snapshot, candidate).block() }.also { notifyWrite(snapshot, state) }} 也干了两件事： 获取快照；2. 调用了overwritableRecord() 函数； Snapshot 快照的知识我们可以先忽略，来看 overwritableRecord() 做了什么： 12345678910111213141516171819202122internal fun &lt;T : StateRecord&gt; T.overwritableRecord( state: StateObject, snapshot: Snapshot, candidate: T): T { if (snapshot.readOnly) { // If the snapshot is read-only, use the snapshot recordModified to report it. snapshot.recordModified(state) } val id = snapshot.id // 核心模块 1 if (candidate.snapshotId == id) return candidate // 核心模块 2 val newData = sync { newOverwritableRecordLocked(state) } newData.snapshotId = id if (candidate.snapshotId != Snapshot.PreexistingSnapshotId) snapshot.recordModified(state) return newData} 我们将代码分为两端来看： 核心代码块 1： 如果传进来的 StateRecord 的快照 id 正好对应当前 snapshot 的 id，那么直接返回。 核心代码块 2： 否则会创建一个新的或者返回一个弃用的 StateRecord，然后将快照 id 赋予新的 StateRecord。 说白了最终就是要取到一个对应当前 snapshot 的 StateRecord！ 1234567891011121314internal inline fun &lt;T : StateRecord, R&gt; T.overwritable( state: StateObject, candidate: T, block: T.() -&gt; R): R { var snapshot: Snapshot = snapshotInitializer return sync { snapshot = Snapshot.current // 取到一个对应当前 snapshot 的 StateRecord this.overwritableRecord(state, snapshot, candidate).block() }.also { notifyWrite(snapshot, state) }} 取到对应当前 snapshot 的 StateRecord 后，紧接着调用了 block()，它是传进来的参数，是外面传进来的，也就是 {this.value = value}。 123456set(value) = next.withCurrent { // 判断新旧值 if (!policy.equivalent(it.value, value)) { next.overwritable(this, it) { this.value = value } }} 又拐回来了，把传入的新值赋值给拿到的 StateRecord 内部的 value，这不就是写新值的操作么？ 到这里是不是 set() 流程是不是我们就讲完了？ No～，我们再看一下 overwritable() 方法内部： 1234567891011121314internal inline fun &lt;T : StateRecord, R&gt; T.overwritable( state: StateObject, candidate: T, block: T.() -&gt; R): R { var snapshot: Snapshot = snapshotInitializer return sync { snapshot = Snapshot.current // 这里讲完了 this.overwritableRecord(state, snapshot, candidate).block() }.also { notifyWrite(snapshot, state) // 但这里还有个 notifyWrite }} 还有一行我们遗漏了，notifyWrite() 又做了什么？ 1234internal fun notifyWrite(snapshot: Snapshot, state: StateObject) { snapshot.writeCount += 1 snapshot.writeObserver?.invoke(state)} 有种似曾相识的感觉，在前面分析 get() 函数的时候，我们看到过单参数的 readable() 里面有一行： 1snapshot.readObserver?.invoke(state) 那这里的作用呢？ ⇒ 寻找变量在哪里被读了，然后将这部分内容的组合标记为失效，等到下一帧的时候会重组刷新。 所以，整个 set() 方法就干了两件事： 将传入的值赋值给 StateRecord 内部的 value 写入通知刷新 到这里我们就基本上能够很清晰的明白了状态订阅&amp;自动刷新机制的原理了： 当 get() 被调用的时候，不仅返回值，还会记录读值的地方，也就是哪里调用了（相当于订阅）。 当 set() 被调用的时候，不仅修改值，还会查找读值的地方，然后进行刷新操作（相当于通知）。 代理/委托：by 在实际开发中，如果每次获取值都要加上 value 会显得很冗余，所以 Compose 给我们提供了一种更方便的写法：by。它是 Kotlin 的一个关键字，表示左边的变量用右边的对象作为代理（委托）。 12345678910111213class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val name by mutableStateOf(&quot;Compose&quot;) setContent { ComposeBlogTheme { Text(name) // 可以直接 name，而不需要 name.value } } }} 如果你这么写，IDLE 会提示报错，因为 name 委托给了 mutableStateOf，如果我们要获取 name 的值，那委托对象需要调用 getValue() 和 setValue() 两个函数，这两个函数需要自己实现。 但实际上并不需要我们实现，你通过提示也可以看出来，我们可以直接导入，因为 Compose 内部已经帮我们实现好了这个方法。 12import androidx.compose.runtime.getValueimport androidx.compose.runtime.setValue 自此，关于 Compose 的状态订阅&amp;自动刷新机制的原理算是讲明白了吧！","link":"/2025/06/01/compose/Compose%20--%20%E7%8A%B6%E6%80%81%E8%AE%A2%E9%98%85%20&%20%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%20--%2001.%20%E8%A7%A3%E6%9E%90%20mutableStateOf%20%E6%BA%90%E7%A0%81/"},{"title":"Compose 的「有状态、无状态、状态提升」","text":"先来看两段 Compose 的官方描述： 利用 Compose，你可以构建不与特定 activity 或 fragment 相关联的小型「无状态」组件，这让你可以轻松重用和测试这些组件。 使用 remember 存储对象的可组合项包含「内部状态」，这会使该可组合项「有状态」。在调用方不需要控制状态，并且不必自行管理状态便可使用状态的情况下，「有状态」会非常有用。但是，具有「内部状态」的可组合项往往不易重复使用，也更难测试。 这里，我们可以抛出三个问题： 什么是「无状态」？ 什么是「有状态」？ 什么是「内部状态」？ 带着这三个问题，我们开始探讨 Compose 中的状态。 无状态首先，我们思考下：什么是状态？ 在传统 Android 中，比如 TextView，它的状态就是「内部的属性」，比如我们可以通过 getText() 获取 TextView 的文字，setText() 设置 TextView 的文字。 我们看下面的代码： 12345678910class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { val name = &quot;Hi, Compose&quot; Text(name) } }} 现在思考一个问题：Text() 组件在这里能像 TextView() 一样既能 getText()、也能 setText() 吗？ 很明显不能！ Text(name) 只是用了 name，并没有保存，所以它是一个「无状态组件」。 有状态现在我们自定义一个 Compose 函数： 12345@Composablefun HiCompose() { val name = &quot;Hi, Compose&quot; Text(name)} 请问：Text() 有状态吗？ 没有（我们刚刚才说过） 那么：HiCompose() 呢？ 有！ 它的内部有一个属于它自己的变量：name = “Hi, Compose”，准确的来说，它是有「内部状态」的。 所以，Compose 组件是可以「有状态」，也可以「无状态」，而所谓的有没有状态 - - 其实都是指：「内部状态」！ 状态提升思考一个问题，既然 HiCompose() 函数是有「内部状态」的，那我如果想从「外部」获取它的「内部状态」，该如何做？ 比如下面的代码： 123456789101112131415class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { HiCompose().name ??? // 这里如何获取到 HiCompose 内部的 name? } }}@Composablefun HiCompose() { val name = &quot;Hi, Compose&quot; Text(name)} 这就相当于你要从外部获取一个函数内部的变量，是获取不到的，那如何做呢？ 123456789101112131415class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { val name = &quot;Hi, Compose&quot; HiCompose(name) } }}@Composablefun HiCompose(name: String) { Text(name)} 我们把 HiCompose() 「内部状态」给提到了「参数」里面，然后外部就可以传入「状态」，两者就联系起来了。 在 Compose 中这种做法就叫做：「状态提示」（State Hoisting） 那么，请问此时 HiCompose 还有状态吗？ 现在它就是「无状态」的！ 因为它已经没有「内部状态」了，状态上提到外面去了。 输入框：TextFieldCompose 有一个典型的状态提升的组件示例：TextField，它是一个文本输入框，类似于 EditText。 123456789class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { TextField(value = , onValueChange = ) } }} 其中 value 就是从 TextField 内部提升上来的，我们来给它传个值： 12345678910class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { var name = &quot;&quot; TextField(name, onValueChange = ) } }} onValueChange 是一个函数类型的参数，可以写成 Lambda 表达式： 12345678910111213class MainActivity : ComponentActivity() { @OptIn(ExperimentalMaterial3Api::class) override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { var name = &quot;&quot; TextField(name, { }) } }} 此时什么也没填，运行看下效果： 键盘都敲冒烟了，但是输入框却没有任何内容，问题肯定出在 onValueChange，因为我们什么也没填，那填什么？ 12345678910111213class MainActivity : ComponentActivity() { @OptIn(ExperimentalMaterial3Api::class) override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { var name = &quot;&quot; TextField(name, { newValue -&gt; name = newValue }) } }} 这就这么简单，newValue 就是输入的内容，把 newValue 赋值给 name，name 才是输入框显示的内容实际值。 运行看下效果： 怎么还不行？如果你看了之前的文章，应该能找到问题点在哪！ 直接修改代码： 12345678910111213class MainActivity : ComponentActivity() { @OptIn(ExperimentalMaterial3Api::class) override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { var name by remember { mutableStateOf(&quot;&quot;) } TextField(name, { newValue -&gt; name = newValue }) } }} 再次运行： 如果你没看懂为啥这么改，赶紧回去看前两篇文章吧！","link":"/2025/06/13/compose/Compose%20--%20%E7%8A%B6%E6%80%81%E8%AE%A2%E9%98%85%20&%20%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%20--%2003.%20%E6%9C%89%E7%8A%B6%E6%80%81%E3%80%81%E6%97%A0%E7%8A%B6%E6%80%81%E3%80%81%E7%8A%B6%E6%80%81%E6%8F%90%E5%8D%87/"}],"tags":[{"name":"Compose","slug":"Compose","link":"/tags/Compose/"},{"name":"Modifier","slug":"Modifier","link":"/tags/Modifier/"},{"name":"CombinedModifier","slug":"CombinedModifier","link":"/tags/CombinedModifier/"},{"name":"LayoutModifier","slug":"LayoutModifier","link":"/tags/LayoutModifier/"},{"name":"状态订阅 &amp; 自动更新","slug":"状态订阅-自动更新","link":"/tags/%E7%8A%B6%E6%80%81%E8%AE%A2%E9%98%85-%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0/"},{"name":"mutableStateListOf","slug":"mutableStateListOf","link":"/tags/mutableStateListOf/"},{"name":"重组","slug":"重组","link":"/tags/%E9%87%8D%E7%BB%84/"},{"name":"remember","slug":"remember","link":"/tags/remember/"},{"name":"重组作用域","slug":"重组作用域","link":"/tags/%E9%87%8D%E7%BB%84%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"name":"DrawModifier","slug":"DrawModifier","link":"/tags/DrawModifier/"},{"name":"ComposedModifier","slug":"ComposedModifier","link":"/tags/ComposedModifier/"},{"name":"Compose 状态","slug":"Compose-状态","link":"/tags/Compose-%E7%8A%B6%E6%80%81/"}],"categories":[{"name":"Compose","slug":"Compose","link":"/categories/Compose/"},{"name":"状态订阅 &amp; 自动更新","slug":"Compose/状态订阅-自动更新","link":"/categories/Compose/%E7%8A%B6%E6%80%81%E8%AE%A2%E9%98%85-%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0/"},{"name":"Modifier","slug":"Compose/Modifier","link":"/categories/Compose/Modifier/"}],"pages":[]}